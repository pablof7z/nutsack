This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*, .cursorrules, .cursor/rules/*, .clinerules, CLAUDE.md
- Files matching these patterns are excluded: .*.*, **/*.pbxproj, **/node_modules/**, **/dist/**, **/build/**, **/compile/**, **/*.spec.*, **/*.pyc, **/.env, **/.env.*, **/*.env, **/*.env.*, **/*.lock, **/*.lockb, **/package-lock.*, **/pnpm-lock.*, **/*.tsbuildinfo, **/certdata.txt
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    ci.yml
    README.md
    testflight.yml
maestro/
  tests/
    add_mint_test.yaml
  README.md
  test_account_creation.yaml
  test_auth_persistence.yaml
  test_login_flow.yaml
maestro-tests/
  01-onboarding.yaml
  02-minting.yaml
  03-melting.yaml
  04-cashu-send.yaml
  05-cashu-receive.yaml
  06-nutzap.yaml
  07-mint-management.yaml
  08-backup-restore.yaml
  09-transactions-history.yaml
  10-proof-management.yaml
  basic-wallet-operations.yaml
  create-account.yaml
  launch-app.yaml
  README.md
Sources/
  NutsackiOS/
    Assets.xcassets/
      AppIcon.appiconset/
        Contents.json
      Contents.json
    DataSources/
      NostrDataSources.swift
      WalletDataSources.swift
    Models/
      AppState.swift
      DataModels.swift
      NostrManager.swift
      WalletEventInfo.swift
      WalletManager.swift
    Utils/
      AppIconGenerator.swift
      PlatformHelpers.swift
      QRCodeGenerator.swift
      QRScannerView.swift
    Views/
      Alerts/
        MintFailureAlert.swift
      Auth/
        AuthenticationFlow.swift
      Helpers/
        AsyncContentView.swift
      Utils/
        RelativeTimeView.swift
        UserProfileViews.swift
      Wallet/
        BalanceCard.swift
        DLEQStatusIndicator.swift
        MintAllocationPieChart.swift
        MintBalanceLegend.swift
        MintDetailView.swift
        MintView.swift
        NutzapView.swift
        PaymentReceivedAnimation.swift
        ProofManagementView.swift
        ReceivedNutzapsView.swift
        ReceiveView.swift
        RecentTransactionsView.swift
        RelayHealthView.swift
        RelayStatusIndicator.swift
        SendView.swift
        SwapView.swift
        TokenConfirmationView.swift
        TransactionDetailDrawer.swift
        WalletEventDetailView.swift
        WalletEventsView.swift
        WalletSettingsView.swift
        WalletView.swift
        WalletView.swift.backup
      BlacklistedMintsView.swift
      ContactsView.swift
      ContentView.swift
      DebugLoggingView.swift
      DiscoveredMintsView.swift
      MintsView.swift
      NutLogoView.swift
      NutzapSettingsView.swift
      RelayManagementView.swift
      SettingsView.swift
      SplashView.swift
      WalletOnboardingView.swift
    Info.plist
    LaunchScreen.storyboard
    NutsackApp.swift
    NutsackiOS.xcconfig
.gitignore
.repomixignore
build.sh
deploy.sh
ExportOptions-TestFlight.plist
fix_renaming.py
LICENSE
project.yml
README.md
refresh-project.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/README.md">
# CI/CD Setup for Nutsack

This repository uses GitHub Actions for continuous integration and deployment to TestFlight.

## Workflows

### CI (`ci.yml`)
- Runs on every push to main/master and on pull requests
- Builds the app for iOS Simulator
- Runs tests if available
- Uses Xcode 15.4 on macOS 14

### TestFlight Deployment (`testflight.yml`)
- Triggered by version tags (e.g., `v1.0.0`) or manual dispatch
- Builds the app for release
- Archives and exports IPA
- Uploads to TestFlight using App Store Connect API

## Required Secrets

Configure these secrets in your repository settings:

- `APP_STORE_CONNECT_API_KEY`: Base64 encoded .p8 key file
- `APP_STORE_CONNECT_API_KEY_ID`: Your API Key ID
- `APP_STORE_CONNECT_ISSUER_ID`: Your Issuer ID
- `DEVELOPMENT_TEAM`: Your Apple Developer Team ID (e.g., "456SHKPP26")

## Deployment Process

1. Create a version tag:
   ```bash
   git tag v1.0.0
   git push origin v1.0.0
   ```

2. The workflow will automatically:
   - Build the app
   - Create an IPA file
   - Upload to TestFlight

3. Or trigger manually from GitHub Actions tab

## Local Testing

To test the build process locally:
```bash
./build.sh
```

To deploy manually:
```bash
./deploy.sh
```
</file>

<file path="maestro/tests/add_mint_test.yaml">
appId: io.nutsack.app
---
# Test: Add Mint Flow
# This test verifies that adding a new mint works correctly
# and that the mint appears in the mint list after adding
- runFlow:
    file: ../setup/login_test_account.yaml
# Navigate to Settings
- tapOn:
    text: "Settings"
# Navigate to Mints
- tapOn:
    text: "Mints"
# Wait for mints to load
- assertVisible:
    text: "Mints"
    timeout: 5000
# Take screenshot of initial mint list
- takeScreenshot: "mint_list_before_add"
# Tap Add Mint button
- tapOn:
    text: "Add Mint"
# Wait for Add Mint sheet to appear
- assertVisible:
    text: "Mint URL"
    timeout: 3000
# Take screenshot of add mint sheet
- takeScreenshot: "add_mint_sheet"
# Clear any existing text first
- clearText
# Enter a test mint URL
- inputText: "https://mint.minibits.cash/Bitcoin"
# Take screenshot after entering URL
- takeScreenshot: "mint_url_entered"
# Tap the Add Mint action button
- tapOn:
    text: "Add Mint"
    index: 1  # Second "Add Mint" is the action button
# Check if error appeared
- extendedWaitUntil:
    visible:
        text: "Failed to add mint"
    timeout: 2000
# If no error, wait for the sheet to dismiss
- waitForNotVisible:
    text: "Mint URL"
    timeout: 20000
# Wait a bit for the list to update
- waitForAnimationToEnd
# Pull to refresh the mint list
- scroll:
    direction: DOWN
    duration: 1000
# Wait for refresh to complete
- waitForAnimationToEnd
# Take screenshot after adding
- takeScreenshot: "mint_list_after_add"
# Verify the mint was added by checking for its host
- assertVisible:
    text: "mint.minibits.cash"
    timeout: 10000
# Verify we can tap on the mint to see details
- tapOn:
    text: "mint.minibits.cash"
# Verify mint detail view opened
- assertVisible:
    text: "Mint Information"
    timeout: 3000
# Take screenshot of mint details
- takeScreenshot: "mint_details"
# Go back to mints list
- tapOn:
    id: ".*back.*|.*Back.*"
    enabled: true
# Clean up: Remove the mint we just added
- tapOn:
    text: "mint.minibits.cash"
- tapOn:
    text: "Remove Mint"
# Confirm removal
- tapOn:
    text: "Remove"
    index: 1  # The destructive action button
# Verify mint was removed
- waitForNotVisible:
    text: "mint.minibits.cash"
    timeout: 5000
- takeScreenshot: "mint_removed_successfully"
</file>

<file path="maestro/README.md">
# NutsackiOS Maestro Tests

This directory contains Maestro tests for the NutsackiOS app authentication flows.

## Prerequisites

1. Install Maestro CLI: https://maestro.mobile.dev/getting-started/installing-maestro
2. Have an iOS Simulator running with the NutsackiOS app installed

## Running Tests

To run all tests:
```bash
maestro test maestro/
```

To run a specific test:
```bash
maestro test maestro/test_account_creation.yaml
```

## Test Descriptions

### test_account_creation.yaml
Tests the complete account creation flow:
- Opens the app
- Creates a new account with display name and about text
- Verifies the backup key screen appears
- Confirms navigation to the main wallet interface

### test_login_flow.yaml
Tests logging in with an existing nsec:
- Opens the app
- Navigates to import account screen
- Enters an nsec private key
- Verifies successful login to the main interface

### test_auth_persistence.yaml
Tests that authentication persists after login (addresses the issue where users were being returned to the login screen):
- Creates a new account
- Verifies the user stays in the main app
- Tests navigation between tabs
- Ensures the authentication screen doesn't reappear

## Debugging Failed Tests

If tests fail, you can run them with debug output:
```bash
maestro test --debug maestro/test_auth_persistence.yaml
```

You can also use Maestro Studio for interactive debugging:
```bash
maestro studio
```

## Test Private Keys

The test uses a dummy nsec for testing login:
- `nsec1vl029mgpspedva04g90vltkh6fvh240zqtv9k0t9af8935ke9laqsnlfe5`

**Warning**: This is a test key only. Never use real private keys in tests.
</file>

<file path="maestro/test_account_creation.yaml">
appId: com.nutsack.wallet
---
# Test Account Creation Flow
- launchApp
# Wait for app to initialize
- assertVisible:
    text: "Nutsack"
- assertVisible:
    text: "Lightning-fast payments with Nostr"
# Click Create Account button
- tapOn:
    text: "Create Account"
# Wait for Create Account screen
- assertVisible:
    text: "Profile Information"
# Fill in display name
- tapOn:
    text: "Display Name"
- inputText: "Test User ${TIMESTAMP}"
# Fill in about (optional)
- tapOn:
    text: "About (optional)"
- inputText: "Test account created by Maestro"
# Create the account
- tapOn:
    text: "Create Account"
# Wait for account creation to complete
- waitForAnimationToEnd
# Should see the backup key screen
- assertVisible:
    text: "Save Your Private Key"
- assertVisible:
    text: "This is the only way to access your account"
# Verify nsec is displayed
- assertVisible:
    text: "Your private key (nsec):"
- assertVisible:
    id: ".*nsec1.*"  # Regex to match nsec format
# Toggle the saved key checkbox
- tapOn:
    text: "I have saved my private key"
# Continue to wallet
- tapOn:
    text: "Continue to Wallet"
# Verify we're in the main app
- assertVisible:
    text: "Wallet"
- assertVisible:
    id: ".*TabView.*"  # Should see the tab view
# Verify we don't see the authentication screen anymore
- assertNotVisible:
    text: "Lightning-fast payments with Nostr"
- assertNotVisible:
    text: "Create Account"
</file>

<file path="maestro/test_auth_persistence.yaml">
appId: com.nutsack.wallet
---
# Test Authentication Persistence
# This test verifies that after successful authentication, 
# the user stays in the main app and doesn't return to login
- launchApp
# Create a new account first
- tapOn:
    text: "Create Account"
- tapOn:
    text: "Display Name"
- inputText: "Persistence Test User"
- tapOn:
    text: "Create Account"
# Wait a moment for the action to process
- waitForAnimationToEnd
# Handle potential error alert (if account creation fails)
- tapOn: 
    text: "OK"
    optional: true
# Wait for account creation - increase timeout
- extendedWaitUntil:
    visible:
      text: "Save Your Private Key"
    timeout: 15000
# Handle backup key screen
- assertVisible:
    text: "Save Your Private Key"
- tapOn:
    text: "I have saved my private key"
- tapOn:
    text: "Continue to Wallet"
# Wait for navigation
- waitForAnimationToEnd
# Now verify we're in the main app and stay there
- assertVisible:
    text: "Wallet"
# Wait a bit to ensure no unexpected navigation
- waitForAnimationToEnd
# Verify we're still in the main app (not back at login)
- assertVisible:
    text: "Wallet"
- assertNotVisible:
    text: "Create Account"
- assertNotVisible:
    text: "Import with nsec"
# Try navigating between tabs to ensure app is stable
- tapOn:
    text: "Contacts"
- assertVisible:
    text: "Contacts"
- tapOn:
    text: "Settings"
- assertVisible:
    text: "Settings"
- tapOn:
    text: "Wallet"
- assertVisible:
    text: "Wallet"
# Final check - still authenticated
- assertNotVisible:
    text: "Lightning-fast payments with Nostr"
</file>

<file path="maestro/test_login_flow.yaml">
appId: com.nutsack.wallet
---
# Test Login Flow with Existing nsec
- launchApp
# Wait for app to initialize
- assertVisible:
    text: "Nutsack"
- assertVisible:
    text: "Lightning-fast payments with Nostr"
# Click Import with nsec button
- tapOn:
    text: "Import with nsec"
# Wait for Import Account screen
- assertVisible:
    text: "Private Key"
# Enter a test nsec (this is a dummy key for testing)
- tapOn:
    text: "nsec1..."
- inputText: "nsec1vl029mgpspedva04g90vltkh6fvh240zqtv9k0t9af8935ke9laqsnlfe5"
# Login
- tapOn:
    text: "Log In"
# Wait for login to complete
- waitForAnimationToEnd
# Verify we're in the main app
- assertVisible:
    text: "Wallet"
- assertVisible:
    id: ".*TabView.*"  # Should see the tab view
# Verify we don't see the authentication screen anymore
- assertNotVisible:
    text: "Lightning-fast payments with Nostr"
- assertNotVisible:
    text: "Import with nsec"
</file>

<file path="maestro-tests/01-onboarding.yaml">
appId: com.nutsack.wallet
---
# Test: New User Onboarding Flow
- launchApp
- clearState
# Verify welcome screen
- assertVisible: "Nutsack"
- assertVisible: "Lightning-fast payments with Nostr"
- assertVisible: "Create Account"
- assertVisible: "Import with nsec"
# Test creating new account
- tapOn: "Create Account"
- waitForAnimationToEnd
# Should show wallet setup
- assertVisible:
    text: ".*[Ww]allet.*"
    optional: true
# Configure mint (if prompted)
- tapOn:
    text: ".*[Aa]dd.*[Mm]int.*"
    optional: true
- inputText: "https://mint.minibits.cash/Bitcoin"
- tapOn: 
    text: "Add"
    optional: true
- waitForAnimationToEnd
# Verify wallet is created
- assertVisible:
    text: "0"  # Initial balance
    optional: true
- assertVisible:
    text: "sats"
    optional: true
# Take screenshot for documentation
- takeScreenshot: "wallet-created"
</file>

<file path="maestro-tests/02-minting.yaml">
appId: com.nutsack.wallet
---
# Test: Minting (Adding funds via Lightning)
- launchApp
# Navigate to Receive/Mint
- tapOn:
    text: "Receive"
    optional: true
- tapOn:
    id: "receive-button"
    optional: true
- tapOn:
    text: "Mint"
    optional: true
# Enter amount
- tapOn:
    id: "amount-field"
    optional: true
- clearText
- inputText: "1000"
# Generate Lightning invoice
- tapOn: 
    text: "Generate"
    optional: true
- tapOn:
    text: "Create Invoice"
    optional: true
# Verify invoice QR code is shown
- assertVisible:
    id: "qr-code"
    optional: true
- assertVisible:
    text: ".*lightning:.*"
    optional: true
# Copy invoice (for testing)
- tapOn:
    text: "Copy"
    optional: true
- takeScreenshot: "lightning-invoice"
# Simulate payment received (in real test, would pay externally)
- waitForAnimationToEnd
# Go back and verify balance updated
- back
- assertNotVisible:
    text: "0 sats"
    optional: true
</file>

<file path="maestro-tests/03-melting.yaml">
appId: com.nutsack.wallet
---
# Test: Melting (Withdrawing via Lightning)
- launchApp
# Navigate to Send/Melt
- tapOn:
    text: "Send"
    optional: true
- tapOn:
    id: "send-button"
    optional: true
- tapOn:
    text: "Melt"
    optional: true
# Paste or scan Lightning invoice
- tapOn:
    text: "Paste"
    optional: true
- tapOn:
    id: "paste-button"
    optional: true
# Alternative: Enter invoice manually
- tapOn:
    id: "invoice-field"
    optional: true
- inputText: "lnbc1000n1..." # Sample invoice
# Verify amount and fees
- assertVisible:
    text: ".*[Aa]mount.*"
- assertVisible:
    text: ".*[Ff]ee.*"
    optional: true
# Confirm payment
- tapOn:
    text: "Send"
    optional: true
- tapOn:
    text: "Confirm"
    optional: true
# Handle authentication if required
- tapOn:
    id: "authenticate"
    optional: true
# Wait for payment
- waitForAnimationToEnd
# Verify success
- assertVisible:
    text: ".*[Ss]uccess.*"
    optional: true
- assertVisible:
    text: ".*[Pp]aid.*"
    optional: true
- takeScreenshot: "payment-success"
# Go back to wallet
- back
- back
</file>

<file path="maestro-tests/04-cashu-send.yaml">
appId: com.nutsack.wallet
---
# Test: Sending Cashu tokens (ecash)
- launchApp
# Navigate to Send
- tapOn:
    text: "Send"
    optional: true
- tapOn:
    id: "send-button"
    optional: true
# Select Cashu/Token option
- tapOn:
    text: "Token"
    optional: true
- tapOn:
    text: "Cashu"
    optional: true
# Enter amount
- tapOn:
    id: "amount-field"
    optional: true
- clearText
- inputText: "100"
# Add optional memo
- tapOn:
    id: "memo-field"
    optional: true
- inputText: "Test payment"
# Generate token
- tapOn:
    text: "Create Token"
    optional: true
- tapOn:
    text: "Generate"
    optional: true
# Verify token is created
- assertVisible:
    text: "cashuA.*"  # Token should start with cashuA
    optional: true
# Copy token
- tapOn:
    text: "Copy"
    optional: true
- tapOn:
    text: "Share"
    optional: true
- takeScreenshot: "cashu-token-created"
# Go back
- back
</file>

<file path="maestro-tests/05-cashu-receive.yaml">
appId: com.nutsack.wallet
---
# Test: Receiving Cashu tokens
- launchApp
# Navigate to Receive
- tapOn:
    text: "Receive"
    optional: true
- tapOn:
    id: "receive-button"
    optional: true
# Select Token/Cashu option
- tapOn:
    text: "Token"
    optional: true
- tapOn:
    text: "Redeem"
    optional: true
# Paste token
- tapOn:
    id: "token-field"
    optional: true
- inputText: "cashuAeyJ0b2tlbiI6W3sibWludCI6Imh0dHBzOi8vbWludC5taW5pYml0cy5jYXNoL0JpdGNvaW4i..."
# Alternatively, scan QR
- tapOn:
    text: "Scan"
    optional: true
- waitForAnimationToEnd
- tapOn:
    text: "Allow"  # Camera permission
    optional: true
# Redeem token
- tapOn:
    text: "Redeem"
    optional: true
- tapOn:
    text: "Claim"
    optional: true
# Wait for redemption
- waitForAnimationToEnd
# Verify success
- assertVisible:
    text: ".*[Ss]uccess.*"
    optional: true
- assertVisible:
    text: ".*[Rr]edeemed.*"
    optional: true
- assertVisible:
    text: ".*100.*sats.*"  # Amount received
    optional: true
- takeScreenshot: "token-redeemed"
# Go back to wallet
- back
</file>

<file path="maestro-tests/06-nutzap.yaml">
appId: com.nutsack.wallet
---
# Test: Nutzap - Zapping on Nostr with Cashu
- launchApp
# Navigate to Nutzap feature
- tapOn:
    text: "Zap"
    optional: true
- tapOn:
    text: "Nutzap"
    optional: true
- tapOn:
    id: "nutzap-tab"
    optional: true
# Enter Nostr note ID or user
- tapOn:
    id: "nostr-id-field"
    optional: true
- inputText: "npub1..."  # Sample Nostr pubkey
# Alternative: Paste note ID
- tapOn:
    text: "note1..."
    optional: true
# Set zap amount
- tapOn:
    id: "zap-amount"
    optional: true
- clearText
- inputText: "21"  # Common zap amount
# Add zap comment (optional)
- tapOn:
    id: "zap-comment"
    optional: true
- inputText: "Great post! ⚡"
# Select mint for zapping
- tapOn:
    text: ".*[Mm]int.*"
    optional: true
- tapOn:
    text: "minibits"  # Select specific mint
    optional: true
# Send zap
- tapOn:
    text: "Zap"
    optional: true
- tapOn:
    text: "Send Zap"
    optional: true
# Confirm
- tapOn:
    text: "Confirm"
    optional: true
# Wait for zap to process
- waitForAnimationToEnd
# Verify success
- assertVisible:
    text: ".*[Zz]apped.*"
    optional: true
- assertVisible:
    text: "⚡"
    optional: true
- takeScreenshot: "nutzap-sent"
# Check zap history
- tapOn:
    text: "History"
    optional: true
- assertVisible:
    text: "21 sats"
    optional: true
# Go back
- back
</file>

<file path="maestro-tests/07-mint-management.yaml">
appId: com.nutsack.wallet
---
# Test: Managing Mints
- launchApp
# Navigate to Settings/Mints
- tapOn:
    text: "Settings"
    optional: true
- tapOn:
    id: "settings-tab"
    optional: true
- tapOn:
    text: "Mints"
# View current mints
- assertVisible:
    text: ".*mint.*"
    optional: true
# Add new mint
- tapOn:
    text: "Add Mint"
    optional: true
- tapOn:
    text: "+"
    optional: true
# Enter mint URL
- tapOn:
    id: "mint-url-field"
    optional: true
- inputText: "https://legend.lnbits.com/cashu/api/v1/AptDNABNBXv8gpuywhx6NV"
# Add mint
- tapOn:
    text: "Add"
    optional: true
- tapOn:
    text: "Connect"
    optional: true
# Wait for mint info to load
- waitForAnimationToEnd
# Verify mint added
- assertVisible:
    text: "legend.lnbits"
    optional: true
# Check mint balance
- tapOn:
    text: "legend.lnbits"
    optional: true
- assertVisible:
    text: ".*[Bb]alance.*"
    optional: true
- assertVisible:
    text: ".*[Kk]eyset.*"
    optional: true
- takeScreenshot: "mint-details"
# Test mint swap
- tapOn:
    text: "Swap"
    optional: true
- tapOn:
    id: "swap-button"
    optional: true
# Go back
- back
- back
</file>

<file path="maestro-tests/08-backup-restore.yaml">
appId: com.nutsack.wallet
---
# Test: Backup and Restore Wallet
- launchApp
# Navigate to Settings
- tapOn:
    text: "Settings"
    optional: true
- tapOn:
    id: "settings-tab"
    optional: true
# Go to Backup section
- tapOn:
    text: "Backup"
    optional: true
- tapOn:
    text: "Export"
    optional: true
# View recovery phrase
- tapOn:
    text: "Show Recovery Phrase"
    optional: true
- tapOn:
    text: "View Seed"
    optional: true
# Authenticate if required
- tapOn:
    id: "authenticate"
    optional: true
# Verify seed words shown
- assertVisible:
    text: ".*word.*"
    optional: true
- assertVisible:
    text: "[1-9]"  # Word numbers
    optional: true
- takeScreenshot: "recovery-phrase"
# Copy seed phrase
- tapOn:
    text: "Copy"
    optional: true
# Test NIP-60 wallet backup
- back
- tapOn:
    text: "Nostr Backup"
    optional: true
- tapOn:
    text: "Backup to Nostr"
    optional: true
# Confirm backup
- tapOn:
    text: "Backup Now"
    optional: true
# Wait for backup
- waitForAnimationToEnd
# Verify backup success
- assertVisible:
    text: ".*[Bb]acked up.*"
    optional: true
- assertVisible:
    text: ".*[Ss]uccess.*"
    optional: true
# Test restore flow
- back
- back
- tapOn:
    text: "Settings"
- tapOn:
    text: "Advanced"
    optional: true
- tapOn:
    text: "Reset Wallet"
    optional: true
# Confirm reset
- tapOn:
    text: "Reset"
    optional: true
- tapOn:
    text: "Confirm"
    optional: true
# Should return to onboarding
- assertVisible: "Import with nsec"
# Import from seed
- tapOn: "Import with nsec"
- tapOn:
    id: "nsec-field"
    optional: true
- inputText: "nsec1..."  # Would paste actual nsec
# Complete import
- tapOn:
    text: "Import"
    optional: true
# Wait for restore
- waitForAnimationToEnd
# Verify wallet restored
- assertVisible:
    text: ".*[Ww]allet.*"
    optional: true
- takeScreenshot: "wallet-restored"
</file>

<file path="maestro-tests/09-transactions-history.yaml">
appId: com.nutsack.wallet
---
# Test: Transaction History and Details
- launchApp
# View transaction history
- tapOn:
    text: "History"
    optional: true
- tapOn:
    text: "Transactions"
    optional: true
- tapOn:
    id: "transactions-tab"
    optional: true
# Verify transaction list
- assertVisible:
    text: ".*[Tt]ransaction.*"
    optional: true
# Filter transactions
- tapOn:
    text: "Filter"
    optional: true
- tapOn:
    id: "filter-button"
    optional: true
# Select transaction type
- tapOn:
    text: "Sent"
    optional: true
- tapOn:
    text: "Apply"
    optional: true
# Verify filtered results
- assertVisible:
    text: ".*Send.*|.*Sent.*"
    optional: true
# Reset filter
- tapOn:
    text: "Filter"
    optional: true
- tapOn:
    text: "All"
    optional: true
- tapOn:
    text: "Apply"
    optional: true
# View transaction details
- tapOn:
    index: 0  # First transaction
    optional: true
# Verify transaction details
- assertVisible:
    text: ".*[Aa]mount.*"
    optional: true
- assertVisible:
    text: ".*[Dd]ate.*"
    optional: true
- assertVisible:
    text: ".*[Tt]ype.*"
    optional: true
# Check proof details for Cashu transactions
- assertVisible:
    text: ".*[Pp]roof.*"
    optional: true
- assertVisible:
    text: ".*[Mm]int.*"
    optional: true
- takeScreenshot: "transaction-details"
# Export transaction
- tapOn:
    text: "Export"
    optional: true
- tapOn:
    text: "Share"
    optional: true
# Go back
- back
- back
</file>

<file path="maestro-tests/10-proof-management.yaml">
appId: com.nutsack.wallet
---
# Test: Proof Management and DLEQ Verification
- launchApp
# Navigate to advanced settings
- tapOn:
    text: "Settings"
    optional: true
- tapOn:
    text: "Advanced"
    optional: true
- tapOn:
    text: "Proof Management"
    optional: true
# View current proofs
- assertVisible:
    text: ".*[Pp]roof.*"
    optional: true
- assertVisible:
    text: ".*DLEQ.*"
    optional: true
# Check DLEQ status indicators
- assertVisible:
    id: "dleq-valid"
    optional: true
- assertVisible:
    text: "✓"  # Valid indicator
    optional: true
# Select suspicious proofs
- tapOn:
    text: "Unverified"
    optional: true
- tapOn:
    text: "Check All"
    optional: true
# Verify proofs
- tapOn:
    text: "Verify"
    optional: true
# Wait for verification
- waitForAnimationToEnd
# Check verification results
- assertVisible:
    text: ".*[Vv]erified.*"
    optional: true
# Consolidate proofs
- tapOn:
    text: "Consolidate"
    optional: true
- tapOn:
    text: "Optimize Proofs"
    optional: true
# Confirm consolidation
- tapOn:
    text: "Confirm"
    optional: true
# Wait for consolidation
- waitForAnimationToEnd
# Verify consolidation success
- assertVisible:
    text: ".*[Oo]ptimized.*"
    optional: true
- takeScreenshot: "proof-management"
# Check spent proofs
- tapOn:
    text: "Spent"
    optional: true
- assertVisible:
    text: ".*[Ss]pent.*"
    optional: true
# Clean up spent proofs
- tapOn:
    text: "Clean Up"
    optional: true
- tapOn:
    text: "Remove Spent"
    optional: true
# Go back
- back
- back
</file>

<file path="maestro-tests/basic-wallet-operations.yaml">
appId: com.nutsack.wallet
---
# Test 1: Create a new account
- launchApp
- assertVisible: "Create Account"
- tapOn: "Create Account"
# Wait for account creation
- waitForAnimationToEnd
# Test 2: Check wallet view is displayed
- assertVisible: 
    text: ".*[Bb]alance.*"
    optional: true
- assertVisible:
    text: ".*[Ww]allet.*"
    optional: true
# Test 3: Navigate to receive screen
- tapOn: 
    text: "Receive"
    optional: true
- tapOn:
    id: "receive-button"
    optional: true
# Test 4: Check receive screen elements
- assertVisible:
    text: ".*QR.*"
    optional: true
- assertVisible:
    text: ".*[Aa]mount.*"
    optional: true
# Test 5: Go back to wallet
- back
# Test 6: Navigate to send screen
- tapOn:
    text: "Send"
    optional: true
- tapOn:
    id: "send-button" 
    optional: true
# Test 7: Check send screen elements
- assertVisible:
    text: ".*[Aa]mount.*"
    optional: true
- assertVisible:
    text: ".*[Dd]estination.*|.*[Tt]o.*"
    optional: true
# Test 8: Go back to wallet
- back
# Test 9: Navigate to settings
- tapOn:
    text: "Settings"
    optional: true
- tapOn:
    id: "settings-button"
    optional: true
# Test 10: Check settings options
- assertVisible:
    text: ".*[Mm]ints.*"
    optional: true
- assertVisible:
    text: ".*[Bb]ackup.*|.*[Ee]xport.*"
    optional: true
</file>

<file path="maestro-tests/create-account.yaml">
appId: com.nutsack.wallet
---
- launchApp
- assertVisible: "Nutsack"
- assertVisible: "Create Account"
- tapOn: "Create Account"
- waitForAnimationToEnd
</file>

<file path="maestro-tests/launch-app.yaml">
appId: com.nutsack.wallet
---
- launchApp
- assertVisible: ".*"
</file>

<file path="maestro-tests/README.md">
# Nutsack Wallet Maestro Test Suite

This directory contains comprehensive Maestro UI tests for the Nutsack wallet app, covering all major wallet operations and features.

## Prerequisites

1. Install Maestro: `brew install maestro`
2. Have iOS Simulator running with Nutsack app installed
3. Configure Maestro for iOS testing if needed

## Test Files

### Core Wallet Operations

1. **01-onboarding.yaml** - New user account creation and wallet setup
2. **02-minting.yaml** - Adding funds via Lightning (minting ecash)
3. **03-melting.yaml** - Withdrawing funds via Lightning (melting ecash)
4. **04-cashu-send.yaml** - Creating and sending Cashu tokens
5. **05-cashu-receive.yaml** - Receiving and redeeming Cashu tokens

### Advanced Features

6. **06-nutzap.yaml** - Zapping on Nostr using Cashu tokens
7. **07-mint-management.yaml** - Adding and managing multiple mints
8. **08-backup-restore.yaml** - Wallet backup and recovery flows
9. **09-transactions-history.yaml** - Viewing and filtering transaction history
10. **10-proof-management.yaml** - DLEQ verification and proof optimization

### Utility Tests

- **basic-wallet-operations.yaml** - Quick smoke test of basic features
- **create-account.yaml** - Simple account creation test

## Running Tests

### Run Individual Test
```bash
maestro test 01-onboarding.yaml
```

### Run All Tests
```bash
maestro test .
```

### Run with Reporting
```bash
maestro test --format junit --output results.xml .
```

### Interactive Mode
```bash
maestro studio
```

## Test Coverage

The test suite covers:

- ✅ Account creation and import
- ✅ Lightning integration (mint/melt)
- ✅ Cashu token operations
- ✅ Nostr integration (Nutzaps)
- ✅ Multi-mint support
- ✅ Backup and restore (including NIP-60)
- ✅ Transaction history
- ✅ Proof management and DLEQ verification
- ✅ QR code scanning and generation
- ✅ Error handling and edge cases

## Notes

- Tests assume a clean app state. Use `clearState` command if needed
- Some tests require external services (Lightning nodes, mints) to be available
- Timeouts may need adjustment based on network conditions
- Screenshots are captured at key points for documentation

## Troubleshooting

If Maestro has issues connecting to the iOS Simulator:

1. Ensure Xcode command line tools are installed
2. Try `maestro doctor` to diagnose issues
3. Make sure the app bundle ID matches: `com.nutsack.wallet`
4. Check that the simulator is booted and unlocked

## Contributing

When adding new tests:
1. Follow the naming convention: `XX-feature-name.yaml`
2. Include clear comments explaining the test flow
3. Use optional selectors where UI might vary
4. Add appropriate wait times for animations
5. Capture screenshots for important states
</file>

<file path="Sources/NutsackiOS/Assets.xcassets/AppIcon.appiconset/Contents.json">
{
  "images" : [
    {
      "filename" : "Icon-60@2x.png",
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "60x60"
    },
    {
      "filename" : "Icon-60@3x.png",
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "60x60"
    },
    {
      "filename" : "Icon-76@2x.png",
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "76x76"
    },
    {
      "filename" : "Icon-83.5@2x.png",
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "83.5x83.5"
    },
    {
      "filename" : "Icon-1024.png",
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="Sources/NutsackiOS/Assets.xcassets/Contents.json">
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="Sources/NutsackiOS/Views/Alerts/MintFailureAlert.swift">
import SwiftUI
import NDKSwift
struct MintFailureAlert: View {
    let operation: PendingMintOperation
    let onRetry: () -> Void
    let onBlacklist: () -> Void
    let onCancel: () -> Void
    @Environment(\.dismiss) private var dismiss
    var body: some View {
        VStack(spacing: 20) {
            // Icon
            Image(systemName: "exclamationmark.triangle.fill")
                .font(.system(size: 50))
                .foregroundColor(.orange)
            // Title
            Text("Mint Failed to Issue Tokens")
                .font(.title2)
                .fontWeight(.bold)
                .multilineTextAlignment(.center)
            // Details
            VStack(alignment: .leading, spacing: 12) {
                DetailRow(
                    label: "Mint",
                    value: formatMintURL(operation.mintURL)
                )
                DetailRow(
                    label: "Amount",
                    value: "\(operation.amount) sats"
                )
                DetailRow(
                    label: "Quote ID",
                    value: String(operation.quoteId.prefix(16)) + "..."
                )
                if let paymentProof = operation.paymentProof {
                    DetailRow(
                        label: "Payment Proof",
                        value: String(paymentProof.prefix(16)) + "..."
                    )
                }
            }
            .padding()
            .background(Color(.systemGray6))
            .cornerRadius(10)
            // Explanation
            Text("The mint has received your payment but failed to issue tokens after multiple attempts. You can retry, blacklist this mint, or cancel.")
                .font(.caption)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
            // Action buttons
            VStack(spacing: 12) {
                Button(action: {
                    onRetry()
                    dismiss()
                }) {
                    Label("Retry", systemImage: "arrow.clockwise")
                        .frame(maxWidth: .infinity)
                }
                .buttonStyle(.borderedProminent)
                Button(action: {
                    onBlacklist()
                    dismiss()
                }) {
                    Label("Blacklist Mint", systemImage: "xmark.shield.fill")
                        .frame(maxWidth: .infinity)
                }
                .buttonStyle(.bordered)
                .tint(.red)
                Button("Cancel") {
                    onCancel()
                    dismiss()
                }
                .buttonStyle(.plain)
            }
            .padding(.top)
        }
        .padding()
        .frame(maxWidth: 400)
    }
    private func formatMintURL(_ url: String) -> String {
        // Extract domain from URL for display
        if let url = URL(string: url),
           let host = url.host {
            return host
        }
        return url
    }
}
private struct DetailRow: View {
    let label: String
    let value: String
    var body: some View {
        HStack {
            Text(label)
                .font(.caption)
                .foregroundColor(.secondary)
            Spacer()
            Text(value)
                .font(.caption)
                .fontWeight(.medium)
                .lineLimit(1)
                .truncationMode(.middle)
        }
    }
}
// MARK: - Preview
struct MintFailureAlert_Previews: PreviewProvider {
    static var previews: some View {
        MintFailureAlert(
            operation: PendingMintOperation(
                quoteId: "abc123def456ghi789",
                mintURL: "https://mint.example.com",
                amount: 1000,
                invoice: "lnbc1000...",
                paymentProof: "proof123456789",
                createdAt: Date(),
                lastAttemptAt: Date()
            ),
            onRetry: { print("Retry") },
            onBlacklist: { print("Blacklist") },
            onCancel: { print("Cancel") }
        )
        .previewLayout(.sizeThatFits)
    }
}
</file>

<file path="Sources/NutsackiOS/Views/Wallet/WalletView.swift.backup">
import SwiftUI
import NDKSwift
// import Popovers - Removed for build compatibility

struct WalletView: View {
    @EnvironmentObject private var appState: AppState
    @EnvironmentObject private var nostrManager: NostrManager
    @Environment(WalletManager.self) private var walletManager

    @Binding var urlState: URLState?
    @Binding var showScanner: Bool

    @State private var navigationDestination: WalletDestination?
    @State private var isLoadingWallet = false
    @State private var scannedInvoice: String?
    @State private var showInvoicePreview = false
    @State private var showWalletSettings = false
    @State private var showSettings = false
    @State private var showWalletOnboarding = false

    enum WalletDestination: Identifiable, Hashable {
        case mint
        case send
        case receive(urlString: String?)
        case nutzap(pubkey: String? = nil)
        case swap
        case relayHealth
        case contacts
        case walletEvents
        case proofManagement
        case receivedNutzaps

        var id: String {
            switch self {
            case .mint: return "mint"
            case .send: return "send"
            case .receive(let url): return "receive_\(url ?? "nil")"
            case .nutzap(let pubkey): return "nutzap_\(pubkey ?? "nil")"
            case .swap: return "swap"
            case .relayHealth: return "relayHealth"
            case .contacts: return "contacts"
            case .walletEvents: return "walletEvents"
            case .proofManagement: return "proofManagement"
            case .receivedNutzaps: return "receivedNutzaps"
            }
        }
    }

    var body: some View {
        NavigationStack {
            VStack {
                if walletManager.wallet == nil {
                    // No wallet at all - show full onboarding
                    EmptyWalletView(showWalletOnboarding: $showWalletOnboarding)
                } else {
                    ScrollView {
                        VStack(spacing: 12) {
                            // Balance card with expandable pie chart
                            BalanceCard()
                                .padding(.horizontal)
                                .zIndex(1) // Ensure it stays on top during expansion

                            // Contacts horizontal scroll
                            ContactsScrollView(navigationDestination: $navigationDestination)
                                .padding(.top, -8)

                            // Recent transactions
                            RecentTransactionsView()
                                .padding(.horizontal)
                        }
                        .padding(.top, 8)
                    }
                    .scrollIndicators(.hidden)

                    Spacer()

                    // Action buttons
                    ActionButtonsView(navigationDestination: $navigationDestination, showScanner: $showScanner)
                        .padding()
            }
            .background(
                RadialGradient(
                    gradient: Gradient(colors: [
                        Color(.systemBackground),
                        Color(.secondarySystemBackground)
                    ]),
                    center: .top,
                    startRadius: 0,
                    endRadius: 400
                )
            )
            .navigationTitle("")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .topBarLeading) {
                    Button(action: { showSettings = true }) {
                        Image(systemName: "person.circle.fill")
                            .font(.title3)
                    }
                }

                if walletManager.wallet != nil {
                    ToolbarItem(placement: .topBarTrailing) {
                        Button(action: { showWalletSettings = true }) {
                            Image(systemName: "gearshape")
                                .font(.title3)
                        }
                    }
                }
            }
            .sheet(isPresented: $showInvoicePreview) {
                if let invoice = scannedInvoice {
                    LightningInvoicePreviewView(invoice: invoice)
                }
            }
            .sheet(isPresented: $showWalletSettings) {
                WalletSettingsView()
                    .environmentObject(nostrManager)
                    .environment(walletManager)
            }
            .sheet(isPresented: $showSettings) {
                SettingsView()
                    .environmentObject(nostrManager)
                    .environment(walletManager)
            }
            .navigationDestination(item: $navigationDestination) { destination in
                switch destination {
                case .mint:
                    MintView()
                case .send:
                    SendView()
                case .receive(let urlString):
                    ReceiveView(tokenString: urlString)
                case .nutzap(let pubkey):
                    NutzapView(recipientPubkey: pubkey)
                case .swap:
                    SwapView()
                case .relayHealth:
                    RelayHealthView()
                case .contacts:
                    ContactsView(navigationDestination: $navigationDestination)
                case .walletEvents:
                    WalletEventsView()
                case .proofManagement:
                    ProofManagementView()
                case .receivedNutzaps:
                    ReceivedNutzapsView(walletManager: walletManager)
                }
            }
            .onAppear {
                print("\n=== 🟢 [WalletView] VIEW LIFECYCLE ===")
                print("🟢 [WalletView] onAppear called at \(Date())")
                print("🟢 [WalletView] activeWallet exists: \(walletManager.wallet != nil)")
                print("🟢 [WalletView] isAuthenticated: \(nostrManager.isAuthenticated)")
                print("🟢 [WalletView] signer available: \(nostrManager.ndk?.signer != nil)")
                loadWalletIfNeeded()

                // Check wallet status for logging purposes
                Task {
                    let wallet = walletManager.wallet
                    let mintUrls = await wallet?.mints.getMintURLs() ?? []
                    
                    print("🟢 [WalletView] Wallet status check:")
                    print("  - wallet exists: \(wallet != nil)")
                    print("  - mint count: \(mintUrls.count)")
                    print("  - mints: \(mintUrls)")
                    
                    if wallet == nil {
                        print("🚨 [WalletView] NO WALLET - Will show EmptyWalletView")
                    } else {
                        print("✅ [WalletView] Wallet exists - Will show normal wallet UI (even without mints)")
                    }
                }
                print("=== [WalletView] END VIEW LIFECYCLE ===\n")
            }
            .onChange(of: urlState) { _, newValue in
                if let newValue {
                    navigationDestination = .receive(urlString: newValue.url)
                    urlState = nil
                }
            }
            .onChange(of: nostrManager.isAuthenticated) { _, newValue in
                if newValue && walletManager.wallet == nil {
                    loadWalletIfNeeded()
                }
            }
            .fullScreenCover(isPresented: $showWalletOnboarding) {
                WalletOnboardingView(authMode: .none)
                    .environmentObject(nostrManager)
                    .environment(walletManager)
                    .onDisappear {
                        // Reload wallet after onboarding
                        Task {
                            try? await walletManager.loadWalletForCurrentUser()
                        }
                    }
            }
            .task {
                print("🔵 WalletView - Task started at \(Date())")
                // Monitor for signer availability when authenticated
                var attempts = 0
                while nostrManager.isAuthenticated && walletManager.wallet == nil {
                    attempts += 1
                    print("🔵 WalletView - Task checking signer (attempt \(attempts))")
                    if nostrManager.ndk?.signer != nil {
                        print("🔵 WalletView - Task found signer, calling loadWalletIfNeeded")
                        loadWalletIfNeeded()
                        break
                    }
                    try? await Task.sleep(nanoseconds: 100_000_000) // 0.1 seconds
                }
                print("🔵 WalletView - Task completed")
            }
        }
        .tint(.orange)
    }

    private func loadWalletIfNeeded() {
        print("🟡 loadWalletIfNeeded called from \(Thread.current)")
        guard nostrManager.isAuthenticated else {
            print("🟡 loadWalletIfNeeded - Not authenticated, skipping")
            return
        }
        guard walletManager.wallet == nil else {
            print("🟡 loadWalletIfNeeded - Wallet already active, skipping")
            return
        }
        guard !isLoadingWallet else {
            print("🟡 loadWalletIfNeeded - Already loading wallet, skipping duplicate call")
            return
        }

        print("🟡 loadWalletIfNeeded - Starting wallet load task")
        isLoadingWallet = true
        Task {
            defer { isLoadingWallet = false }
            do {
                print("🟡 loadWalletIfNeeded - Calling loadWalletForCurrentUser")
                try await walletManager.loadWalletForCurrentUser()
                print("✅ loadWalletIfNeeded - Wallet loaded successfully")
            } catch WalletError.signerNotAvailable {
                // Signer not ready yet, retry after a short delay
                print("⚠️ loadWalletIfNeeded - Signer not available yet, retrying...")
                try? await Task.sleep(nanoseconds: 500_000_000) // 0.5 seconds

                // Retry once more
                do {
                    print("🟡 loadWalletIfNeeded - Retrying loadWalletForCurrentUser")
                    try await walletManager.loadWalletForCurrentUser()
                    print("✅ loadWalletIfNeeded - Wallet loaded successfully on retry")
                } catch {
                    print("❌ loadWalletIfNeeded - Failed to load wallet after retry: \(error)")
                }
            } catch {
                print("❌ loadWalletIfNeeded - Failed to load wallet: \(error)")
            }
        }
    }
}

// MARK: - Empty Wallet View
struct EmptyWalletView: View {
    @EnvironmentObject private var nostrManager: NostrManager
    @Binding var showWalletOnboarding: Bool

    var body: some View {
        VStack(spacing: 24) {
            Spacer()
            
            // Icon
            ZStack {
                Circle()
                    .fill(Color.orange.opacity(0.1))
                    .frame(width: 120, height: 120)
                
                Image(systemName: "wallet.pass")
                    .font(.system(size: 60))
                    .foregroundColor(.orange)
            }
            
            // Title
            Text("Welcome to Nutsack")
                .font(.title)
                .fontWeight(.bold)
            
            // Description
            Text("Your wallet is not set up yet. Tap the button below to configure your Cashu wallet and start using instant, private payments.")
                .font(.body)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
                .padding(.horizontal, 40)
            
            // Setup button
            Button(action: {
                print("🔍 [EmptyWalletView] User manually initiated wallet setup")
                showWalletOnboarding = true
            }) {
                Label("Set Up Wallet", systemImage: "arrow.right.circle.fill")
                    .font(.headline)
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .frame(height: 50)
                    .background(Color.orange)
                    .cornerRadius(12)
            }
            .padding(.horizontal, 40)
            
            Spacer()
        }
        .onAppear {
            print("\n=== 🚀 [EmptyWalletView] VIEW DISPLAYED ===")
            print("🔍 [EmptyWalletView] Detected authenticated user with no configured wallet")
            print("🔍 [EmptyWalletView] NostrManager has signer: \(nostrManager.ndk?.signer != nil)")
            print("🔍 [EmptyWalletView] NostrManager.isAuthenticated: \(nostrManager.isAuthenticated)")

            // If we have auth state but no signer, clear the lingering auth state
            if nostrManager.ndk?.signer == nil && nostrManager.isAuthenticated {
                print("🔍 [EmptyWalletView] DECISION: Clear lingering auth state (no signer found)")
                Task {
                    await nostrManager.logout()
                }
                // Don't show wallet onboarding, let ContentView handle showing AuthenticationFlow
            } else {
                // User is authenticated but has no wallet configured
                // Don't automatically show onboarding - let user initiate it manually
                print("🔍 [EmptyWalletView] DECISION: User authenticated but wallet not configured - showing setup prompt")
                print("🔍 [EmptyWalletView] User can tap 'Set Up Wallet' button to begin setup")
            }
            print("=== [EmptyWalletView] END VIEW DISPLAYED ===\n")
        }
    }
}

// Premium button style with subtle press effect
struct PremiumButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed ? 0.95 : 1.0)
            .opacity(configuration.isPressed ? 0.8 : 1.0)
            .animation(.easeInOut(duration: 0.1), value: configuration.isPressed)
    }
}

// MARK: - Action Buttons
struct ActionButtonsView: View {
    @Binding var navigationDestination: WalletView.WalletDestination?
    @Binding var showScanner: Bool
    @State private var showReceiveMenu = false
    @State private var showSendMenu = false
    @State private var scanButtonPressed = false

    var body: some View {
        ZStack {
            // Base layer - receive and send buttons touching
            HStack(spacing: 0) {
                // Receive button
                Button(action: { navigationDestination = .mint }) {
                    HStack(spacing: 8) {
                        Image(systemName: "arrow.down")
                            .font(.system(size: 20, weight: .medium))
                        Text("Receive")
                            .font(.system(size: 16, weight: .medium))
                    }
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity, alignment: .center)
                    .frame(height: 60)
                    .padding(.trailing, 40) // Offset for floating circle (80px width / 2)
                }
                .buttonStyle(PremiumButtonStyle())

                // Send button - direct to send view
                Button(action: { navigationDestination = .send }) {
                    HStack(spacing: 8) {
                        Image(systemName: "arrow.up")
                            .font(.system(size: 20, weight: .medium))
                        Text("Send")
                            .font(.system(size: 16, weight: .medium))
                    }
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity, alignment: .center)
                    .frame(height: 60)
                    .padding(.leading, 40) // Offset for floating circle (80px width / 2)
                }
                .buttonStyle(PremiumButtonStyle())
            }
            .background(
                RoundedRectangle(cornerRadius: 16)
                    .fill(
                        LinearGradient(
                            gradient: Gradient(colors: [
                                Color(white: 0.18),
                                Color(white: 0.12)
                            ]),
                            startPoint: .top,
                            endPoint: .bottom
                        )
                    )
            )
            .shadow(color: Color(.label).opacity(0.2), radius: 20, x: 0, y: 10)

            // Floating scan button on top
            Button(action: {
                withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {
                    scanButtonPressed = true
                }
                showScanner = true
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                    scanButtonPressed = false
                }
            }) {
                Circle()
                    .fill(
                        LinearGradient(
                            gradient: Gradient(colors: [
                                Color.orange,
                                Color.orange.opacity(0.85)
                            ]),
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .frame(width: 80, height: 80)
                    .shadow(color: Color.orange.opacity(0.4), radius: 12, x: 0, y: 6)
                    .overlay(
                        Image(systemName: "qrcode.viewfinder")
                            .font(.system(size: 36, weight: .medium))
                            .foregroundColor(.white)
                    )
                    .scaleEffect(scanButtonPressed ? 0.92 : 1.0)
            }
            .buttonStyle(PlainButtonStyle())
        }
        .frame(height: 76) // Match the reduced scan button
    }
}

// MARK: - Contacts Scroll View
struct ContactsScrollView: View {
    @Binding var navigationDestination: WalletView.WalletDestination?
    @EnvironmentObject private var nostrManager: NostrManager
    @State private var contacts: [NDKUser] = []
    @State private var scrollOffset: CGFloat = 0

    // Default users to show when no contacts
    private let defaultUsers: [NDKUser] = {
        // Pre-calculated pubkeys for reliability
        let defaultPubkeys = [
            // Pablo Fernandez
            "fcb220c3af11b08325c8ad74c37b2ab5b9e665e3c39076c20c8d36c5b5c3de78",
            // Jack Dorsey  
            "82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2",
            // Calle (Cashu creator)
            "50d94fc2d8580c682b071a542f8b1e31a200b0508bab95a33bef0855df281d63"
        ]
        return defaultPubkeys.map { NDKUser(pubkey: $0) }
    }()

    var body: some View {
        ScrollViewReader { _ in
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 16) {
                    // Show default users if no contacts, otherwise show contacts
                    ForEach(contacts.isEmpty ? defaultUsers : contacts, id: \.pubkey) { contact in
                        ContactAvatarView(user: contact) {
                            navigationDestination = .nutzap(pubkey: contact.pubkey)
                        }
                    }

                    // View All button at the end
                    Button(action: {
                        navigationDestination = .contacts
                    }) {
                        VStack(spacing: 4) {
                            ZStack {
                                Circle()
                                    .fill(Color(white: 0.15))
                                    .frame(width: 64, height: 64)

                                Image(systemName: "ellipsis")
                                    .font(.system(size: 24, weight: .medium))
                                    .foregroundColor(.white.opacity(0.6))
                            }

                            Text("All")
                                .font(.caption2)
                                .foregroundStyle(.secondary)
                        }
                    }
                    .id("viewAll")
                }
                .padding(.horizontal)
                .background(GeometryReader { geometry in
                    Color.clear
                        .preference(key: ScrollOffsetPreferenceKey.self,
                                  value: geometry.frame(in: .named("scroll")).minX)
                })
            }
            .coordinateSpace(name: "scroll")
            .onPreferenceChange(ScrollOffsetPreferenceKey.self) { @MainActor value in
                scrollOffset = value
                // If scrolled far enough to the right (view all button visible)
                if value < -UIScreen.main.bounds.width {
                    navigationDestination = .contacts
                }
            }
        }
        .task {
            await loadContacts()
        }
    }

    @MainActor
    private func loadContacts() async {
        guard let ndk = nostrManager.ndk else { return }

        do {
            // Get user's contact list
            guard let signer = ndk.signer else { return }
            let pubkey = try await signer.pubkey

            let filter = NDKFilter(
                authors: [pubkey],
                kinds: [3]
            )

            // Use declarative data source to fetch contact list
            let contactDataSource = ndk.observe(
                filter: filter,
                maxAge: 3600,
                cachePolicy: .cacheWithNetwork
            )

            var contactListEvent: NDKEvent?
            for await event in contactDataSource.events {
                contactListEvent = event
                break // Take first event
            }

            if let contactListEvent = contactListEvent {
                // Parse the contact list
                var contactPubkeys: [String] = []
                for tag in contactListEvent.tags {
                    if tag.count >= 2 && tag[0] == "p" {
                        contactPubkeys.append(tag[1])
                    }
                }

                // Limit to first 20 contacts for performance
                let limitedPubkeys = Array(contactPubkeys.prefix(20))

                // Create NDKUser objects and show them immediately
                contacts = limitedPubkeys.map { NDKUser(pubkey: $0) }
            }
        } catch {
            print("Failed to load contacts: \(error)")
        }
    }
}

struct ContactAvatarView: View {
    let user: NDKUser
    let onTap: () -> Void
    @State private var profile: NDKUserProfile?
    @State private var profileTask: Task<Void, Never>?
    @EnvironmentObject private var nostrManager: NostrManager

    var displayName: String {
        profile?.displayName ?? profile?.name ?? String(user.pubkey.prefix(8))
    }

    var body: some View {
        Button(action: onTap) {
            VStack(spacing: 4) {
                Group {
                    if let imageUrl = profile?.picture, let url = URL(string: imageUrl) {
                        AsyncImage(url: url) { image in
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                                .frame(width: 64, height: 64)
                                .clipShape(Circle())
                        } placeholder: {
                            Circle()
                                .fill(Color(white: 0.15))
                                .frame(width: 64, height: 64)
                                .overlay(
                                    Text(String(displayName.prefix(1)).uppercased())
                                        .font(.title2)
                                        .foregroundColor(.white.opacity(0.6))
                                )
                        }
                    } else {
                        Circle()
                            .fill(Color(white: 0.15))
                            .frame(width: 64, height: 64)
                            .overlay(
                                Text(String(displayName.prefix(1)).uppercased())
                                    .font(.title2)
                                    .foregroundColor(.white.opacity(0.6))
                            )
                    }
                }
                .overlay(
                    Circle()
                        .stroke(Color(.separator).opacity(0.3), lineWidth: 1)
                )

                Text(displayName)
                    .font(.caption2)
                    .foregroundStyle(.secondary)
                    .lineLimit(1)
                    .frame(maxWidth: 64)
            }
        }
        .buttonStyle(PlainButtonStyle())
        .task {
            guard let ndk = nostrManager.ndk else { return }

            profileTask = Task {
                // Use declarative data source for profile
                let profileDataSource = ndk.observe(
                    filter: NDKFilter(
                        authors: [user.pubkey],
                        kinds: [0]
                    ),
                    maxAge: 3600,
                    cachePolicy: .cacheWithNetwork
                )

                for await event in profileDataSource.events {
                    if let profile = JSONCoding.safeDecode(NDKUserProfile.self, from: event.content) {
                        await MainActor.run {
                            self.profile = profile
                        }
                        break
                    }
                }
            }
        }
        .onDisappear {
            profileTask?.cancel()
        }
    }
}

struct ScrollOffsetPreferenceKey: PreferenceKey {
    static let defaultValue: CGFloat = 0
    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
        value = nextValue()
    }
}

// MARK: - Helper Views
</file>

<file path="Sources/NutsackiOS/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>1.0</string>
	<key>CFBundleVersion</key>
	<string>1</string>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>UIApplicationSceneManifest</key>
	<dict>
		<key>UIApplicationSupportsMultipleScenes</key>
		<false/>
	</dict>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
	<key>UIRequiredDeviceCapabilities</key>
	<array>
		<string>arm64</string>
	</array>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationPortraitUpsideDown</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>UISupportedInterfaceOrientations~ipad</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationPortraitUpsideDown</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
</dict>
</plist>
</file>

<file path="Sources/NutsackiOS/LaunchScreen.storyboard">
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="22155" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <device id="retina6_1" orientation="portrait" appearance="light"/>
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="22131"/>
        <capability name="Safe area layout guides" minToolsVersion="9.0"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <rect key="frame" x="0.0" y="0.0" width="414" height="896"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <viewLayoutGuide key="safeArea" id="6Tk-OE-BBY"/>
                        <color key="backgroundColor" white="0.0" alpha="1" colorSpace="custom" customColorSpace="genericGamma22GrayColorSpace"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
</document>
</file>

<file path="Sources/NutsackiOS/NutsackiOS.xcconfig">
// Configuration settings file format documentation can be found at:
// https://help.apple.com/xcode/#/dev745c5c974

PRODUCT_BUNDLE_IDENTIFIER = com.nutsack.wallet
PRODUCT_NAME = NutsackiOS
PRODUCT_MODULE_NAME = NutsackiOS
DEVELOPMENT_LANGUAGE = en
</file>

<file path=".repomixignore">
NutsackiOS.xcodeproj
</file>

<file path="build.sh">
#!/bin/bash
set -euo pipefail
# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color
# Get script directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
cd "$SCRIPT_DIR"
echo -e "${YELLOW}🔄 Regenerating Xcode project...${NC}"
# Check if xcodegen is installed
if ! command -v xcodegen &> /dev/null; then
    echo -e "${RED}❌ xcodegen is not installed. Installing via Homebrew...${NC}"
    brew install xcodegen
fi
# Generate Xcode project
xcodegen generate
echo -e "${GREEN}✅ Xcode project regenerated${NC}"
# Build the project
echo -e "${YELLOW}🏗️  Building NutsackiOS...${NC}"
# Set default values
DESTINATION="${DESTINATION:-platform=iOS Simulator,name=iPhone 15 Pro}"
CONFIGURATION="${CONFIGURATION:-Debug}"
SCHEME="${SCHEME:-NutsackiOS}"
# Build with xcbeautify for cleaner output
set -o pipefail && xcodebuild \
    -project NutsackiOS.xcodeproj \
    -scheme "$SCHEME" \
    -destination "$DESTINATION" \
    -configuration "$CONFIGURATION" \
    build \
    | xcbeautify
echo -e "${GREEN}✅ Build completed successfully${NC}"
</file>

<file path="deploy.sh">
#!/bin/bash
cd "$(dirname "$0")/.."
./deploy-testflight.sh NutsackiOS
</file>

<file path="ExportOptions-TestFlight.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>destination</key>
    <string>export</string>
    <key>method</key>
    <string>app-store</string>
    <key>signingStyle</key>
    <string>automatic</string>
    <key>stripSwiftSymbols</key>
    <true/>
    <key>teamID</key>
    <string>456SHKPP26</string>
    <key>uploadBitcode</key>
    <false/>
    <key>uploadSymbols</key>
    <true/>
    <key>compileBitcode</key>
    <false/>
    <key>provisioningProfiles</key>
    <dict/>
</dict>
</plist>
</file>

<file path="fix_renaming.py">
#!/usr/bin/env python3
import os
import re
def fix_file(filepath):
    with open(filepath, 'r') as f:
        content = f.read()
    original_content = content
    # Replace .observe( with .subscribe(
    content = re.sub(r'\.observe\(', '.subscribe(', content)
    # Replace NDKDataSource with NDKSubscription
    content = re.sub(r'\bNDKDataSource\b', 'NDKSubscription', content)
    if content != original_content:
        with open(filepath, 'w') as f:
            f.write(content)
        print(f"Fixed: {filepath}")
        return True
    return False
# Find all Swift files
fixed_count = 0
for root, dirs, files in os.walk('Sources'):
    for file in files:
        if file.endswith('.swift'):
            filepath = os.path.join(root, file)
            if fix_file(filepath):
                fixed_count += 1
print(f"\nTotal files fixed: {fixed_count}")
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Pablo Fernandez

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="README.md">
# Nutsack - Modern Cashu Wallet for iOS

<div align="center">
  <img src="Resources/nutsack-icon.png" alt="Nutsack Logo" width="200"/>
  
  [![Platform](https://img.shields.io/badge/platform-iOS%2017%2B-lightgrey)](https://developer.apple.com/ios/)
  [![Swift](https://img.shields.io/badge/Swift-5.9-orange)](https://swift.org)
  [![NDKSwift](https://img.shields.io/badge/NDKSwift-0.2.0-blue)](https://github.com/pablof7z/NDKSwift)
  [![CashuSwift](https://img.shields.io/badge/CashuSwift-latest-green)](https://github.com/zeugmaster/CashuSwift)
  [![License](https://img.shields.io/badge/license-MIT-green)](LICENSE)
</div>

## Overview

Nutsack is a modern [Cashu](https://cashu.space) ecash wallet for iOS that integrates seamlessly with [Nostr](https://nostr.com), implementing [NIP-60](https://github.com/nostr-protocol/nips/blob/master/60.md) (wallet data) and [NIP-61](https://github.com/nostr-protocol/nips/blob/master/61.md) (nutzaps). It provides a beautiful, native iOS experience for managing ecash with full backup and social payment capabilities.

## Features

### 🏦 Core Wallet Features
- **Multi-Mint Support**: Connect to multiple Cashu mints for improved reliability
- **Lightning Integration**: Mint ecash from Lightning invoices and melt back to Lightning
- **Send & Receive**: Share ecash tokens via QR codes, text, or Nostr
- **Real-time Balance**: Live balance updates with fiat conversion (USD, EUR, BTC)
- **Transaction History**: Comprehensive tracking of all ecash movements
- **Proof Management**: View, select, and manage individual ecash proofs
- **DLEQ Verification**: Automatic verification of mint signatures for enhanced security

### ⚡ Nostr Integration
- **Nostr Authentication**: Login with nsec or create new Nostr account
- **NIP-60 Backup**: Automatic wallet backup to Nostr relays
- **NIP-61 Nutzaps**: Zap other Nostr users with ecash
- **Contact Integration**: See your Nostr follows and zap them easily
- **Multi-Relay Support**: Connect to multiple Nostr relays with health monitoring
- **Mint Discovery**: Find new mints through NIP-38000 announcements

### 🎨 UI/UX Features
- **Beautiful Dark Theme**: Elegant design with glassmorphic effects
- **Native iOS Feel**: Built with SwiftUI for smooth, native performance
- **QR Code Scanner**: Scan ecash tokens, Lightning invoices, and mint URLs
- **Intuitive Navigation**: Tab-based interface with clear actions
- **Real-time Updates**: Live balance updates and transaction notifications
- **Pie Chart Visualization**: Visual breakdown of balance across mints
- **Smooth Animations**: Delightful animations for payments and interactions

### 🔒 Security Features
- **Biometric Lock**: Protect your wallet with Face ID/Touch ID
- **Encrypted Storage**: Local key storage with encryption
- **Mint Blacklisting**: Block untrusted mints
- **Token Validation**: Automatic validation of received tokens
- **Relay Health Monitoring**: Track relay connection status

## Architecture

The app is built using modern iOS technologies:

- **SwiftUI** for the declarative UI layer
- **SwiftData** for local persistence
- **NDKSwift** for Nostr protocol integration
- **CashuSwift** for Cashu protocol operations
- **Combine** for reactive programming

### Key Components

1. **WalletManager**: Core wallet operations and state management
2. **NostrManager**: Handles all Nostr operations including authentication and event publishing
3. **MintDiscoveryManager**: Discovers and manages Cashu mints
4. **WalletDataSources**: Reactive data sources for UI updates
5. **AppState**: Global app state and user preferences

## Requirements

- iOS 17.0+
- Xcode 15.0+
- Swift 5.9+

## Installation

### Building from Source

1. Clone the repository:
```bash
git clone https://github.com/pablof7z/Nutsack.git
cd Nutsack
```

2. Install XcodeGen if you haven't already:
```bash
brew install xcodegen
```

3. Generate the Xcode project:
```bash
./refresh-project.sh
```

4. Open the project in Xcode:
```bash
open NutsackiOS.xcodeproj
```

5. Build and run the project on your device or simulator

### TestFlight

Coming soon! We'll be releasing Nutsack on TestFlight for beta testing.

## Development

### Building

```bash
# Refresh project after file changes
./refresh-project.sh

# Build with clean output
./build.sh

# Build for specific device
DESTINATION="platform=iOS Simulator,name=iPhone 16 Pro" ./build.sh
```

### Testing

The project includes comprehensive Maestro UI tests:

```bash
# Run all tests
maestro test maestro-tests/

# Run specific test
maestro test maestro-tests/01-onboarding.yaml
```

### Deploying to TestFlight

```bash
./deploy.sh
```

## Configuration

### Default Mints

The app comes pre-configured with trusted mints. Users can add their own mints via:
- Scanning mint QR codes
- Entering mint URLs manually
- Discovering mints through Nostr

### Relay Configuration

Default relays are configured for optimal performance. Users can customize relays in Settings.

## Contributing

We welcome contributions! Please see our [Contributing Guidelines](CONTRIBUTING.md) for details.

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## Testing

The app includes comprehensive test coverage:

- Unit tests for wallet operations
- UI tests using Maestro
- Integration tests for Nostr functionality

Run tests with:
```bash
swift test
```

## Security

- Private keys are encrypted and stored locally
- All Nostr communications use standard encryption
- Ecash tokens are validated before acceptance
- Mint trust is explicit and user-controlled
- Regular security audits are performed

## Roadmap

- [ ] Multi-language support
- [ ] Backup/restore from seed phrase
- [ ] Push notifications for received payments
- [ ] Widget support for balance display
- [ ] WalletConnect integration
- [ ] Hardware wallet support
- [ ] Tor support for enhanced privacy

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgments

- Built with [NDKSwift](https://github.com/pablof7z/NDKSwift)
- Uses [CashuSwift](https://github.com/zeugmaster/CashuSwift) for Cashu operations
- Implements [Nostr Protocol](https://nostr.com) NIPs
- UI inspired by macademia wallet

## Contact

- Nostr: `npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft`
- GitHub: [@pablof7z](https://github.com/pablof7z)

---

<div align="center">
  Made with 🥜 for the ecash future
</div>
</file>

<file path="refresh-project.sh">
#!/bin/bash
set -euo pipefail
# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color
# Get script directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
cd "$SCRIPT_DIR"
echo -e "${YELLOW}🔄 Refreshing Xcode project after file changes...${NC}"
# Clean derived data if requested
if [[ "${CLEAN:-false}" == "true" ]]; then
    echo -e "${YELLOW}🧹 Cleaning derived data...${NC}"
    rm -rf .build/DerivedData
fi
# Regenerate project
xcodegen generate --spec project.yml
echo -e "${GREEN}✅ Project refreshed! The .xcodeproj now includes all current files.${NC}"
echo -e "${GREEN}   Code signing is configured from project.yml${NC}"
</file>

<file path=".github/workflows/ci.yml">
name: CI
on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
env:
  XCODE_VERSION: '15.4'
jobs:
  build:
    name: Build and Test
    runs-on: macos-14
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Select Xcode
      run: sudo xcode-select -s /Applications/Xcode_15.4.app
    - name: Install dependencies
      run: |
        brew install xcodegen
        brew install xcbeautify
    - name: Generate Xcode project
      run: ./refresh-project.sh
    - name: Build for testing
      run: |
        xcodebuild build-for-testing \
          -project NutsackiOS.xcodeproj \
          -scheme NutsackiOS \
          -destination "platform=iOS Simulator,name=iPhone 15 Pro" \
          | xcbeautify
    - name: Run tests
      run: |
        xcodebuild test-without-building \
          -project NutsackiOS.xcodeproj \
          -scheme NutsackiOS \
          -destination "platform=iOS Simulator,name=iPhone 15 Pro" \
          | xcbeautify || true
ENDOFFILE < /dev/null
</file>

<file path=".github/workflows/testflight.yml">
name: Deploy to TestFlight
on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
jobs:
  deploy:
    name: Deploy to TestFlight
    runs-on: macos-14
    steps:
    - uses: actions/checkout@v4
    - name: Select Xcode
      run: sudo xcode-select -s /Applications/Xcode_15.4.app
    - name: Install dependencies
      run: |
        brew install xcodegen
        brew install xcbeautify
    - name: Setup API Key
      env:
        APP_STORE_CONNECT_API_KEY: ${{ secrets.APP_STORE_CONNECT_API_KEY }}
      run: |
        mkdir -p ~/.appstoreconnect/private_keys
        echo "$APP_STORE_CONNECT_API_KEY" > ~/.appstoreconnect/private_keys/AuthKey_${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}.p8
    - name: Generate Xcode project
      run: ./refresh-project.sh
    - name: Build and deploy
      env:
        API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
        API_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
      run: |
        xcodebuild archive \
          -project NutsackiOS.xcodeproj \
          -scheme NutsackiOS \
          -configuration Release \
          -archivePath build/NutsackiOS.xcarchive \
          -destination "generic/platform=iOS" \
          CODE_SIGN_STYLE=Automatic \
          DEVELOPMENT_TEAM="${{ secrets.DEVELOPMENT_TEAM }}" \
          | xcbeautify
        xcodebuild -exportArchive \
          -archivePath build/NutsackiOS.xcarchive \
          -exportPath build \
          -exportOptionsPlist ExportOptions-TestFlight.plist \
          | xcbeautify
        xcrun altool --upload-app \
          -f build/NutsackiOS.ipa \
          -t ios \
          --apiKey "$API_KEY_ID" \
          --apiIssuer "$API_ISSUER_ID"
</file>

<file path="Sources/NutsackiOS/Models/WalletEventInfo.swift">
import Foundation
import NDKSwift
import CashuSwift
// Data model for wallet event information
struct WalletEventInfo: Identifiable, Hashable {
    let id: String
    let event: NDKEvent
    let tokenData: NIP60TokenEvent?
    let isDeleted: Bool
    let deletionReason: String?
    let deletionEvent: NDKEvent?
    init(event: NDKEvent, tokenData: NIP60TokenEvent?, isDeleted: Bool, deletionReason: String? = nil, deletionEvent: NDKEvent? = nil) {
        self.id = event.id
        self.event = event
        self.tokenData = tokenData
        self.isDeleted = isDeleted
        self.deletionReason = deletionReason
        self.deletionEvent = deletionEvent
    }
    static func == (lhs: WalletEventInfo, rhs: WalletEventInfo) -> Bool {
        lhs.id == rhs.id
    }
    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
}
</file>

<file path="Sources/NutsackiOS/Utils/AppIconGenerator.swift">
import SwiftUI
struct AppIconView: View {
    let size: CGFloat
    var body: some View {
        ZStack {
            // Background gradient
            LinearGradient(
                gradient: Gradient(colors: [
                    Color(red: 0.95, green: 0.5, blue: 0.1),
                    Color.orange,
                    Color(red: 0.8, green: 0.4, blue: 0.1)
                ]),
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            // Hexagon shape
            HexagonShape()
                .fill(
                    LinearGradient(
                        gradient: Gradient(colors: [
                            Color.orange,
                            Color(red: 0.9, green: 0.5, blue: 0.1)
                        ]),
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .overlay(
                    HexagonShape()
                        .stroke(
                            LinearGradient(
                                gradient: Gradient(colors: [
                                    Color.white.opacity(0.6),
                                    Color.white.opacity(0.2)
                                ]),
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            ),
                            lineWidth: size * 0.02
                        )
                )
                .padding(size * 0.15)
                .shadow(color: Color.black.opacity(0.3), radius: size * 0.02, x: 0, y: size * 0.02)
            // Inner glow effect
            HexagonShape()
                .fill(
                    RadialGradient(
                        gradient: Gradient(colors: [
                            Color.white.opacity(0.3),
                            Color.clear
                        ]),
                        center: .center,
                        startRadius: 0,
                        endRadius: size * 0.3
                    )
                )
                .padding(size * 0.15)
                .blendMode(.overlay)
            // Text "N" for Nutsack
            Text("N")
                .font(.system(size: size * 0.4, weight: .black, design: .rounded))
                .foregroundColor(.white)
                .shadow(color: Color.black.opacity(0.3), radius: size * 0.01, x: 0, y: size * 0.01)
        }
        .frame(width: size, height: size)
    }
}
struct AppIconGenerator: View {
    var body: some View {
        VStack(spacing: 40) {
            Text("App Icon Preview")
                .font(.largeTitle)
                .fontWeight(.bold)
            VStack(spacing: 20) {
                // 1024x1024 App Store icon
                VStack {
                    AppIconView(size: 256) // Preview at smaller size
                    Text("1024×1024 (App Store)")
                        .font(.caption)
                }
                HStack(spacing: 20) {
                    // 180x180 (60pt @3x for iPhone)
                    VStack {
                        AppIconView(size: 90)
                        Text("180×180")
                            .font(.caption)
                    }
                    // 120x120 (60pt @2x for iPhone)
                    VStack {
                        AppIconView(size: 60)
                        Text("120×120")
                            .font(.caption)
                    }
                    // 152x152 (76pt @2x for iPad)
                    VStack {
                        AppIconView(size: 76)
                        Text("152×152")
                            .font(.caption)
                    }
                    // 167x167 (83.5pt @2x for iPad Pro)
                    VStack {
                        AppIconView(size: 83.5)
                        Text("167×167")
                            .font(.caption)
                    }
                }
            }
            Text("Export these at actual pixel sizes for production")
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .padding()
        .background(Color.gray.opacity(0.1))
    }
}
</file>

<file path="Sources/NutsackiOS/Utils/PlatformHelpers.swift">
import SwiftUI
// MARK: - Platform-specific clipboard operations
extension String {
    func copyToPasteboard() {
        #if os(iOS)
        UIPasteboard.general.string = self
        #elseif os(macOS)
        NSPasteboard.general.clearContents()
        NSPasteboard.general.setString(self, forType: .string)
        #endif
    }
}
// MARK: - Platform-specific view modifiers
struct PlatformNavigationBarTitleDisplayMode: ViewModifier {
    let mode: Any?
    init(inline: Bool = true) {
        #if os(iOS)
        self.mode = inline ? NavigationBarItem.TitleDisplayMode.inline : NavigationBarItem.TitleDisplayMode.large
        #else
        self.mode = nil
        #endif
    }
    func body(content: Content) -> some View {
        #if os(iOS)
        if let displayMode = mode as? NavigationBarItem.TitleDisplayMode {
            content.navigationBarTitleDisplayMode(displayMode)
        } else {
            content
        }
        #else
        content
        #endif
    }
}
extension View {
    func platformNavigationBarTitleDisplayMode(inline: Bool = true) -> some View {
        self.modifier(PlatformNavigationBarTitleDisplayMode(inline: inline))
    }
}
</file>

<file path="Sources/NutsackiOS/Utils/QRCodeGenerator.swift">
import SwiftUI
import NDKSwiftUI
// Type aliases for backward compatibility
public typealias QRCodeGenerator = NDKUIQRCodeGenerator
public typealias QRCodeView = NDKUIQRCodeView
public typealias QRCodeDisplayModifier = NDKUIQRCodeDisplayModifier
public typealias QRCodeDisplayView = NDKUIQRCodeDisplayView
// MARK: - View Extensions
public extension View {
    /// Presents a QR code display sheet (compatibility wrapper)
    func qrCodeSheet(for content: String, title: String, isPresented: Binding<Bool>) -> some View {
        self.ndkQRCodeSheet(for: content, title: title, isPresented: isPresented)
    }
}
</file>

<file path="Sources/NutsackiOS/Views/Helpers/AsyncContentView.swift">
import SwiftUI
/// A view that loads content asynchronously and displays it when ready
struct AsyncContentView<Content: View, T>: View {
    let operation: () async -> T
    let content: (T) -> Content
    @State private var result: T?
    @State private var isLoading = true
    var body: some View {
        Group {
            if isLoading {
                ProgressView()
                    .frame(maxWidth: .infinity)
                    .padding()
            } else if let result = result {
                content(result)
            } else {
                Text("No data available")
                    .foregroundStyle(.secondary)
                    .frame(maxWidth: .infinity)
                    .padding()
            }
        }
        .task {
            isLoading = true
            result = await operation()
            isLoading = false
        }
    }
}
</file>

<file path="Sources/NutsackiOS/Views/Utils/RelativeTimeView.swift">
import SwiftUI
import NDKSwift
import NDKSwiftUI
// Use NDKSwiftUI's relative time component
struct RelativeTimeView: View {
    let date: Date
    var body: some View {
        NDKUIRelativeTime(timestamp: Timestamp(date.timeIntervalSince1970))
    }
}
</file>

<file path="Sources/NutsackiOS/Views/Wallet/DLEQStatusIndicator.swift">
import SwiftUI
struct DLEQStatusIndicator: View {
    @Environment(WalletManager.self) private var walletManager
    @State private var proofStats: (verified: Int, unverified: Int, unknown: Int) = (0, 0, 0)
    var dleqStatus: (verified: Int, unverified: Int, unknown: Int) {
        proofStats
    }
    var statusColor: Color {
        let status = dleqStatus
        if status.unverified > 0 {
            return .yellow
        } else if status.verified > 0 && status.unknown == 0 {
            return .green
        } else if status.unknown > 0 {
            return .gray
        }
        return .gray
    }
    var statusIcon: String {
        let status = dleqStatus
        if status.unverified > 0 {
            return "exclamationmark.shield.fill"
        } else if status.verified > 0 && status.unknown == 0 {
            return "checkmark.shield.fill"
        } else {
            return "shield.fill"
        }
    }
    var statusText: String {
        let status = dleqStatus
        if status.unverified > 0 {
            return "\(status.unverified) unverified"
        } else if status.verified > 0 && status.unknown == 0 {
            return "All verified"
        } else if status.verified > 0 {
            return "\(status.verified) verified"
        } else {
            return "No verification data"
        }
    }
    var body: some View {
        HStack(spacing: 4) {
            Image(systemName: statusIcon)
                .font(.caption2)
                .foregroundStyle(statusColor)
            Text(statusText)
                .font(.caption2)
                .foregroundStyle(statusColor)
        }
        .help("Token authenticity status: \(dleqStatus.verified) verified, \(dleqStatus.unverified) unverified, \(dleqStatus.unknown) unknown")
        .task {
            await updateStats()
        }
    }
    private func updateStats() async {
        // Implementation pending: Requires WalletManager to track DLEQ verification status of proofs
        // This would involve tracking each proof's verification state in the wallet
        // Currently showing placeholder values until wallet infrastructure supports this
        proofStats = (0, 0, 0)
    }
}
// Compact version for inline use
struct DLEQBadge: View {
    let isVerified: Bool?
    var body: some View {
        if let verified = isVerified {
            Image(systemName: verified ? "checkmark.shield.fill" : "exclamationmark.shield.fill")
                .font(.caption2)
                .foregroundStyle(verified ? .green : .yellow)
                .help(verified ? "Token authenticity verified" : "Token authenticity not verified")
        }
    }
}
</file>

<file path="Sources/NutsackiOS/Views/Wallet/MintBalanceLegend.swift">
import SwiftUI
import Foundation
struct MintBalanceLegend: View {
    let mintBalances: [(mint: String, balance: Int64, percentage: Double)]
    let mintColors: [Color]
    let opacity: Double
    @State private var selectedMint: String?
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            ForEach(Array(mintBalances.enumerated()), id: \.element.mint) { index, item in
                NavigationLink(destination: MintDetailView(mintURL: item.mint)) {
                    HStack(spacing: 12) {
                        // Color indicator
                        RoundedRectangle(cornerRadius: 4)
                            .fill(mintColors[index % mintColors.count])
                            .frame(width: 20, height: 20)
                        VStack(alignment: .leading, spacing: 2) {
                            Text(formatMintName(item.mint))
                                .font(.system(size: 14, weight: .medium))
                                .foregroundColor(.white)
                            HStack(spacing: 8) {
                                Text("\(formatSats(item.balance)) sats")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                                Text("·")
                                    .foregroundColor(.secondary.opacity(0.5))
                                Text("\(Int(item.percentage))%")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                        }
                        Spacer()
                        Image(systemName: "chevron.right")
                            .font(.caption)
                            .foregroundColor(.secondary.opacity(0.6))
                    }
                }
                .buttonStyle(.plain)
            }
        }
        .padding(16)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(.secondarySystemBackground))
                .overlay(
                    RoundedRectangle(cornerRadius: 12)
                        .stroke(Color.gray.opacity(0.2), lineWidth: 1)
                )
        )
        .opacity(opacity)
    }
    private func formatSats(_ sats: Int64) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.groupingSeparator = ","
        return formatter.string(from: NSNumber(value: sats)) ?? String(sats)
    }
    private func formatMintName(_ urlString: String) -> String {
        guard let url = URL(string: urlString),
              let host = url.host else {
            return urlString
        }
        let cleanHost = host
            .replacingOccurrences(of: "www.", with: "")
            .replacingOccurrences(of: "mint.", with: "")
        if cleanHost.count > 25 {
            return String(cleanHost.prefix(22)) + "..."
        }
        return cleanHost
    }
}
</file>

<file path="Sources/NutsackiOS/Views/Wallet/PaymentReceivedAnimation.swift">
import SwiftUI
import UIKit
struct PaymentReceivedAnimation: View {
    let amount: Int64
    let onComplete: () -> Void
    @State private var showAmount = false
    @State private var checkmarkScale: CGFloat = 0
    @State private var amountOpacity: Double = 0
    @State private var glowOpacity: Double = 0
    @State private var ringOpacity: Double = 0
    @State private var ringScale: CGFloat = 0.8
    @State private var successTextOpacity: Double = 0
    var body: some View {
        ZStack {
            // Subtle dark backdrop
            Color.black.opacity(0.85)
                .ignoresSafeArea()
                .onTapGesture {
                    onComplete()
                }
            // Soft radial gradient
            RadialGradient(
                colors: [
                    Color.orange.opacity(glowOpacity * 0.15),
                    Color.orange.opacity(glowOpacity * 0.05),
                    Color.clear
                ],
                center: .center,
                startRadius: 100,
                endRadius: 300
            )
            .ignoresSafeArea()
            VStack(spacing: 40) {
                // Elegant expanding ring with checkmark
                ZStack {
                    // Single elegant ring
                    Circle()
                        .stroke(
                            LinearGradient(
                                colors: [Color.orange.opacity(0.8), Color.orange.opacity(0.3)],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            ),
                            lineWidth: 3
                        )
                        .frame(width: 120, height: 120)
                        .scaleEffect(ringScale)
                        .opacity(ringOpacity)
                    // Elegant checkmark
                    Image(systemName: "checkmark")
                        .font(.system(size: 50, weight: .semibold))
                        .foregroundStyle(
                            LinearGradient(
                                colors: [.white, Color.orange.opacity(0.9)],
                                startPoint: .top,
                                endPoint: .bottom
                            )
                        )
                        .scaleEffect(checkmarkScale)
                }
                // Amount display
                VStack(spacing: 16) {
                    HStack(alignment: .firstTextBaseline, spacing: 8) {
                        Text("\(amount)")
                            .font(.system(size: 48, weight: .semibold, design: .rounded))
                            .foregroundStyle(.white)
                        Text("sats")
                            .font(.system(size: 24, weight: .medium, design: .rounded))
                            .foregroundStyle(Color.white.opacity(0.7))
                    }
                    .opacity(amountOpacity)
                    Text("Payment Received")
                        .font(.system(size: 20, weight: .medium, design: .rounded))
                        .foregroundStyle(Color.white.opacity(0.9))
                        .opacity(successTextOpacity)
                }
            }
        }
        .onAppear {
            startElegantAnimation()
        }
    }
    private func startElegantAnimation() {
        // Subtle haptic feedback
        let impactFeedback = UIImpactFeedbackGenerator(style: .medium)
        impactFeedback.prepare()
        // Fade in backdrop glow
        withAnimation(.easeIn(duration: 0.4)) {
            glowOpacity = 1
        }
        // Ring animation
        withAnimation(.easeOut(duration: 0.6)) {
            ringOpacity = 1
            ringScale = 1
        }
        // Checkmark appears with spring
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
            withAnimation(.interpolatingSpring(stiffness: 300, damping: 15)) {
                checkmarkScale = 1
            }
            impactFeedback.impactOccurred()
        }
        // Amount fades in
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            withAnimation(.easeIn(duration: 0.4)) {
                amountOpacity = 1
            }
        }
        // Success text appears
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.7) {
            withAnimation(.easeIn(duration: 0.3)) {
                successTextOpacity = 1
            }
            // Light success haptic
            let notificationFeedback = UINotificationFeedbackGenerator()
            notificationFeedback.notificationOccurred(.success)
        }
        // Auto dismiss after 2.5 seconds
        DispatchQueue.main.asyncAfter(deadline: .now() + 2.5) {
            withAnimation(.easeOut(duration: 0.3)) {
                amountOpacity = 0
                successTextOpacity = 0
                checkmarkScale = 0.8
                ringOpacity = 0
                glowOpacity = 0
            }
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.4) {
                onComplete()
            }
        }
    }
}
</file>

<file path="Sources/NutsackiOS/Views/Wallet/WalletEventDetailView.swift">
import SwiftUI
import NDKSwift
import CashuSwift
#if os(iOS)
import UIKit
#endif
struct WalletEventDetailView: View {
    let eventInfo: WalletEventInfo
    @Environment(WalletManager.self) private var walletManager
    @State private var proofStates: [String: CashuSwift.Proof.ProofState] = [:]
    @State private var isCheckingProofs = false
    @State private var checkError: Error?
    @State private var copiedBech32 = false
    private var totalAmount: Int {
        eventInfo.tokenData?.proofs.reduce(0) { $0 + Int($1.amount) } ?? 0
    }
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 20) {
                // Event Status Card
                VStack(alignment: .leading, spacing: 12) {
                    HStack {
                        Image(systemName: eventInfo.isDeleted ? "xmark.circle.fill" : "checkmark.circle.fill")
                            .foregroundColor(eventInfo.isDeleted ? .red : .green)
                            .font(.title2)
                        Text(eventInfo.isDeleted ? "Deleted Event" : "Active Event")
                            .font(.headline)
                        Spacer()
                    }
                    if eventInfo.isDeleted, let reason = eventInfo.deletionReason {
                        Label(reason, systemImage: "info.circle")
                            .font(.subheadline)
                            .foregroundStyle(.red)
                    }
                    if let deletionEvent = eventInfo.deletionEvent {
                        VStack(alignment: .leading, spacing: 4) {
                            Text("Deleted by:")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                            Text(deletionEvent.id)
                                .font(.system(.caption, design: .monospaced))
                                .foregroundStyle(.secondary)
                        }
                    }
                }
                .padding()
                .background(Color(.secondarySystemGroupedBackground))
                .cornerRadius(12)
                // Event Metadata
                VStack(alignment: .leading, spacing: 12) {
                    Text("Event Information")
                        .font(.headline)
                    LabeledContent("Event ID") {
                        Text(eventInfo.event.id)
                            .font(.system(.caption, design: .monospaced))
                            .textSelection(.enabled)
                    }
                    // Bech32 encoding
                    if let bech32 = try? eventInfo.event.encode(includeRelays: true) {
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Bech32")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                            HStack(spacing: 8) {
                                Text(String(bech32.prefix(40)) + "...")
                                    .font(.system(.caption, design: .monospaced))
                                    .lineLimit(1)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                                // Copy button
                                Button(action: {
                                    #if os(iOS)
                                    UIPasteboard.general.string = bech32
                                    #endif
                                    withAnimation {
                                        copiedBech32 = true
                                    }
                                    DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                                        copiedBech32 = false
                                    }
                                }) {
                                    Image(systemName: copiedBech32 ? "checkmark.circle.fill" : "doc.on.doc")
                                        .foregroundColor(copiedBech32 ? .green : .accentColor)
                                }
                                .buttonStyle(.plain)
                                // Open in njump.me button
                                Button(action: {
                                    if let url = URL(string: "https://njump.me/\(bech32)") {
                                        #if os(iOS)
                                        UIApplication.shared.open(url)
                                        #endif
                                    }
                                }) {
                                    Image(systemName: "arrow.up.forward.square")
                                        .foregroundColor(.accentColor)
                                }
                                .buttonStyle(.plain)
                            }
                        }
                        if copiedBech32 {
                            Text("Copied to clipboard!")
                                .font(.caption)
                                .foregroundStyle(.green)
                                .transition(.opacity)
                        }
                    }
                    LabeledContent("Created") {
                        Text(Date(timeIntervalSince1970: TimeInterval(eventInfo.event.createdAt)), style: .date) +
                        Text(" at ") +
                        Text(Date(timeIntervalSince1970: TimeInterval(eventInfo.event.createdAt)), style: .time)
                    }
                    LabeledContent("Kind") {
                        Text("\(eventInfo.event.kind)")
                            .font(.system(.body, design: .monospaced))
                    }
                }
                .padding()
                .background(Color(.secondarySystemGroupedBackground))
                .cornerRadius(12)
                // Token Information
                if let tokenData = eventInfo.tokenData {
                    VStack(alignment: .leading, spacing: 12) {
                        HStack {
                            Text("Token Information")
                                .font(.headline)
                            Spacer()
                            if !eventInfo.isDeleted {
                                Button(action: checkProofStates) {
                                    if isCheckingProofs {
                                        ProgressView()
                                            .scaleEffect(0.8)
                                    } else {
                                        Label("Check States", systemImage: "arrow.clockwise")
                                            .font(.caption)
                                    }
                                }
                                .buttonStyle(.bordered)
                                .controlSize(.small)
                                .disabled(isCheckingProofs)
                            }
                        }
                        LabeledContent("Mint") {
                            Text(URL(string: tokenData.mint)?.host ?? tokenData.mint)
                                .textSelection(.enabled)
                        }
                        LabeledContent("Total Amount") {
                            Text("\(totalAmount) sats")
                                .font(.system(.body, design: .monospaced))
                                .foregroundColor(.orange)
                        }
                        LabeledContent("Number of Proofs") {
                            Text("\(tokenData.proofs.count)")
                        }
                        if let delTags = tokenData.del, !delTags.isEmpty {
                            VStack(alignment: .leading, spacing: 8) {
                                Text("Replaces Events:")
                                    .font(.subheadline)
                                    .foregroundStyle(.secondary)
                                ForEach(delTags, id: \.self) { deletedEventId in
                                    Text(deletedEventId)
                                        .font(.system(.caption, design: .monospaced))
                                        .foregroundStyle(.blue)
                                        .lineLimit(1)
                                }
                            }
                        }
                    }
                    .padding()
                    .background(Color(.secondarySystemGroupedBackground))
                    .cornerRadius(12)
                    // Proofs List
                    VStack(alignment: .leading, spacing: 12) {
                        Text("Proofs")
                            .font(.headline)
                        if checkError != nil {
                            Label("Error checking proof states", systemImage: "exclamationmark.triangle")
                                .font(.caption)
                                .foregroundColor(.red)
                        }
                        ForEach(tokenData.proofs, id: \.C) { proof in
                            ProofRow(proof: proof, state: proofStates[proof.C])
                        }
                    }
                    .padding()
                    .background(Color(.secondarySystemGroupedBackground))
                    .cornerRadius(12)
                }
                // Raw Event Content (for debugging)
                VStack(alignment: .leading, spacing: 12) {
                    DisclosureGroup("Raw Event Data") {
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Content (Encrypted):")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                            Text(eventInfo.event.content)
                                .font(.system(.caption, design: .monospaced))
                                .textSelection(.enabled)
                                .padding(8)
                                .background(Color(.tertiarySystemGroupedBackground))
                                .cornerRadius(8)
                            Text("Tags:")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                                .padding(.top, 8)
                            ForEach(Array(eventInfo.event.tags.enumerated()), id: \.offset) { _, tag in
                                Text(tag.joined(separator: ", "))
                                    .font(.system(.caption, design: .monospaced))
                                    .textSelection(.enabled)
                                    .padding(8)
                                    .background(Color(.tertiarySystemGroupedBackground))
                                    .cornerRadius(8)
                            }
                        }
                    }
                    .padding()
                    .background(Color(.secondarySystemGroupedBackground))
                    .cornerRadius(12)
                }
            }
            .padding()
        }
        .navigationTitle("Event Details")
        #if os(iOS)
        .navigationBarTitleDisplayMode(.inline)
        #endif
    }
    private func checkProofStates() {
        guard let tokenData = eventInfo.tokenData else { return }
        isCheckingProofs = true
        checkError = nil
        Task {
            do {
                let states = try await walletManager.checkProofStates(
                    for: tokenData.proofs,
                    mint: tokenData.mint
                )
                await MainActor.run {
                    self.proofStates = states
                    self.isCheckingProofs = false
                }
            } catch {
                await MainActor.run {
                    self.checkError = error
                    self.isCheckingProofs = false
                }
            }
        }
    }
}
struct ProofRow: View {
    let proof: CashuSwift.Proof
    let state: CashuSwift.Proof.ProofState?
    private var stateColor: Color {
        switch state {
        case .unspent:
            return .green
        case .spent:
            return .red
        case .pending:
            return .orange
        case nil:
            return .gray
        }
    }
    private var stateText: String {
        switch state {
        case .unspent:
            return "Unspent"
        case .spent:
            return "Spent"
        case .pending:
            return "Pending"
        case nil:
            return "Unknown"
        }
    }
    private var stateIcon: String {
        switch state {
        case .unspent:
            return "checkmark.circle.fill"
        case .spent:
            return "xmark.circle.fill"
        case .pending:
            return "clock.fill"
        case nil:
            return "questionmark.circle"
        }
    }
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text("\(proof.amount) sats")
                        .font(.system(.body, design: .monospaced))
                        .fontWeight(.medium)
                    Text("C: " + proof.C.prefix(16) + "...")
                        .font(.system(.caption, design: .monospaced))
                        .foregroundStyle(.secondary)
                        .lineLimit(1)
                    Text("Keyset: " + proof.keysetID.prefix(16) + "...")
                        .font(.system(.caption, design: .monospaced))
                        .foregroundStyle(.secondary)
                        .lineLimit(1)
                }
                Spacer()
                VStack(alignment: .trailing, spacing: 4) {
                    Image(systemName: stateIcon)
                        .foregroundColor(stateColor)
                        .font(.title3)
                    if state != nil {
                        Text(stateText)
                            .font(.caption)
                            .foregroundColor(stateColor)
                    }
                }
            }
            .padding(12)
            .background(Color(.tertiarySystemGroupedBackground))
            .cornerRadius(8)
        }
    }
}
</file>

<file path="Sources/NutsackiOS/Views/DiscoveredMintsView.swift">
import SwiftUI
import NDKSwift
struct DiscoveredMintsView: View {
    let discoveredMints: [DiscoveredMint]
    @Environment(\.dismiss) private var dismiss
    @Environment(WalletManager.self) private var walletManager
    @State private var selectedMints: Set<String> = []
    @State private var isAdding = false
    @State private var showError = false
    @State private var errorMessage = ""
    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
                if discoveredMints.isEmpty {
                    emptyStateView
                } else {
                    mintsList
                }
                // Bottom action bar
                if !selectedMints.isEmpty {
                    actionBar
                }
            }
            .navigationTitle("Discovered Mints")
            .platformNavigationBarTitleDisplayMode(inline: true)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { dismiss() }
                }
            }
            .alert("Error", isPresented: $showError) {
                Button("OK") { }
            } message: {
                Text(errorMessage)
            }
        }
    }
    private var emptyStateView: some View {
        VStack(spacing: 16) {
            Image(systemName: "magnifyingglass")
                .font(.system(size: 60))
                .foregroundStyle(.secondary)
            Text("No mints discovered")
                .font(.headline)
                .foregroundStyle(.secondary)
            Text("No Cashu mints were found on the network")
                .font(.subheadline)
                .foregroundStyle(.tertiary)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(Color(.systemGroupedBackground))
    }
    private var mintsList: some View {
        List {
            Section {
                ForEach(discoveredMints, id: \.url) { mint in
                    DiscoveredMintRow(
                        mint: mint,
                        isSelected: selectedMints.contains(mint.url),
                        onToggle: {
                            if selectedMints.contains(mint.url) {
                                selectedMints.remove(mint.url)
                            } else {
                                selectedMints.insert(mint.url)
                            }
                        }
                    )
                }
            } header: {
                Text("\(discoveredMints.count) mints discovered")
                    .font(.caption)
                    .foregroundStyle(.secondary)
            }
        }
    }
    private var actionBar: some View {
        VStack(spacing: 0) {
            Divider()
            HStack {
                Text("\(selectedMints.count) mint\(selectedMints.count == 1 ? "" : "s") selected")
                    .font(.subheadline)
                    .foregroundStyle(.secondary)
                Spacer()
                Button(action: addSelectedMints) {
                    if isAdding {
                        ProgressView()
                            .scaleEffect(0.8)
                    } else {
                        Text("Add Selected")
                            .fontWeight(.medium)
                    }
                }
                .disabled(isAdding)
            }
            .padding()
            .background(Color(.systemBackground))
        }
    }
    private func addSelectedMints() {
        // Just dismiss - user should manage mints in wallet settings
        dismiss()
        // Show a message that they need to use wallet settings
        Task {
            await MainActor.run {
                errorMessage = "To add discovered mints, please use Wallet Settings."
                showError = true
            }
        }
    }
}
struct DiscoveredMintRow: View {
    let mint: DiscoveredMint
    let isSelected: Bool
    let onToggle: () -> Void
    var body: some View {
        Button(action: onToggle) {
            HStack(spacing: 12) {
                // Selection indicator
                Image(systemName: isSelected ? "checkmark.circle.fill" : "circle")
                    .font(.title2)
                    .foregroundStyle(isSelected ? .orange : .secondary)
                // Mint info
                VStack(alignment: .leading, spacing: 4) {
                    Text(mint.name)
                        .font(.headline)
                        .foregroundStyle(.primary)
                    if let description = mint.description, !description.isEmpty {
                        Text(description)
                            .font(.caption)
                            .foregroundStyle(.secondary)
                            .lineLimit(2)
                    }
                    HStack(spacing: 8) {
                        // URL
                        Label(mint.url, systemImage: "link")
                            .font(.caption2)
                            .foregroundStyle(.tertiary)
                            .lineLimit(1)
                        // Pubkey if available
                        if let pubkey = mint.pubkey {
                            Label(String(pubkey.prefix(8)) + "...", systemImage: "person.circle")
                                .font(.caption2)
                                .foregroundStyle(.tertiary)
                                .lineLimit(1)
                        }
                    }
                }
                Spacer()
            }
            .padding(.vertical, 4)
        }
        .buttonStyle(.plain)
    }
}
</file>

<file path="Sources/NutsackiOS/Views/NutLogoView.swift">
import SwiftUI
struct HexagonShape: Shape {
    func path(in rect: CGRect) -> Path {
        var path = Path()
        let center = CGPoint(x: rect.midX, y: rect.midY)
        let radius = min(rect.width, rect.height) / 2
        let angle: CGFloat = 60 * .pi / 180
        // Start from the top point
        var currentAngle: CGFloat = -90 * .pi / 180
        // Move to first vertex
        path.move(to: CGPoint(
            x: center.x + radius * cos(currentAngle),
            y: center.y + radius * sin(currentAngle)
        ))
        // Draw lines to create hexagon
        for _ in 0..<6 {
            currentAngle += angle
            path.addLine(to: CGPoint(
                x: center.x + radius * cos(currentAngle),
                y: center.y + radius * sin(currentAngle)
            ))
        }
        path.closeSubpath()
        return path
    }
}
struct NutLogoView: View {
    let size: CGFloat
    let color: Color
    init(size: CGFloat = 100, color: Color = .white) {
        self.size = size
        self.color = color
    }
    var body: some View {
        // Create a hexagon with a circular hole in the center
        HexagonShape()
            .fill(color)
            .frame(width: size, height: size)
            .mask(
                ZStack {
                    // Full hexagon
                    Rectangle()
                        .fill(Color.white)
                        .frame(width: size * 2, height: size * 2)
                    // Cut out the center circle
                    Circle()
                        .fill(Color.black)
                        .frame(width: size * 0.4, height: size * 0.4)
                        .blendMode(.destinationOut)
                }
                .compositingGroup()
            )
    }
}
</file>

<file path="Sources/NutsackiOS/Views/SplashView.swift">
import SwiftUI
import NDKSwift
// Simple redirect to the new unified authentication flow
struct SplashView: View {
    var body: some View {
        AuthenticationFlow()
    }
}
// MARK: - Electric Arc Shape (reused by AuthenticationFlow)
struct ElectricArc: Shape {
    let startPoint: CGPoint
    let endPoint: CGPoint
    func path(in rect: CGRect) -> Path {
        var path = Path()
        let start = CGPoint(
            x: startPoint.x * rect.width,
            y: startPoint.y * rect.height
        )
        let end = CGPoint(
            x: endPoint.x * rect.width,
            y: endPoint.y * rect.height
        )
        path.move(to: start)
        // Create a jagged lightning effect
        let segments = 8
        for i in 1...segments {
            let progress = CGFloat(i) / CGFloat(segments)
            let baseX = start.x + (end.x - start.x) * progress
            let baseY = start.y + (end.y - start.y) * progress
            // Add random offset for electric effect
            let offsetRange: CGFloat = 20
            let offsetX = CGFloat.random(in: -offsetRange...offsetRange)
            let offsetY = CGFloat.random(in: -offsetRange...offsetRange)
            let point = CGPoint(x: baseX + offsetX, y: baseY + offsetY)
            if i == segments {
                path.addLine(to: end)
            } else {
                path.addLine(to: point)
            }
        }
        return path
    }
}
// MARK: - Dark Text Field Style (reused by AuthenticationFlow)
struct DarkTextFieldStyle: TextFieldStyle {
    func _body(configuration: TextField<Self._Label>) -> some View {
        configuration
            .padding(16)
            .background(Color.white.opacity(0.08))
            .foregroundColor(.white)
            .accentColor(.orange)
            .overlay(
                RoundedRectangle(cornerRadius: 12)
                    .stroke(Color.white.opacity(0.2), lineWidth: 1)
            )
            .clipShape(RoundedRectangle(cornerRadius: 12))
    }
}
</file>

<file path=".gitignore">
# Xcode
#
# gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore & Swift.gitignore

## User settings
xcuserdata/

## compatibility with Xcode 8 and earlier (ignoring not required starting Xcode 9)
*.xcscmblueprint
*.xccheckout

## compatibility with Xcode 3 and earlier (ignoring not required starting Xcode 4)
build/
DerivedData/
*.moved-aside
*.pbxuser
!default.pbxuser
*.mode1v3
!default.mode1v3
*.mode2v3
!default.mode2v3
*.perspectivev3
!default.perspectivev3

## Obj-C/Swift specific
*.hmap

## App packaging
*.ipa
*.dSYM.zip
*.dSYM

## Playgrounds
timeline.xctimeline
playground.xcworkspace

# Swift Package Manager
#
# Add this line if you want to avoid checking in source code from Swift Package Manager dependencies.
# Packages/
# Package.pins
# Package.resolved
# *.xcodeproj
#
# Xcode automatically generates this directory with a .xcworkspacedata file and xcuserdata
# hence it is not needed unless you have added a package configuration file to your project
# .swiftpm

.build/

# CocoaPods
#
# We recommend against adding the Pods directory to your .gitignore. However
# you should judge for yourself, the pros and cons are mentioned at:
# https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control
#
# Pods/
#
# Add this line if you want to avoid checking in source code from the Xcode workspace
# *.xcworkspace

# Carthage
#
# Add this line if you want to avoid checking in source code from Carthage dependencies.
# Carthage/Checkouts

Carthage/Build/

# Accio dependency management
Dependencies/
.accio/

# fastlane
#
# It is recommended to not store the screenshots in the git repo.
# Instead, use fastlane to re-generate the screenshots whenever they are needed.
# For more information about the recommended setup visit:
# https://docs.fastlane.tools/best-practices/source-control/#source-control

fastlane/report.xml
fastlane/Preview.html
fastlane/screenshots/**/*.png
fastlane/test_output

# Code Injection
#
# After new code Injection tools there's a generated folder /iOSInjectionProject
# https://github.com/johnno1962/injectionforxcode

iOSInjectionProject/

# macOS
.DS_Store

# Test Results
test-results/
wallet_settings_improved.png
wallet_view.pngrepomix-output.xml
</file>

<file path="Sources/NutsackiOS/DataSources/NostrDataSources.swift">
import Foundation
import NDKSwift
import NDKSwiftUI
// MARK: - Type Aliases for Compatibility
typealias UserProfileDataSource = NDKUIUserProfileDataSource
typealias MultipleProfilesDataSource = NDKUIMultipleProfilesDataSource
</file>

<file path="Sources/NutsackiOS/Models/AppState.swift">
import Foundation
import SwiftUI
import NDKSwift
enum ThemeMode: String, CaseIterable {
    case system = "system"
    case light = "light"
    case dark = "dark"
    var displayName: String {
        switch self {
        case .system: return "System"
        case .light: return "Light"
        case .dark: return "Dark"
        }
    }
    var colorScheme: ColorScheme? {
        switch self {
        case .system: return nil
        case .light: return .light
        case .dark: return .dark
        }
    }
}
@MainActor
class AppState: ObservableObject {
    private static let conversionUnitKey = "PreferredCurrencyConversionUnit"
    private static let themeKey = "PreferredTheme"
    private static let lastRNackHashKey = "LastReleaseNotesAcknoledgedHash"
    private static let firstLaunchFlag = "HasLaunchedBefore"
    private static let blacklistedMintsKey = "BlacklistedMints"
    // Debug mode for testing
    #if DEBUG
    @Published var debugSimulateMintFailure = false
    #endif
    struct ExchangeRateResponse: Decodable {
        let bitcoin: ExchangeRate
    }
    struct ExchangeRate: Decodable, Equatable {
        let usd: Int
        let eur: Int
    }
    @Published var preferredConversionUnit: CurrencyUnit {
        didSet {
            UserDefaults.standard.setValue(preferredConversionUnit.rawValue, forKey: AppState.conversionUnitKey)
        }
    }
    @Published var themeMode: ThemeMode {
        didSet {
            UserDefaults.standard.setValue(themeMode.rawValue, forKey: AppState.themeKey)
        }
    }
    @Published var blacklistedMints: Set<String> {
        didSet {
            UserDefaults.standard.set(Array(blacklistedMints), forKey: AppState.blacklistedMintsKey)
        }
    }
    @Published var exchangeRates: ExchangeRate?
    static var showOnboarding: Bool {
        get {
            return !UserDefaults.standard.bool(forKey: firstLaunchFlag)
        } set {
            UserDefaults.standard.set(!newValue, forKey: firstLaunchFlag)
        }
    }
    init() {
        if let unit = CurrencyUnit(rawValue: UserDefaults.standard.string(forKey: AppState.conversionUnitKey) ?? "") {
            preferredConversionUnit = unit
        } else {
            preferredConversionUnit = .usd
        }
        if let theme = ThemeMode(rawValue: UserDefaults.standard.string(forKey: AppState.themeKey) ?? "") {
            themeMode = theme
        } else {
            themeMode = .system
        }
        if let savedMints = UserDefaults.standard.array(forKey: AppState.blacklistedMintsKey) as? [String] {
            blacklistedMints = Set(savedMints)
        } else {
            blacklistedMints = []
        }
        loadExchangeRates()
    }
    func loadExchangeRates() {
        print("Loading exchange rates...")
        guard let url = URL(string: "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd,eur") else {
            print("Could not fetch exchange rates from API due to an invalid URL.")
            return
        }
        Task {
            guard let (data, _) = try? await URLSession.shared.data(from: url) else {
                print("Unable to load conversion data.")
                return
            }
            guard let prices = try? JSONCoding.decoder.decode(ExchangeRateResponse.self, from: data).bitcoin else {
                print("Unable to decode exchange rate data from request response.")
                return
            }
            await MainActor.run {
                self.exchangeRates = prices
            }
        }
    }
    // MARK: - Blacklist Management
    func blacklistMint(_ mintURL: String) {
        blacklistedMints.insert(mintURL)
    }
    func unblacklistMint(_ mintURL: String) {
        blacklistedMints.remove(mintURL)
    }
    func isMintBlacklisted(_ mintURL: String) -> Bool {
        blacklistedMints.contains(mintURL)
    }
}
enum CurrencyUnit: String, CaseIterable {
    case sat
    case usd
    case eur
    case btc
    var symbol: String {
        switch self {
        case .sat: return "sats"
        case .usd: return "$"
        case .eur: return "€"
        case .btc: return "₿"
        }
    }
}
</file>

<file path="Sources/NutsackiOS/Models/DataModels.swift">
import Foundation
import NDKSwift
// MARK: - MintInfo
// Local replacement for the removed NIP60Wallet.MintInfo type
struct MintInfo: Identifiable, Equatable, Hashable {
    let id: String
    let url: URL
    let name: String?
    let description: String?
    let isActive: Bool
    init(url: URL, name: String? = nil, description: String? = nil, isActive: Bool = true) {
        self.id = url.absoluteString
        self.url = url
        self.name = name
        self.description = description
        self.isActive = isActive
    }
}
// Note: MintInfo is now defined at the top level of this file
// References to NIP60Wallet.MintInfo should be changed to just MintInfo
// MARK: - Transaction
// UI model for displaying transactions (no longer a SwiftData @Model)
struct Transaction: Identifiable {
    let id = UUID()
    var transactionID: UUID
    var type: TransactionType
    var amount: Int
    var memo: String?
    var createdAt: Date
    var nostrEventID: String?  // For nutzaps
    var lightningInvoice: String?
    var status: TransactionStatus
    var senderPubkey: String?  // For nutzaps and received transactions
    var recipientPubkey: String?  // For sent nutzaps
    var offlineToken: String?  // Store generated offline token
    var timestamp: Date  // Transaction timestamp from wallet event
    var direction: TransactionDirection  // Direction of the transaction
    var mintURL: String?  // Mint URL for the transaction
    var errorDetails: String?  // Error details for failed transactions
    init(type: TransactionType, amount: Int, memo: String? = nil) {
        self.transactionID = UUID()
        self.type = type
        self.amount = amount
        self.memo = memo
        self.createdAt = Date()
        self.timestamp = Date()
        self.status = .pending
        self.direction = .neutral
    }
    enum TransactionType: String, Codable {
        case mint      // Lightning -> Ecash (deposit)
        case melt      // Ecash -> Lightning (withdraw)
        case send      // Send ecash token
        case receive   // Receive ecash token
        case nutzap    // NIP-61 zap
        case deposit   // Alias for mint
        case withdraw  // Alias for melt
        case swap      // Swap between mints
    }
    enum TransactionStatus: String, Codable {
        case pending
        case processing
        case completed
        case failed
        case expired
    }
    enum TransactionDirection: String, Codable {
        case incoming
        case outgoing
        case neutral
    }
}
// MARK: - Transaction Extensions
extension Transaction.TransactionType {
    var displayName: String {
        switch self {
        case .mint, .deposit: return "Lightning Deposit"
        case .melt, .withdraw: return "Lightning Payment"
        case .send: return "Sent Ecash"
        case .receive: return "Received Ecash"
        case .nutzap: return "Zap"
        case .swap: return "Mint Transfer"
        }
    }
}
// MARK: - WalletTransaction UI Extensions
extension WalletTransaction {
    /// Convert WalletTransaction to app's Transaction model for UI compatibility
    func toTransaction() -> Transaction {
        var transaction = Transaction(
            type: mapTransactionType(),
            amount: Int(amount),
            memo: memo ?? displayDescription
        )
        // Map status
        switch status {
        case .pending:
            transaction.status = .pending
        case .processing:
            transaction.status = .processing
        case .completed:
            transaction.status = .completed
        case .failed:
            transaction.status = .failed
        case .expired:
            transaction.status = .expired
        }
        // Map direction
        switch direction {
        case .incoming:
            transaction.direction = .incoming
        case .outgoing:
            transaction.direction = .outgoing
        case .neutral:
            transaction.direction = .neutral
        }
        // Set additional fields
        transaction.timestamp = timestamp
        transaction.createdAt = timestamp
        // Set nutzap-specific fields
        if let nutzapData = nutzapData {
            transaction.senderPubkey = nutzapData.senderPubkey
            transaction.recipientPubkey = nutzapData.recipientPubkey
            transaction.nostrEventID = nutzapData.nutzapEventId
        }
        // Set primary event ID
        if let primaryEventId = events.primaryEventId {
            transaction.nostrEventID = primaryEventId
        }
        // Set mint URL if available
        if let mint = mint {
            transaction.mintURL = mint
        }
        // Set offline token if available
        if let tokenData = ecashTokenData {
            transaction.offlineToken = tokenData.tokenString
        }
        // Set error details if available
        transaction.errorDetails = errorDetails
        return transaction
    }
    private func mapTransactionType() -> Transaction.TransactionType {
        switch type {
        case .mint:
            return .mint
        case .melt:
            return .melt
        case .send:
            return .send
        case .receive:
            return .receive
        case .nutzapSent, .nutzapReceived:
            return .nutzap
        case .swap:
            return .swap
        }
    }
}
</file>

<file path="Sources/NutsackiOS/Utils/QRScannerView.swift">
import SwiftUI
import NDKSwiftUI
#if os(iOS)
// Use the shared QR scanner from NDKSwiftUI
typealias QRScannerView = NDKUIQRScanner
#else
// Placeholder for non-iOS platforms
struct QRScannerView: View {
    let onScan: (String) -> Void
    let onDismiss: () -> Void
    var body: some View {
        Text("QR scanning is only available on iOS")
            .foregroundColor(.secondary)
    }
}
#endif
</file>

<file path="Sources/NutsackiOS/Views/Wallet/MintAllocationPieChart.swift">
import SwiftUI
import Foundation
struct MintAllocationPieChart: View {
    @Environment(WalletManager.self) private var walletManager
    @State private var mintBalances: [(mint: String, balance: Int64, percentage: Double)] = []
    @State private var selectedSlice: String?
    @State private var animationProgress: Double = 0
    @State private var isLoading = true
    // Customizable properties
    var chartSize: CGFloat = 240
    var showTitle: Bool = true
    var showLegend: Bool = true
    var expansionProgress: CGFloat = 1.0
    var onBalancesLoaded: ([(mint: String, balance: Int64, percentage: Double)]) -> Void = { _ in }
    private var innerRadius: CGFloat {
        if expansionProgress < 0.5 {
            return 0 // Solid circle when small
        } else {
            return chartSize * 0.3 * ((expansionProgress - 0.5) * 2) // Gradually hollow out
        }
    }
    // Beautiful color palette for the pie chart
    private let mintColors: [Color] = [
        Color(red: 0.98, green: 0.54, blue: 0.13), // Orange
        Color(red: 0.13, green: 0.59, blue: 0.95), // Blue
        Color(red: 0.96, green: 0.26, blue: 0.21), // Red
        Color(red: 0.30, green: 0.69, blue: 0.31), // Green
        Color(red: 0.61, green: 0.15, blue: 0.69), // Purple
        Color(red: 1.00, green: 0.92, blue: 0.23), // Yellow
        Color(red: 0.00, green: 0.74, blue: 0.83), // Cyan
        Color(red: 1.00, green: 0.60, blue: 0.00)  // Deep Orange
    ]
    var body: some View {
        VStack(spacing: 20) {
            if showTitle {
                titleView
            }
            if mintBalances.isEmpty && !isLoading {
                // Don't show empty state for embedded usage
                if showTitle {
                    emptyStateView
                }
            } else {
                if showLegend {
                    chartAndLegendView
                } else {
                    chartView
                }
            }
        }
        .padding(showTitle ? 20 : 0)
        .background(showTitle ? backgroundView : nil)
        .onAppear {
            Task {
                await loadMintBalances()
                withAnimation(.easeOut(duration: 0.8)) {
                    animationProgress = 1.0
                }
            }
        }
    }
    private var titleView: some View {
        HStack {
            Text("Mint Allocation")
                .font(.title3)
                .fontWeight(.semibold)
                .foregroundColor(.white)
            Spacer()
            if isLoading {
                ProgressView()
                    .scaleEffect(0.8)
                    .tint(.white)
            }
        }
    }
    private var emptyStateView: some View {
        VStack(spacing: 12) {
            Image(systemName: "chart.pie")
                .font(.system(size: 50))
                .foregroundColor(.gray)
            Text("No funds distributed yet")
                .font(.subheadline)
                .foregroundColor(.secondary)
        }
        .frame(height: chartSize)
    }
    private var chartAndLegendView: some View {
        HStack(spacing: 30) {
            chartView
            legendView
        }
    }
    private var chartView: some View {
        ZStack {
            // Background circle
            Circle()
                .fill(Color.gray.opacity(0.1))
                .frame(width: chartSize, height: chartSize)
            // Pie slices
            ForEach(Array(mintBalances.enumerated()), id: \.element.mint) { index, item in
                PieSlice(
                    startAngle: startAngle(for: index),
                    endAngle: endAngle(for: index),
                    innerRadius: innerRadius,
                    outerRadius: chartSize / 2,
                    color: mintColors[index % mintColors.count],
                    isSelected: selectedSlice == item.mint && showLegend,
                    animationProgress: animationProgress
                )
                .onTapGesture {
                    if showLegend {
                        withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                            selectedSlice = selectedSlice == item.mint ? nil : item.mint
                        }
                    }
                }
            }
            // Center hole with total
            centerTotalView
        }
        .frame(width: chartSize, height: chartSize)
    }
    private var centerTotalView: some View {
        Group {
            if expansionProgress > 0.5 && showLegend {
                VStack(spacing: 4) {
                    Text("Total")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text(formatSats(mintBalances.reduce(0) { $0 + $1.balance }))
                        .font(.headline)
                        .fontWeight(.bold)
                        .foregroundColor(.white)
                    Text("sats")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                }
                .opacity(Double((expansionProgress - 0.5) * 2))
            } else if expansionProgress > 0.5 {
                // Simplified center for BalanceCard usage
                VStack(spacing: 2) {
                    Text("\(mintBalances.count)")
                        .font(.system(size: 18 + (10 * expansionProgress), weight: .bold))
                        .foregroundColor(.white)
                    Text("mints")
                        .font(.system(size: 10 + (4 * expansionProgress)))
                        .foregroundColor(.secondary)
                }
                .opacity(Double((expansionProgress - 0.5) * 2))
            }
        }
    }
    private var legendView: some View {
        VStack(alignment: .leading, spacing: 12) {
            ForEach(Array(mintBalances.enumerated()), id: \.element.mint) { index, item in
                legendItem(for: item, at: index)
            }
        }
        .frame(maxWidth: .infinity)
    }
    private func legendItem(for item: (mint: String, balance: Int64, percentage: Double), at index: Int) -> some View {
        HStack(spacing: 8) {
            // Color indicator
            RoundedRectangle(cornerRadius: 4)
                .fill(mintColors[index % mintColors.count])
                .frame(width: 16, height: 16)
                .overlay(
                    RoundedRectangle(cornerRadius: 4)
                        .stroke(selectedSlice == item.mint ? Color(.label) : Color.clear, lineWidth: 2)
                )
            VStack(alignment: .leading, spacing: 2) {
                Text(formatMintName(item.mint))
                    .font(.caption)
                    .fontWeight(selectedSlice == item.mint ? .semibold : .regular)
                    .foregroundColor(.white)
                    .lineLimit(1)
                HStack(spacing: 4) {
                    Text("\(formatSats(item.balance)) sats")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                    Text("(\(Int(item.percentage))%)")
                        .font(.caption2)
                        .foregroundColor(.secondary.opacity(0.8))
                }
            }
            Spacer()
        }
        .opacity(selectedSlice == nil || selectedSlice == item.mint ? 1.0 : 0.5)
        .scaleEffect(selectedSlice == item.mint ? 1.05 : 1.0)
        .animation(.easeInOut(duration: 0.2), value: selectedSlice)
    }
    private var backgroundView: some View {
        RoundedRectangle(cornerRadius: 16)
            .fill(Color(.secondarySystemBackground))
            .overlay(
                RoundedRectangle(cornerRadius: 16)
                    .stroke(Color.gray.opacity(0.3), lineWidth: 1)
            )
    }
    private func loadMintBalances() async {
        isLoading = true
        defer { isLoading = false }
        guard let wallet = walletManager.wallet else { return }
        // Get balances grouped by mint directly
        let balancesByMint = await wallet.getBalancesByMint()
        var balances: [(mint: String, balance: Int64, percentage: Double)] = []
        let totalBalance = balancesByMint.values.reduce(0, +)
        // Calculate percentages
        if totalBalance > 0 {
            for (mint, balance) in balancesByMint {
                let percentage = (Double(balance) / Double(totalBalance)) * 100
                balances.append((mint: mint, balance: balance, percentage: percentage))
            }
        }
        // Sort by balance (largest first)
        balances.sort { $0.balance > $1.balance }
        await MainActor.run {
            self.mintBalances = balances
            self.onBalancesLoaded(balances)
        }
    }
    private func startAngle(for index: Int) -> Angle {
        guard index > 0 else { return .degrees(-90) }
        let previousAngles = mintBalances[0..<index].reduce(0.0) { sum, item in
            sum + (item.percentage / 100.0 * 360.0)
        }
        return .degrees(previousAngles - 90)
    }
    private func endAngle(for index: Int) -> Angle {
        // For the last slice, ensure it closes perfectly at 270 degrees (top of circle)
        if index == mintBalances.count - 1 {
            return .degrees(270) // Ensure perfect closure at top
        }
        let cumulativeAngle = mintBalances[0...index].reduce(0.0) { sum, item in
            sum + (item.percentage / 100.0 * 360.0)
        }
        return .degrees(cumulativeAngle - 90)
    }
    private func formatSats(_ sats: Int64) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.groupingSeparator = ","
        return formatter.string(from: NSNumber(value: sats)) ?? String(sats)
    }
    private func formatMintName(_ urlString: String) -> String {
        guard let url = URL(string: urlString),
              let host = url.host else {
            return urlString
        }
        // Remove common prefixes
        let cleanHost = host
            .replacingOccurrences(of: "www.", with: "")
            .replacingOccurrences(of: "mint.", with: "")
        // Truncate if too long
        if cleanHost.count > 20 {
            return String(cleanHost.prefix(17)) + "..."
        }
        return cleanHost
    }
}
// Custom pie slice shape
struct PieSlice: View {
    let startAngle: Angle
    let endAngle: Angle
    let innerRadius: CGFloat
    let outerRadius: CGFloat
    let color: Color
    let isSelected: Bool
    let animationProgress: Double
    var body: some View {
        ZStack {
            // Shadow for selected slice
            if isSelected {
                PieSliceShape(
                    startAngle: startAngle,
                    endAngle: endAngle,
                    innerRadius: innerRadius,
                    outerRadius: outerRadius + 5
                )
                .fill(color.opacity(0.3))
                .blur(radius: 8)
            }
            // Main slice
            PieSliceShape(
                startAngle: startAngle,
                endAngle: startAngle + (endAngle - startAngle) * animationProgress,
                innerRadius: innerRadius,
                outerRadius: isSelected ? outerRadius + 5 : outerRadius
            )
            .fill(
                LinearGradient(
                    gradient: Gradient(colors: [
                        color,
                        color.opacity(0.8)
                    ]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
            )
            // Highlight edge
            PieSliceShape(
                startAngle: startAngle,
                endAngle: startAngle + (endAngle - startAngle) * animationProgress,
                innerRadius: innerRadius,
                outerRadius: isSelected ? outerRadius + 5 : outerRadius
            )
            .stroke(color.opacity(0.8), lineWidth: 1)
        }
        .animation(.spring(response: 0.3, dampingFraction: 0.7), value: isSelected)
    }
}
struct PieSliceShape: Shape {
    let startAngle: Angle
    let endAngle: Angle
    let innerRadius: CGFloat
    let outerRadius: CGFloat
    func path(in rect: CGRect) -> Path {
        var path = Path()
        let center = CGPoint(x: rect.midX, y: rect.midY)
        // If it's a full circle (360 degrees), draw it specially to avoid gaps
        let angleDifference = endAngle.degrees - startAngle.degrees
        if abs(angleDifference - 360.0) < 0.01 || abs(angleDifference - (-360.0)) < 0.01 {
            // Full circle case
            if innerRadius > 0 {
                // Donut shape
                path.addEllipse(in: CGRect(
                    x: center.x - outerRadius,
                    y: center.y - outerRadius,
                    width: outerRadius * 2,
                    height: outerRadius * 2
                ))
                path.addEllipse(in: CGRect(
                    x: center.x - innerRadius,
                    y: center.y - innerRadius,
                    width: innerRadius * 2,
                    height: innerRadius * 2
                ))
            } else {
                // Full circle
                path.addEllipse(in: CGRect(
                    x: center.x - outerRadius,
                    y: center.y - outerRadius,
                    width: outerRadius * 2,
                    height: outerRadius * 2
                ))
            }
        } else {
            // Regular pie slice
            // Start point on outer radius
            let outerStartPoint = CGPoint(
                x: center.x + outerRadius * Foundation.cos(startAngle.radians),
                y: center.y + outerRadius * Foundation.sin(startAngle.radians)
            )
            path.move(to: outerStartPoint)
            // Outer arc
            path.addArc(
                center: center,
                radius: outerRadius,
                startAngle: startAngle,
                endAngle: endAngle,
                clockwise: false
            )
            // Line to inner arc (or center if innerRadius is 0)
            if innerRadius > 0 {
                let innerEndPoint = CGPoint(
                    x: center.x + innerRadius * Foundation.cos(endAngle.radians),
                    y: center.y + innerRadius * Foundation.sin(endAngle.radians)
                )
                path.addLine(to: innerEndPoint)
                // Inner arc (reversed)
                path.addArc(
                    center: center,
                    radius: innerRadius,
                    startAngle: endAngle,
                    endAngle: startAngle,
                    clockwise: true
                )
            } else {
                // Line to center for solid pie slice
                path.addLine(to: center)
            }
            // Close the path
            path.closeSubpath()
        }
        return path
    }
}
</file>

<file path="Sources/NutsackiOS/Views/Wallet/ProofManagementView.swift">
import SwiftUI
import NDKSwift
import CashuSwift
struct ProofManagementView: View {
    @Environment(WalletManager.self) private var walletManager
    @Environment(\.dismiss) private var dismiss
    @State private var allProofEntries: [ProofStateManager.ProofEntry] = []
    @State private var mintBalances: [String: Int64] = [:]
    @State private var isLoading = true
    @State private var isValidating = false
    @State private var validationResults: [String: [String: CashuSwift.Proof.ProofState]] = [:] // mint -> proof states
    @State private var selectedProofs: Set<String> = [] // proof.C values
    @State private var showDeleteConfirmation = false
    @State private var isDeleting = false
    @State private var deleteError: Error?
    var groupedProofs: [String: [ProofStateManager.ProofEntry]] {
        Dictionary(grouping: allProofEntries) { $0.mint }
    }
    var selectedProofCount: Int {
        selectedProofs.count
    }
    var selectedProofAmount: Int64 {
        allProofEntries
            .filter { selectedProofs.contains($0.proof.C) }
            .reduce(0) { $0 + Int64($1.proof.amount) }
    }
    var body: some View {
        NavigationStack {
            VStack {
                if isLoading {
                    ProgressView("Loading proofs...")
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                } else if allProofEntries.isEmpty {
                    ContentUnavailableView(
                        "No Proofs",
                        systemImage: "key",
                        description: Text("Your wallet doesn't contain any proofs")
                    )
                } else {
                    proofsList
                }
            }
            .navigationTitle("Proof Management")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                toolbarContent
            }
            .task {
                await loadAllProofs()
            }
            .refreshable {
                await loadAllProofs()
            }
            .confirmationDialog(
                "Delete Selected Proofs",
                isPresented: $showDeleteConfirmation,
                titleVisibility: .visible
            ) {
                Button("Delete \(selectedProofCount) Proofs (\(selectedProofAmount) sats)", role: .destructive) {
                    Task { await deleteSelectedProofs() }
                }
                Button("Cancel", role: .cancel) {}
            } message: {
                Text("This will permanently remove the selected proofs from your wallet. This action cannot be undone.")
            }
            .alert("Delete Error", isPresented: .constant(deleteError != nil)) {
                Button("OK") { deleteError = nil }
            } message: {
                if let error = deleteError {
                    Text(error.localizedDescription)
                }
            }
        }
    }
    private var proofsList: some View {
        List {
            // Summary section
            Section {
                HStack {
                    VStack(alignment: .leading) {
                        Text("Total Proofs")
                            .font(.caption)
                            .foregroundStyle(.secondary)
                        Text("\(allProofEntries.count)")
                            .font(.title2)
                            .fontWeight(.semibold)
                    }
                    Spacer()
                    if !selectedProofs.isEmpty {
                        VStack(alignment: .trailing) {
                            Text("Selected")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                            Text("\(selectedProofCount) (\(selectedProofAmount) sats)")
                                .font(.headline)
                                .foregroundColor(.orange)
                        }
                    }
                }
                .padding(.vertical, 4)
            }
            // Mints and their proofs
            ForEach(groupedProofs.keys.sorted(), id: \.self) { mint in
                if let proofs = groupedProofs[mint] {
                    Section {
                        ForEach(proofs.sorted { $0.proof.amount > $1.proof.amount }, id: \.proof.C) { entry in
                            ProofManagementRow(
                                entry: entry,
                                validationState: validationResults[mint]?[entry.proof.C],
                                isSelected: selectedProofs.contains(entry.proof.C),
                                onToggleSelection: { toggleSelection(entry.proof.C) }
                            )
                        }
                    } header: {
                        HStack {
                            Text(formatMintName(mint))
                            Spacer()
                            if let balance = mintBalances[mint] {
                                Text("\(balance) sats")
                                    .font(.caption)
                                    .foregroundStyle(.secondary)
                            }
                        }
                    }
                }
            }
        }
        .listStyle(.insetGrouped)
    }
    @ToolbarContentBuilder
    private var toolbarContent: some ToolbarContent {
        ToolbarItem(placement: .cancellationAction) {
            Button("Done") { dismiss() }
        }
        ToolbarItem(placement: .primaryAction) {
            HStack(spacing: 16) {
                if !selectedProofs.isEmpty {
                    Button(action: { selectedProofs.removeAll() }) {
                        Text("Clear")
                            .font(.caption)
                    }
                    Button(action: { showDeleteConfirmation = true }) {
                        Label("Delete", systemImage: "trash")
                            .foregroundColor(.red)
                    }
                    .disabled(isDeleting)
                }
                Button(action: { Task { await validateAllProofs() } }) {
                    if isValidating {
                        ProgressView()
                            .scaleEffect(0.8)
                    } else {
                        Label("Validate", systemImage: "checkmark.shield")
                    }
                }
                .disabled(isValidating || isDeleting)
            }
        }
    }
    private func toggleSelection(_ proofC: String) {
        if selectedProofs.contains(proofC) {
            selectedProofs.remove(proofC)
        } else {
            selectedProofs.insert(proofC)
        }
    }
    private func loadAllProofs() async {
        isLoading = true
        guard let wallet = walletManager.wallet else {
            await MainActor.run { isLoading = false }
            return
        }
        // Get all proof entries
        let entries = await wallet.proofStateManager.getAllEntries()
            .filter { $0.state != ProofStateManager.ProofState.deleted }
        // Calculate balances per mint
        var balances: [String: Int64] = [:]
        for entry in entries where entry.state == ProofStateManager.ProofState.available {
            balances[entry.mint, default: 0] += Int64(entry.proof.amount)
        }
        await MainActor.run {
            self.allProofEntries = entries
            self.mintBalances = balances
            self.isLoading = false
        }
    }
    private func validateAllProofs() async {
        isValidating = true
        validationResults.removeAll()
        guard let wallet = walletManager.wallet else {
            await MainActor.run { isValidating = false }
            return
        }
        // Validate proofs for each mint
        for (mint, _) in groupedProofs {
            guard let mintURL = URL(string: mint) else { continue }
            do {
                let states = try await wallet.checkProofStates(mintURL: mintURL)
                await MainActor.run {
                    validationResults[mint] = states
                }
            } catch {
                print("Failed to validate proofs for mint \(mint): \(error)")
            }
        }
        await MainActor.run {
            isValidating = false
        }
    }
    private func deleteSelectedProofs() async {
        isDeleting = true
        deleteError = nil
        guard let wallet = walletManager.wallet else {
            await MainActor.run { isDeleting = false }
            return
        }
        do {
            // Get the proofs to delete
            _ = allProofEntries
                .filter { selectedProofs.contains($0.proof.C) }
                .map { $0.proof }
            // Group proofs by mint
            var proofsByMint: [String: [CashuSwift.Proof]] = [:]
            for entry in allProofEntries where selectedProofs.contains(entry.proof.C) {
                proofsByMint[entry.mint, default: []].append(entry.proof)
            }
            // Create wallet state change for each mint
            for (mint, proofs) in proofsByMint {
                let stateChange = WalletStateChange(
                    store: [],
                    destroy: proofs,
                    mint: mint,
                    memo: "Manual proof deletion"
                )
                // Use the wallet's update method which properly creates token events with del tags
                _ = try await wallet.update(stateChange: stateChange)
            }
            // Reload proofs
            await loadAllProofs()
            await MainActor.run {
                selectedProofs.removeAll()
                isDeleting = false
            }
        } catch {
            await MainActor.run {
                deleteError = error
                isDeleting = false
            }
        }
    }
    private func formatMintName(_ urlString: String) -> String {
        guard let url = URL(string: urlString),
              let host = url.host else {
            return urlString
        }
        return host
            .replacingOccurrences(of: "www.", with: "")
            .replacingOccurrences(of: "mint.", with: "")
    }
}
// MARK: - Proof Management Row
struct ProofManagementRow: View {
    let entry: ProofStateManager.ProofEntry
    let validationState: CashuSwift.Proof.ProofState?
    let isSelected: Bool
    let onToggleSelection: () -> Void
    var stateIndicator: (color: Color, icon: String, text: String) {
        if let validationState = validationState {
            switch validationState {
            case .unspent:
                return (.green, "checkmark.circle.fill", "Valid")
            case .spent:
                return (.red, "xmark.circle.fill", "Spent")
            case .pending:
                return (.orange, "clock.fill", "Pending")
            }
        }
        switch entry.state {
        case .available:
            return (.blue, "circle", "Available")
        case .reserved:
            return (.orange, "lock.circle", "Reserved")
        case .deleted:
            return (.red, "trash.circle", "Deleted")
        }
    }
    var isSelectable: Bool {
        // Only allow selection of spent or problematic proofs
        if let validationState = validationState {
            return validationState == .spent
        }
        return entry.state == .available
    }
    var body: some View {
        HStack {
            // Selection checkbox
            Button(action: onToggleSelection) {
                Image(systemName: isSelected ? "checkmark.square.fill" : "square")
                    .foregroundColor(isSelected ? .orange : .secondary)
                    .font(.title3)
            }
            .buttonStyle(.plain)
            .disabled(!isSelectable)
            .opacity(isSelectable ? 1.0 : 0.3)
            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text("\(entry.proof.amount) sats")
                        .font(.system(.body, design: .monospaced))
                        .fontWeight(.medium)
                    Spacer()
                    HStack(spacing: 4) {
                        Image(systemName: stateIndicator.icon)
                            .font(.caption)
                        Text(stateIndicator.text)
                            .font(.caption)
                    }
                    .foregroundColor(stateIndicator.color)
                }
                HStack {
                    Text("C: " + entry.proof.C.prefix(12) + "...")
                        .font(.system(.caption2, design: .monospaced))
                        .foregroundStyle(.secondary)
                    if let eventId = entry.ownerEventId {
                        Text("•")
                            .foregroundStyle(.tertiary)
                        Text("Event: " + eventId.prefix(8) + "...")
                            .font(.system(.caption2, design: .monospaced))
                            .foregroundStyle(.tertiary)
                    }
                }
            }
        }
        .padding(.vertical, 4)
        .opacity(validationState == .spent ? 0.6 : 1.0)
    }
}
</file>

<file path="Sources/NutsackiOS/Views/Wallet/ReceivedNutzapsView.swift">
import SwiftUI
import NDKSwift
struct ReceivedNutzapsView: View {
    let walletManager: WalletManager
    @State private var nutzaps: [NutzapInfo] = []
    @State private var selectedFilter: NutzapStatusFilter = .all
    @State private var isRedeeming: Set<String> = []
    @State private var showError: Bool = false
    @State private var errorMessage: String = ""
    @State private var isRetryingAll: Bool = false
    var body: some View {
        List {
            // Summary section
            NutzapSummarySection(nutzaps: nutzaps)
                .listRowInsets(EdgeInsets())
                .listRowBackground(Color.clear)
            // Filter picker
            Picker("Filter", selection: $selectedFilter) {
                Text("All").tag(NutzapStatusFilter.all)
                Text("Pending").tag(NutzapStatusFilter.pending)
                Text("Redeemed").tag(NutzapStatusFilter.redeemed)
                Text("Failed").tag(NutzapStatusFilter.failed)
            }
            .pickerStyle(SegmentedPickerStyle())
            .padding(.vertical, 8)
            .listRowBackground(Color.clear)
            // Nutzap list
            ForEach(filteredNutzaps) { nutzap in
                NutzapRow(
                    nutzap: nutzap,
                    isRedeeming: isRedeeming.contains(nutzap.eventId),
                    onRedeem: { await redeemNutzap(nutzap) }
                )
            }
        }
        .listStyle(PlainListStyle())
        .navigationTitle("Received Zaps")
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                if hasRetryableFailures {
                    Button("Retry All") {
                        Task { await retryAllFailed() }
                    }
                    .disabled(isRetryingAll)
                }
            }
        }
        .alert("Redemption Error", isPresented: $showError) {
            Button("OK", role: .cancel) { }
        } message: {
            Text(errorMessage)
        }
        .task {
            await loadNutzaps()
        }
        .refreshable {
            await loadNutzaps()
        }
    }
    // MARK: - Computed Properties
    var filteredNutzaps: [NutzapInfo] {
        nutzaps.filter { nutzap in
            switch selectedFilter {
            case .all:
                return true
            case .pending:
                if case .pending = nutzap.status { return true }
                return false
            case .redeemed:
                if case .redeemed = nutzap.status { return true }
                return false
            case .failed:
                if case .failed = nutzap.status { return true }
                return false
            case .retryableFailed:
                if case .failed(let error, _, _) = nutzap.status {
                    return error.isRetryable
                }
                return false
            }
        }
    }
    var hasRetryableFailures: Bool {
        nutzaps.contains { nutzap in
            if case .failed(let error, _, _) = nutzap.status {
                return error.isRetryable
            }
            return false
        }
    }
    var pendingAmount: Int64 {
        nutzaps.filter { nutzap in
            if case .pending = nutzap.status { return true }
            return false
        }.reduce(0) { $0 + $1.amount }
    }
    var redeemedAmount: Int64 {
        nutzaps.filter { nutzap in
            if case .redeemed = nutzap.status { return true }
            return false
        }.reduce(0) { $0 + $1.amount }
    }
    var failedCount: Int {
        nutzaps.filter { nutzap in
            if case .failed = nutzap.status { return true }
            return false
        }.count
    }
    // MARK: - Methods
    private func loadNutzaps() async {
        guard let wallet = walletManager.wallet else { return }
        self.nutzaps = await wallet.getNutzaps()
    }
    private func redeemNutzap(_ nutzap: NutzapInfo) async {
        isRedeeming.insert(nutzap.eventId)
        defer { isRedeeming.remove(nutzap.eventId) }
        do {
            _ = try await walletManager.wallet?.redeemNutzap(nutzap.eventId)
            await loadNutzaps()
        } catch let error as NutzapRedemptionError {
            errorMessage = error.userFriendlyMessage
            showError = true
        } catch {
            errorMessage = "Failed to redeem nutzap: \(error.localizedDescription)"
            showError = true
        }
    }
    private func retryAllFailed() async {
        isRetryingAll = true
        defer { isRetryingAll = false }
        guard let wallet = walletManager.wallet else { return }
        let results = await wallet.retryFailedNutzaps()
        // Count successes and failures
        let successCount = results.filter { $0.result.success }.count
        let failureCount = results.count - successCount
        if successCount > 0 {
            // Reload to show updated statuses
            await loadNutzaps()
        }
        if failureCount > 0 {
            errorMessage = "Retried \(results.count) nutzaps: \(successCount) succeeded, \(failureCount) failed"
            showError = true
        }
    }
}
// MARK: - NutzapInfo Extension
extension NutzapInfo: @retroactive Identifiable {
    public var id: String { eventId }
}
// MARK: - Summary Section
struct NutzapSummarySection: View {
    let nutzaps: [NutzapInfo]
    var pendingAmount: Int64 {
        nutzaps.filter { nutzap in
            if case .pending = nutzap.status { return true }
            return false
        }.reduce(0) { $0 + $1.amount }
    }
    var redeemedAmount: Int64 {
        nutzaps.filter { nutzap in
            if case .redeemed = nutzap.status { return true }
            return false
        }.reduce(0) { $0 + $1.amount }
    }
    var failedCount: Int {
        nutzaps.filter { nutzap in
            if case .failed = nutzap.status { return true }
            return false
        }.count
    }
    var body: some View {
        VStack(spacing: 12) {
            HStack(spacing: 12) {
                // Pending card
                SummaryCard(
                    title: "Pending",
                    value: "\(pendingAmount) sats",
                    color: .orange,
                    icon: "clock.fill"
                )
                // Redeemed card
                SummaryCard(
                    title: "Redeemed",
                    value: "\(redeemedAmount) sats",
                    color: .green,
                    icon: "checkmark.circle.fill"
                )
                // Failed card
                if failedCount > 0 {
                    SummaryCard(
                        title: "Failed",
                        value: "\(failedCount)",
                        color: .red,
                        icon: "exclamationmark.triangle.fill"
                    )
                }
            }
        }
        .padding(.horizontal)
        .padding(.vertical, 12)
    }
}
struct SummaryCard: View {
    let title: String
    let value: String
    let color: Color
    let icon: String
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                Image(systemName: icon)
                    .foregroundColor(color)
                Text(title)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            Text(value)
                .font(.headline)
                .foregroundColor(.primary)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding(.horizontal, 12)
        .padding(.vertical, 10)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(color.opacity(0.1))
        )
    }
}
// MARK: - Nutzap Row
struct NutzapRow: View {
    let nutzap: NutzapInfo
    let isRedeeming: Bool
    let onRedeem: () async -> Void
    var body: some View {
        HStack {
            // Status indicator
            NutzapStatusIndicator(status: nutzap.status)
                .frame(width: 32)
            VStack(alignment: .leading, spacing: 2) {
                // Amount and sender
                HStack {
                    Text("\(nutzap.amount) sats")
                        .font(.headline)
                    Text("from \(nutzap.sender.prefix(8))...")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                // Comment if present
                if let comment = nutzap.comment, !comment.isEmpty {
                    Text(comment)
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .lineLimit(2)
                }
                // Timestamp
                RelativeTimeView(date: Date(timeIntervalSince1970: TimeInterval(nutzap.createdAt)))
                    .font(.caption2)
                    .foregroundColor(.secondary)
                // Error message for failed nutzaps
                if case .failed(let error, let attempts, _) = nutzap.status {
                    Text(error.userFriendlyMessage)
                        .font(.caption)
                        .foregroundColor(.red)
                    if attempts > 1 {
                        Text("\(attempts) attempts")
                            .font(.caption2)
                            .foregroundColor(.secondary)
                    }
                }
            }
            Spacer()
            // Action button for failed nutzaps
            if case .failed(let error, _, _) = nutzap.status, error.isRetryable {
                Button {
                    Task { await onRedeem() }
                } label: {
                    if isRedeeming {
                        ProgressView()
                            .scaleEffect(0.8)
                    } else {
                        Image(systemName: "arrow.clockwise")
                            .foregroundColor(.blue)
                    }
                }
                .buttonStyle(BorderlessButtonStyle())
                .disabled(isRedeeming)
            }
        }
        .padding(.vertical, 2)
    }
}
// MARK: - Status Indicator
struct NutzapStatusIndicator: View {
    let status: NutzapRedemptionStatus
    var body: some View {
        Circle()
            .fill(statusColor)
            .frame(width: 12, height: 12)
            .overlay(
                Image(systemName: statusIcon)
                    .font(.system(size: 8))
                    .foregroundColor(.white)
            )
    }
    var statusColor: Color {
        switch status {
        case .pending:
            return .orange
        case .redeemed:
            return .green
        case .failed:
            return .red
        }
    }
    var statusIcon: String {
        switch status {
        case .pending:
            return "clock"
        case .redeemed:
            return "checkmark"
        case .failed:
            return "exclamationmark"
        }
    }
}
</file>

<file path="Sources/NutsackiOS/Views/Wallet/ReceiveView.swift">
import SwiftUI
import NDKSwift
struct ReceiveView: View {
    let tokenString: String?
    @Environment(\.dismiss) private var dismiss
    @Environment(WalletManager.self) private var walletManager
    @State private var inputToken = ""
    @State private var isProcessing = false
    @State private var showError = false
    @State private var errorMessage = ""
    @State private var showScanner = false
    @State private var receivedAmount: Int?
    @State private var showSuccess = false
    var body: some View {
        Form {
            Section {
                VStack(alignment: .leading, spacing: 12) {
                    HStack {
                        TextField("Paste ecash token", text: $inputToken, axis: .vertical)
                            .lineLimit(3...6)
                            .font(.system(.body, design: .monospaced))
                        Button(action: { showScanner = true }) {
                            Image(systemName: "qrcode.viewfinder")
                                .font(.title2)
                                .foregroundColor(.white)
                                .frame(width: 44, height: 44)
                                .background(Color.orange)
                                .cornerRadius(10)
                        }
                        .buttonStyle(.plain)
                    }
                    if !inputToken.isEmpty {
                        // Token preview
                        HStack {
                            Image(systemName: "banknote")
                                .foregroundStyle(.orange)
                            Text("Ecash token detected")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                        }
                    }
                }
            } header: {
                Text("Ecash Token")
            } footer: {
                Text("Paste or scan an ecash token to redeem it")
            }
            Section {
                Button(action: redeemToken) {
                    if isProcessing {
                        ProgressView()
                            .frame(maxWidth: .infinity)
                    } else {
                        Text("Redeem Token")
                            .frame(maxWidth: .infinity)
                    }
                }
                .disabled(inputToken.isEmpty || isProcessing)
            }
        }
        .navigationTitle("Receive Ecash")
        .platformNavigationBarTitleDisplayMode(inline: true)
        .toolbar {
            ToolbarItem(placement: .cancellationAction) {
                Button("Cancel") { dismiss() }
            }
        }
        .alert("Error", isPresented: $showError) {
            Button("OK") { }
        } message: {
            Text(errorMessage)
        }
        .sheet(isPresented: $showScanner) {
            QRScannerView(
                onScan: { scannedValue in
                    inputToken = scannedValue
                    showScanner = false
                },
                onDismiss: {
                    showScanner = false
                }
            )
        }
        .fullScreenCover(isPresented: $showSuccess) {
            if let amount = receivedAmount {
                PaymentReceivedAnimation(amount: Int64(amount)) {
                    dismiss()
                }
            }
        }
        .onAppear {
            if let token = tokenString {
                inputToken = token
                // Auto-redeem if token was provided
                redeemToken()
            }
        }
    }
    private func redeemToken() {
        guard !inputToken.isEmpty else { return }
        isProcessing = true
        Task {
            do {
                // Redeem the token
                let amount = try await walletManager.receive(
                    tokenString: inputToken.trimmingCharacters(in: .whitespacesAndNewlines)
                )
                // Transaction will be recorded automatically via NIP-60 history events
                await MainActor.run {
                    receivedAmount = Int(amount)
                    showSuccess = true
                    isProcessing = false
                }
            } catch {
                await MainActor.run {
                    errorMessage = error.localizedDescription
                    showError = true
                    isProcessing = false
                }
            }
        }
    }
}
// MARK: - Receive Success View
struct ReceiveSuccessView: View {
    let amount: Int
    let onDone: () -> Void
    @State private var animationAmount = 0.0
    var body: some View {
        VStack(spacing: 30) {
            Spacer()
            // Success animation
            ZStack {
                Circle()
                    .stroke(Color.green.opacity(0.3), lineWidth: 4)
                    .frame(width: 120, height: 120)
                    .scaleEffect(animationAmount)
                    .opacity(2 - animationAmount)
                Image(systemName: "checkmark.circle.fill")
                    .font(.system(size: 80))
                    .foregroundStyle(.green)
                    .scaleEffect(animationAmount > 0 ? 1 : 0.5)
            }
            VStack(spacing: 8) {
                Text("Received!")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                Text("\(amount) sats")
                    .font(.title)
                    .foregroundStyle(.orange)
            }
            Spacer()
            Button(action: onDone) {
                Text("Done")
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.orange)
                    .foregroundColor(.white)
                    .cornerRadius(12)
            }
            .padding(.horizontal, 40)
            .padding(.bottom, 40)
        }
        .onAppear {
            withAnimation(.easeOut(duration: 0.6)) {
                animationAmount = 1.5
            }
        }
    }
}
</file>

<file path="Sources/NutsackiOS/Views/Wallet/RelayHealthView.swift">
import SwiftUI
import NDKSwift
struct RelayHealthView: View {
    @Environment(WalletManager.self) private var walletManager
    @State private var relayHealth: [WalletHealthMonitor.RelayHealth] = []
    @State private var isLoading = true
    @State private var lastUpdateTime: Date?
    @State private var showingRepairSheet = false
    @State private var selectedUnhealthyRelay: WalletHealthMonitor.RelayHealth?
    @State private var showWalletSettings = false
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Header with refresh button
                VStack {
                    HStack {
                        VStack(alignment: .leading) {
                            Text("Wallet Relay Health")
                                .font(.title2)
                                .fontWeight(.bold)
                            if let lastUpdate = lastUpdateTime {
                                Text("Last updated: \(lastUpdate, style: .time)")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                        }
                        Spacer()
                        Button(action: {
                            Task {
                                await refreshHealth()
                            }
                        }) {
                            Image(systemName: "arrow.clockwise")
                                .foregroundColor(.blue)
                                .font(.title2)
                        }
                        .disabled(isLoading)
                    }
                    .padding()
                    // Health summary
                    if !relayHealth.isEmpty {
                        healthSummaryCard
                    }
                }
                .background(Color(UIColor.systemGroupedBackground))
                // Relay list
                if isLoading {
                    Spacer()
                    ProgressView("Checking relay health...")
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                } else if relayHealth.isEmpty {
                    emptyStateView
                } else {
                    relayListView
                }
            }
            .onAppear {
                Task {
                    await refreshHealth()
                }
            }
            .sheet(isPresented: $showingRepairSheet) {
                if let unhealthyRelay = selectedUnhealthyRelay {
                    RelayRepairSheet(relayHealth: unhealthyRelay) {
                        // Refresh after repair
                        Task {
                            await refreshHealth()
                        }
                    }
                }
            }
            .sheet(isPresented: $showWalletSettings) {
                WalletSettingsView()
            }
        }
    }
    private var healthSummaryCard: some View {
        VStack(spacing: 12) {
            HStack {
                // Healthy relays
                VStack {
                    Text("\(healthyRelayCount)")
                        .font(.title)
                        .fontWeight(.bold)
                        .foregroundColor(.green)
                    Text("Healthy")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                .frame(maxWidth: .infinity)
                Divider()
                    .frame(height: 40)
                // Unhealthy relays
                VStack {
                    Text("\(unhealthyRelayCount)")
                        .font(.title)
                        .fontWeight(.bold)
                        .foregroundColor(unhealthyRelayCount > 0 ? .red : .secondary)
                    Text("Issues")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                .frame(maxWidth: .infinity)
                Divider()
                    .frame(height: 40)
                // Total relays
                VStack {
                    Text("\(relayHealth.count)")
                        .font(.title)
                        .fontWeight(.bold)
                        .foregroundColor(.primary)
                    Text("Total")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                .frame(maxWidth: .infinity)
            }
            // Overall status
            HStack {
                Image(systemName: overallHealthIcon)
                    .foregroundColor(overallHealthColor)
                Text(overallHealthMessage)
                    .font(.subheadline)
                    .foregroundColor(overallHealthColor)
            }
        }
        .padding()
        .background(Color(UIColor.secondarySystemGroupedBackground))
        .cornerRadius(12)
        .padding(.horizontal)
    }
    private var relayListView: some View {
        List {
            ForEach(Array(relayHealth.enumerated()), id: \.element.relay.url) { _, health in
                RelayHealthRow(
                    relayHealth: health,
                    onRepairTapped: {
                        selectedUnhealthyRelay = health
                        showingRepairSheet = true
                    }
                )
                .listRowInsets(EdgeInsets(top: 8, leading: 16, bottom: 8, trailing: 16))
            }
        }
        .listStyle(PlainListStyle())
    }
    private var emptyStateView: some View {
        VStack(spacing: 16) {
            Image(systemName: "antenna.radiowaves.left.and.right.slash")
                .font(.system(size: 48))
                .foregroundColor(.secondary)
            Text("No Wallet Relays")
                .font(.title2)
                .fontWeight(.semibold)
            Text("Your wallet doesn't have specific relay tags configured. All wallet operations use your default outbox relays.")
                .font(.body)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
                .padding(.horizontal)
            Button("Configure Wallet Relays") {
                showWalletSettings = true
            }
            .buttonStyle(.borderedProminent)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .padding()
    }
    // MARK: - Health Calculations
    private var healthyRelayCount: Int {
        relayHealth.filter { $0.isHealthy }.count
    }
    private var unhealthyRelayCount: Int {
        relayHealth.filter { !$0.isHealthy }.count
    }
    private var overallHealthIcon: String {
        if unhealthyRelayCount == 0 {
            return "checkmark.circle.fill"
        } else if unhealthyRelayCount < relayHealth.count {
            return "exclamationmark.triangle.fill"
        } else {
            return "xmark.circle.fill"
        }
    }
    private var overallHealthColor: Color {
        if unhealthyRelayCount == 0 {
            return .green
        } else if unhealthyRelayCount < relayHealth.count {
            return .orange
        } else {
            return .red
        }
    }
    private var overallHealthMessage: String {
        if unhealthyRelayCount == 0 {
            return "All relays are healthy"
        } else if unhealthyRelayCount < relayHealth.count {
            return "Some relays have issues"
        } else {
            return "All relays have issues"
        }
    }
    // MARK: - Actions
    private func refreshHealth() async {
        guard let wallet = walletManager.wallet else { return }
        isLoading = true
        defer { isLoading = false }
        let health = await wallet.getRelayHealth()
        await MainActor.run {
            self.relayHealth = health
            self.lastUpdateTime = Date()
        }
    }
}
struct RelayHealthRow: View {
    let relayHealth: WalletHealthMonitor.RelayHealth
    let onRepairTapped: () -> Void
    private var displayURL: String {
        let url = relayHealth.relay.url
        if url.hasPrefix("wss://") {
            return String(url.dropFirst(6))
        } else if url.hasPrefix("ws://") {
            return String(url.dropFirst(5))
        }
        return url
    }
    var body: some View {
        VStack(spacing: 8) {
            HStack {
                // Status indicator
                Circle()
                    .fill(relayHealth.isHealthy ? Color.green : Color.red)
                    .frame(width: 12, height: 12)
                // Relay URL
                VStack(alignment: .leading, spacing: 2) {
                    Text(displayURL)
                        .font(.headline)
                        .lineLimit(1)
                    Text("\(relayHealth.knownEvents) events")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                Spacer()
                // Health status
                if relayHealth.isHealthy {
                    Image(systemName: "checkmark.circle")
                        .foregroundColor(.green)
                        .font(.title3)
                } else {
                    Button("Repair") {
                        onRepairTapped()
                    }
                    .buttonStyle(.bordered)
                    .controlSize(.small)
                }
            }
            // Issue details
            if !relayHealth.isHealthy {
                VStack(alignment: .leading, spacing: 4) {
                    if !relayHealth.missingEvents.isEmpty {
                        HStack {
                            Image(systemName: "minus.circle")
                                .foregroundColor(.orange)
                                .font(.caption)
                            Text("Missing \(relayHealth.missingEvents.count) events")
                                .font(.caption)
                                .foregroundColor(.orange)
                        }
                    }
                    if !relayHealth.extraEvents.isEmpty {
                        HStack {
                            Image(systemName: "plus.circle")
                                .foregroundColor(.red)
                                .font(.caption)
                            Text("\(relayHealth.extraEvents.count) deleted events still present")
                                .font(.caption)
                                .foregroundColor(.red)
                        }
                    }
                }
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding(.leading, 20)
            }
        }
        .padding(.vertical, 4)
    }
}
struct RelayRepairSheet: View {
    let relayHealth: WalletHealthMonitor.RelayHealth
    let onComplete: () -> Void
    @Environment(\.dismiss) private var dismiss
    @Environment(WalletManager.self) private var walletManager
    @State private var isRepairing = false
    @State private var showErrorAlert = false
    @State private var errorMessage = ""
    var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                // Header
                VStack(spacing: 8) {
                    Image(systemName: "wrench.and.screwdriver")
                        .font(.system(size: 48))
                        .foregroundColor(.blue)
                    Text("Repair Relay")
                        .font(.title2)
                        .fontWeight(.bold)
                    Text(relayHealth.relay.url)
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                }
                .padding()
                // Issue summary
                VStack(alignment: .leading, spacing: 12) {
                    Text("Issues Found:")
                        .font(.headline)
                    if !relayHealth.missingEvents.isEmpty {
                        HStack {
                            Image(systemName: "minus.circle")
                                .foregroundColor(.orange)
                            Text("Missing \(relayHealth.missingEvents.count) events")
                            Spacer()
                        }
                    }
                    if !relayHealth.extraEvents.isEmpty {
                        HStack {
                            Image(systemName: "plus.circle")
                                .foregroundColor(.red)
                            Text("\(relayHealth.extraEvents.count) stale events")
                            Spacer()
                        }
                    }
                }
                .padding()
                .background(Color(UIColor.secondarySystemGroupedBackground))
                .cornerRadius(12)
                Spacer()
                // Repair button
                Button(action: performRepair) {
                    HStack {
                        if isRepairing {
                            ProgressView()
                                .scaleEffect(0.8)
                        } else {
                            Image(systemName: "wrench")
                        }
                        Text(isRepairing ? "Repairing..." : "Repair Relay")
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.blue)
                    .foregroundColor(.white)
                    .cornerRadius(12)
                }
                .disabled(isRepairing)
                Text("This will republish missing events to the relay.")
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .multilineTextAlignment(.center)
            }
            .padding()
            .navigationTitle("Relay Repair")
            .navigationBarTitleDisplayMode(.inline)
            .navigationBarItems(
                leading: Button("Cancel") {
                    dismiss()
                }
            )
            .alert("Repair Failed", isPresented: $showErrorAlert) {
                Button("OK", role: .cancel) { }
            } message: {
                Text(errorMessage)
            }
        }
    }
    private func performRepair() {
        guard let wallet = walletManager.wallet else { return }
        Task {
            isRepairing = true
            defer { isRepairing = false }
            do {
                try await wallet.repairRelay(relayHealth.relay, missingEventIds: relayHealth.missingEvents)
                await MainActor.run {
                    onComplete()
                    dismiss()
                }
            } catch {
                print("Repair failed: \(error)")
                await MainActor.run {
                    errorMessage = error.localizedDescription
                    showErrorAlert = true
                    isRepairing = false
                }
            }
        }
    }
}
#Preview {
    // Create mock objects for preview
    let nostrManager = NostrManager(from: "Health")
    RelayHealthView()
        .environment(WalletManager(nostrManager: nostrManager, appState: AppState()))
}
</file>

<file path="Sources/NutsackiOS/Views/Wallet/RelayStatusIndicator.swift">
import SwiftUI
import NDKSwift
/// Compact relay health indicator for the main wallet view
struct RelayStatusIndicator: View {
    @Environment(WalletManager.self) private var walletManager
    @State private var relayHealth: [WalletHealthMonitor.RelayHealth] = []
    @State private var isLoading = false
    private var healthyRelayCount: Int {
        relayHealth.filter { $0.isHealthy }.count
    }
    private var totalRelayCount: Int {
        relayHealth.count
    }
    private var hasIssues: Bool {
        relayHealth.contains { !$0.isHealthy }
    }
    private var statusColor: Color {
        if relayHealth.isEmpty {
            return .secondary
        } else if hasIssues {
            return .orange
        } else {
            return .green
        }
    }
    private var statusIcon: String {
        if relayHealth.isEmpty {
            return "antenna.radiowaves.left.and.right.slash"
        } else if hasIssues {
            return "exclamationmark.triangle.fill"
        } else {
            return "checkmark.circle.fill"
        }
    }
    private var statusText: String {
        if relayHealth.isEmpty {
            return "No wallet relays"
        } else if hasIssues {
            return "\(healthyRelayCount)/\(totalRelayCount) relays healthy"
        } else {
            return "All \(totalRelayCount) relays healthy"
        }
    }
    var body: some View {
        HStack(spacing: 8) {
            // Status icon
            if isLoading {
                ProgressView()
                    .scaleEffect(0.7)
                    .frame(width: 16, height: 16)
            } else {
                Image(systemName: statusIcon)
                    .foregroundColor(statusColor)
                    .font(.caption)
            }
            // Status text
            Text(statusText)
                .font(.caption)
                .foregroundColor(.secondary)
            Spacer()
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 8)
        .background(Color(UIColor.secondarySystemGroupedBackground))
        .cornerRadius(8)
        .onAppear {
            Task {
                await refreshHealth()
            }
        }
    }
    private func refreshHealth() async {
        guard let wallet = walletManager.wallet else { return }
        isLoading = true
        defer { isLoading = false }
        let health = await wallet.getRelayHealth()
        await MainActor.run {
            self.relayHealth = health
        }
    }
}
#Preview {
    // Create mock objects for preview
    let nostrManager = NostrManager(from: "Status")
    RelayStatusIndicator()
        .environment(WalletManager(nostrManager: nostrManager, appState: AppState()))
        .padding()
}
</file>

<file path="Sources/NutsackiOS/Views/Wallet/SendView.swift">
import SwiftUI
import NDKSwift
import CashuSwift
#if os(iOS)
import UIKit
#elseif os(macOS)
import AppKit
#endif
struct SendView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(WalletManager.self) private var walletManager
    @State private var amount = ""
    @State private var memo = ""
    @State private var selectedMintURL: URL?
    @State private var isSending = false
    @State private var showError = false
    @State private var errorMessage = ""
    @State private var generatedToken: String?
    @State private var showTokenView = false
    @State private var availableBalance: Int = 0
    @State private var mints: [MintInfo] = []
    @State private var mintBalances: [String: Int64] = [:] // mint URL to balance
    @State private var isOfflineMode = false
    // Offline mode states
    @State private var availableAmounts: [Int64] = []
    @State private var proofCombinations: [Int64: [CashuSwift.Proof]] = [:]
    @State private var selectedAmount: Int64?
    @State private var availableProofs: [CashuSwift.Proof] = []
    @State private var pickerAmounts: [Int64] = []
    @State private var selectedPickerIndex = 0
    @State private var isLoadingOfflineAmounts = false
    @FocusState private var amountFieldFocused: Bool
    // Common amounts to suggest
    private let commonAmounts: [Int64] = AmountPresets.extendedAmounts.map { Int64($0) }
    var availableBalanceForMint: Int {
        return availableBalance
    }
    var amountInt: Int {
        Int(amount) ?? 0
    }
    var formattedAmount: String {
        if amount.isEmpty {
            return "0"
        }
        if let number = Int(amount) {
            let formatter = NumberFormatter()
            formatter.numberStyle = .decimal
            formatter.groupingSeparator = ","
            return formatter.string(from: NSNumber(value: number)) ?? amount
        }
        return amount
    }
    var body: some View {
        VStack(spacing: 0) {
            ScrollView {
                VStack(spacing: 24) {
                    // Amount Section
                    VStack(spacing: 16) {
                        if !isOfflineMode {
                            // Hidden text field that drives the amount
                            TextField("0", text: $amount)
                                .keyboardType(.numberPad)
                                .opacity(0)
                                .frame(height: 0)
                                .focused($amountFieldFocused)
                            // Visual amount display (same style as MintView)
                            VStack(spacing: 8) {
                                HStack(alignment: .firstTextBaseline, spacing: 8) {
                                    Text(formattedAmount)
                                        .font(.system(size: 48, weight: .semibold, design: .rounded))
                                        .foregroundStyle(.primary)
                                    Text("sats")
                                        .font(.system(size: 20, weight: .medium, design: .rounded))
                                        .foregroundStyle(.secondary)
                                }
                                .contentShape(Rectangle())
                                .onTapGesture {
                                    amountFieldFocused = true
                                }
                                // Available balance
                                Text("Available: \(availableBalanceForMint) sats")
                                    .font(.system(size: 16, weight: .regular, design: .rounded))
                                    .foregroundStyle(amountInt > availableBalanceForMint ? .red : .secondary)
                                    .opacity(0.8)
                            }
                        }
                        // Offline mode toggle (moved under input)
                        VStack(spacing: 12) {
                            Toggle("Offline Mode", isOn: $isOfflineMode)
                                .tint(.orange)
                                .padding(.horizontal)
                            Text(isOfflineMode ?
                                 "" :
                                 "Send tokens directly with network connection")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                                .padding(.horizontal)
                        }
                    }
                    .padding(.horizontal)
                    // Offline mode amount selection
                    if isOfflineMode && selectedMintURL != nil && isLoadingOfflineAmounts {
                        // Show loading indicator
                        VStack(spacing: 12) {
                            Text("Select Amount")
                                .font(.headline)
                                .padding(.horizontal)
                            HStack {
                                Spacer()
                                ProgressView("Loading available amounts...")
                                    .padding()
                                Spacer()
                            }
                        }
                    } else if isOfflineMode && selectedMintURL != nil && !availableAmounts.isEmpty {
                        // Offline mode: Amount picker
                        VStack(spacing: 16) {
                            Text("Select Amount")
                                .font(.headline)
                                .padding(.horizontal)
                            // Picker wheel
                            Picker("Amount", selection: $selectedPickerIndex) {
                                ForEach(Array(pickerAmounts.enumerated()), id: \.offset) { index, amount in
                                    HStack(spacing: 8) {
                                        Text(formatAmount(amount))
                                            .font(.system(size: 24, weight: .semibold, design: .rounded))
                                        Text("sats")
                                            .font(.system(size: 16, weight: .medium, design: .rounded))
                                            .foregroundStyle(.secondary)
                                    }
                                    .tag(index)
                                }
                            }
                            .pickerStyle(.wheel)
                            .frame(height: 120)
                            .clipped()
                            .onChange(of: selectedPickerIndex) { _, newIndex in
                                if newIndex < pickerAmounts.count {
                                    selectedAmount = pickerAmounts[newIndex]
                                }
                            }
                        }
                    }
                    // Mint Selection
                    VStack(alignment: .leading, spacing: 12) {
                        Text("Select Mint")
                            .font(.headline)
                            .padding(.horizontal)
                        if !mints.isEmpty {
                            // Filter to only show mints with balance
                            let mintsWithBalance = mints.filter { mintBalances[$0.url.absoluteString] ?? 0 > 0 }
                            if mintsWithBalance.isEmpty {
                                HStack {
                                    Image(systemName: "exclamationmark.triangle")
                                        .foregroundStyle(.orange)
                                    Text("No mints with available balance")
                                        .foregroundStyle(.secondary)
                                }
                                .padding(.horizontal)
                            } else {
                                ScrollView(.horizontal, showsIndicators: false) {
                                    HStack(spacing: 12) {
                                        // Auto-select option
                                        VStack(spacing: 8) {
                                            Circle()
                                                .fill(selectedMintURL == nil ? Color.orange : Color.orange.opacity(0.15))
                                                .frame(width: 50, height: 50)
                                                .overlay(
                                                    Image(systemName: "sparkles")
                                                        .font(.system(size: 20))
                                                        .foregroundColor(selectedMintURL == nil ? .white : .orange)
                                                )
                                                .overlay(
                                                    Circle()
                                                        .stroke(selectedMintURL == nil ? Color.orange : Color.clear, lineWidth: 2)
                                                )
                                            VStack(spacing: 2) {
                                                Text("Auto")
                                                    .font(.caption)
                                                    .fontWeight(.medium)
                                                    .foregroundColor(.primary)
                                                let totalBalance = mintBalances.values.reduce(0, +)
                                                Text("\(totalBalance) sats")
                                                    .font(.caption2)
                                                    .foregroundColor(.orange)
                                            }
                                        }
                                        .frame(width: 70)
                                        .contentShape(Rectangle())
                                        .onTapGesture {
                                            selectedMintURL = nil
                                        }
                                        // Mints with balance, sorted by balance (highest first)
                                        ForEach(mintsWithBalance.sorted(by: {
                                            (mintBalances[$0.url.absoluteString] ?? 0) > (mintBalances[$1.url.absoluteString] ?? 0)
                                        }), id: \.url.absoluteString) { mint in
                                            VStack(spacing: 8) {
                                                Circle()
                                                    .fill(selectedMintURL == mint.url ? Color.orange : Color.orange.opacity(0.15))
                                                    .frame(width: 50, height: 50)
                                                    .overlay(
                                                        Image(systemName: "building.columns")
                                                            .font(.system(size: 20))
                                                            .foregroundColor(selectedMintURL == mint.url ? .white : .orange)
                                                    )
                                                    .overlay(
                                                        Circle()
                                                            .stroke(selectedMintURL == mint.url ? Color.orange : Color.clear, lineWidth: 2)
                                                    )
                                                VStack(spacing: 2) {
                                                    Text(mint.url.host ?? "Mint")
                                                        .font(.caption)
                                                        .fontWeight(.medium)
                                                        .foregroundColor(.primary)
                                                        .lineLimit(1)
                                                    if let balance = mintBalances[mint.url.absoluteString] {
                                                        Text("\(balance) sats")
                                                            .font(.caption2)
                                                            .foregroundColor(.orange)
                                                    }
                                                }
                                            }
                                            .frame(width: 70)
                                            .contentShape(Rectangle())
                                            .onTapGesture {
                                                selectedMintURL = mint.url
                                            }
                                        }
                                    }
                                    .padding(.horizontal)
                                }
                            }
                        }
                        if isOfflineMode && selectedMintURL != nil && availableAmounts.isEmpty {
                            Text("This mint has no proofs that can be spent offline")
                                .foregroundStyle(.orange)
                                .font(.caption)
                                .padding(.horizontal)
                        }
                    }
                    // Memo Section
                    VStack(alignment: .leading, spacing: 12) {
                        Text("Memo")
                            .font(.headline)
                            .padding(.horizontal)
                        TextField("Note (optional)", text: $memo, axis: .vertical)
                            .lineLimit(2...4)
                            .padding(.horizontal)
                        Text("Add a note for the recipient")
                            .font(.caption)
                            .foregroundStyle(.secondary)
                            .padding(.horizontal)
                    }
                }
                .padding(.vertical)
                .padding(.bottom, 140) // Add space for the fixed button and keyboard
            }
            // Generate Token Button - Outside ScrollView
            VStack {
                Divider()
                Button(action: generateToken) {
                    if isSending {
                        HStack {
                            ProgressView()
                                .scaleEffect(0.8)
                            Text("Generating...")
                        }
                        .frame(maxWidth: .infinity)
                        .fontWeight(.semibold)
                        .padding()
                        .background(Color.orange.opacity(0.3))
                        .foregroundColor(.orange)
                        .cornerRadius(12)
                    } else {
                        Text("Generate Token")
                            .frame(maxWidth: .infinity)
                            .fontWeight(.semibold)
                            .padding()
                            .background(Color.orange)
                            .foregroundColor(.white)
                            .cornerRadius(12)
                    }
                }
                .disabled(isOfflineMode ?
                    (selectedAmount == nil || isSending || selectedMintURL == nil) :
                    (amount.isEmpty || amountInt <= 0 || amountInt > availableBalanceForMint || isSending || availableBalanceForMint == 0))
                .padding()
            }
            .background(Color(.systemBackground))
        }
        .navigationTitle("Send Ecash")
        .platformNavigationBarTitleDisplayMode(inline: true)
        #if os(iOS)
        .ignoresSafeArea(.keyboard, edges: [])
        #endif
        .toolbar {
            ToolbarItemGroup(placement: .keyboard) {
                Spacer()
                Button("Done") {
                    amountFieldFocused = false
                }
                .fontWeight(.semibold)
                .foregroundColor(.orange)
            }
            ToolbarItem(placement: .navigationBarTrailing) {
                Button("Generate Token") {
                    generateToken()
                }
                .foregroundColor(.orange)
                .disabled(isOfflineMode ?
                    (selectedAmount == nil || isSending || selectedMintURL == nil) :
                    (amount.isEmpty || amountInt <= 0 || amountInt > availableBalanceForMint || isSending || availableBalanceForMint == 0))
            }
        }
        .alert("Error", isPresented: $showError) {
            Button("OK") { }
        } message: {
            Text(errorMessage)
        }
        .sheet(isPresented: $showTokenView) {
            TokenConfirmationView(
                token: generatedToken,
                amount: isOfflineMode ? Int(selectedAmount ?? 0) : amountInt,
                memo: memo,
                mintURL: selectedMintURL,
                isOfflineMode: isOfflineMode,
                onDismiss: {
                    // Navigate back to wallet when done
                    dismiss()
                }
            )
        }
        .onAppear {
            loadMints()
            updateAvailableBalance()
        }
        .onChange(of: selectedMintURL) { _, _ in
            updateAvailableBalance()
            if isOfflineMode && selectedMintURL != nil {
                Task {
                    await loadAvailableAmounts()
                }
            }
        }
        .onChange(of: isOfflineMode) { _, newValue in
            if newValue && selectedMintURL != nil {
                Task {
                    await loadAvailableAmounts()
                }
            }
        }
    }
    private func generateToken() {
        if isOfflineMode {
            guard let selectedAmt = selectedAmount else { return }
            let amount = selectedAmt
            guard let proofs = proofCombinations[amount],
                  let mintURL = selectedMintURL else { return }
            guard !proofs.isEmpty else { return }
            isSending = true
            Task {
                do {
                    // Generate offline token
                    let (token, _) = try await walletManager.sendOffline(
                        proofs: proofs,
                        mint: mintURL,
                        memo: memo.isEmpty ? nil : memo
                    )
                    await MainActor.run {
                        generatedToken = token
                        showTokenView = true
                        isSending = false
                    }
                } catch {
                    await MainActor.run {
                        errorMessage = error.localizedDescription
                        showError = true
                        isSending = false
                    }
                }
            }
        } else {
            guard amountInt > 0 else { return }
            isSending = true
            Task {
                do {
                    // Show success immediately - the transaction appears as pending
                    await MainActor.run {
                        showTokenView = true
                    }
                    // Generate ecash token (this creates pending transaction immediately)
                    let tokenString = try await walletManager.send(
                        amount: Int64(amountInt),
                        memo: memo.isEmpty ? nil : memo,
                        fromMint: selectedMintURL
                    )
                    // Update with actual token
                    await MainActor.run {
                        generatedToken = tokenString
                        isSending = false
                    }
                } catch {
                    await MainActor.run {
                        errorMessage = error.localizedDescription
                        showError = true
                        isSending = false
                        showTokenView = false
                    }
                }
            }
        }
    }
    private func updateAvailableBalance() {
        Task {
            if let mintURL = selectedMintURL {
                let balance = await walletManager.wallet?.getBalance(mint: mintURL) ?? 0
                await MainActor.run {
                    availableBalance = Int(balance)
                }
            } else {
                // Get total balance
                do {
                    let totalBalance = try await walletManager.wallet?.getBalance() ?? 0
                    await MainActor.run {
                        availableBalance = Int(totalBalance)
                    }
                } catch {
                    print("Failed to get balance: \(error)")
                }
            }
        }
    }
    private func loadMints() {
        Task {
            guard let wallet = walletManager.wallet else { return }
            // Get balances for all mints (this gives us the full list like the pie chart)
            let balancesByMint = await wallet.getBalancesByMint()
            // Create mint info from all mints that have balances
            let loadedMints = balancesByMint.compactMap { (mintURL, _) -> MintInfo? in
                guard let url = URL(string: mintURL) else { return nil }
                return MintInfo(url: url, name: url.host ?? "Unknown Mint")
            }
            await MainActor.run {
                mints = loadedMints
                mintBalances = balancesByMint
                // Select the mint with the highest balance by default
                if let richestMint = balancesByMint.max(by: { $0.value < $1.value })?.key,
                   let richestURL = URL(string: richestMint) {
                    selectedMintURL = richestURL
                } else {
                    selectedMintURL = mints.first?.url
                }
            }
        }
    }
    private func formatAmount(_ amount: Int64) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.groupingSeparator = ","
        return formatter.string(from: NSNumber(value: amount)) ?? String(amount)
    }
    private func loadAvailableAmounts() async {
        guard let mintURL = selectedMintURL else { return }
        await MainActor.run {
            isLoadingOfflineAmounts = true
        }
        do {
            // Get real unspent proofs from wallet
            let proofsByMint = try await walletManager.getUnspentProofsByMint()
            guard let mintProofs = proofsByMint[mintURL] else {
                await MainActor.run {
                    availableProofs = []
                    availableAmounts = []
                    proofCombinations = [:]
                    pickerAmounts = []
                    isLoadingOfflineAmounts = false
                }
                return
            }
            print("Found \(mintProofs.count) proofs for mint \(mintURL)")
            // Sort proofs by amount (largest first)
            let sortedProofs = mintProofs.sorted(by: { $0.amount > $1.amount })
            // Use a smart approach that doesn't explode exponentially
            var amounts: [Int64] = []
            var combinations: [Int64: [CashuSwift.Proof]] = [:]
            // Calculate total available
            let totalAmount = sortedProofs.reduce(0) { $0 + Int64($1.amount) }
            print("Total available: \(totalAmount) sats from \(sortedProofs.count) proofs")
            // Always add the total amount option
            amounts.append(totalAmount)
            combinations[totalAmount] = sortedProofs
            // Add common denominations that we can definitely make
            for targetAmount in commonAmounts where targetAmount <= totalAmount {
                // Try to construct this amount using a greedy algorithm
                var remaining = targetAmount
                var usedProofs: [CashuSwift.Proof] = []
                let availableProofs = sortedProofs
                // First try to find exact matches
                if let exactMatch = availableProofs.first(where: { Int64($0.amount) == remaining }) {
                    usedProofs.append(exactMatch)
                    amounts.append(targetAmount)
                    combinations[targetAmount] = usedProofs
                    continue
                }
                // Otherwise use greedy approach - start with largest proofs
                for proof in availableProofs {
                    if Int64(proof.amount) <= remaining {
                        usedProofs.append(proof)
                        remaining -= Int64(proof.amount)
                        if remaining == 0 { break }
                    }
                }
                if remaining == 0 {
                    amounts.append(targetAmount)
                    combinations[targetAmount] = usedProofs
                }
            }
            // Add some intermediate amounts based on proof distribution
            // Group proofs by amount
            let proofsByAmount = Dictionary(grouping: sortedProofs, by: { Int64($0.amount) })
            // For each unique proof amount, offer multiples of it (if we have multiple)
            for (amount, proofs) in proofsByAmount where proofs.count > 1 {
                for multiplier in 1...min(5, proofs.count) {
                    let suggestedAmount = amount * Int64(multiplier)
                    if !amounts.contains(suggestedAmount) {
                        amounts.append(suggestedAmount)
                        combinations[suggestedAmount] = Array(proofs.prefix(multiplier))
                    }
                }
            }
            // Sort amounts
            let sortedAmounts = amounts.sorted().filter { $0 > 0 }
            await MainActor.run {
                availableProofs = sortedProofs
                availableAmounts = amounts
                proofCombinations = combinations
                pickerAmounts = sortedAmounts
                // Select middle amount by default
                if !sortedAmounts.isEmpty {
                    selectedPickerIndex = sortedAmounts.count / 2
                    selectedAmount = sortedAmounts[selectedPickerIndex]
                }
                isLoadingOfflineAmounts = false
            }
        } catch {
            await MainActor.run {
                errorMessage = error.localizedDescription
                showError = true
                isLoadingOfflineAmounts = false
            }
        }
    }
}
</file>

<file path="Sources/NutsackiOS/Views/Wallet/TokenConfirmationView.swift">
import SwiftUI
import CashuSwift
#if os(iOS)
import UIKit
#elseif os(macOS)
import AppKit
#endif
struct TokenConfirmationView: View {
    let token: String?
    let amount: Int
    let memo: String
    let mintURL: URL?
    let isOfflineMode: Bool
    let onDismiss: () -> Void
    @State private var copied = false
    @State private var showShareSheet = false
    @Environment(\.dismiss) private var dismiss
    @Environment(\.colorScheme) private var colorScheme
    var isGenerating: Bool {
        token == nil || token?.isEmpty == true
    }
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(spacing: 20) {
                    // QR Code with copy button inside
                    VStack(spacing: 16) {
                        ZStack {
                            RoundedRectangle(cornerRadius: 16)
                                .fill(Color(.secondarySystemBackground))
                                .overlay(
                                    RoundedRectangle(cornerRadius: 16)
                                        .stroke(Color(.separator), lineWidth: 1)
                                )
                                .shadow(
                                    color: Color(.label).opacity(colorScheme == .light ? 0.15 : 0),
                                    radius: colorScheme == .light ? 10 : 0,
                                    x: 0,
                                    y: colorScheme == .light ? 4 : 0
                                )
                                .if(colorScheme == .dark) { view in
                                    view.shadow(
                                        color: Color.white.opacity(0.1),
                                        radius: 8,
                                        x: 0,
                                        y: 0
                                    )
                                }
                            if let token = token, !token.isEmpty {
                                VStack(spacing: 20) {
                                    QRCodeView(content: token)
                                        .padding(24)
                                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                                    Button(action: copyToken) {
                                        HStack(spacing: 8) {
                                            Image(systemName: copied ? "checkmark.circle.fill" : "doc.on.doc")
                                                .font(.system(size: 16))
                                                .foregroundStyle(copied ? .green : .orange)
                                            Text(copied ? "Copied!" : "Copy token")
                                                .font(.system(size: 14, weight: .medium))
                                        }
                                        .foregroundStyle(copied ? .green : .primary)
                                        .padding(.horizontal, 16)
                                        .padding(.vertical, 12)
                                        .frame(minWidth: 44, minHeight: 44)
                                        .background(Color(.systemGray6))
                                        .clipShape(Capsule())
                                    }
                                    .buttonStyle(.plain)
                                    .padding(.bottom, 16)
                                }
                            } else {
                                // Loading state
                                ProgressView()
                                    .progressViewStyle(CircularProgressViewStyle())
                                    .scaleEffect(1.5)
                                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                            }
                        }
                        .frame(width: 320, height: 400)
                    }
                    .padding(.horizontal)
                    // Amount and checkmark
                    HStack(alignment: .center, spacing: 12) {
                        // Success checkmark
                        if !isGenerating {
                            ZStack {
                                Circle()
                                    .fill(Color.green.opacity(colorScheme == .dark ? 0.2 : 0.1))
                                    .frame(width: 32, height: 32)
                                Image(systemName: "checkmark.circle.fill")
                                    .font(.system(size: 20))
                                    .foregroundStyle(.green)
                            }
                        }
                        // Amount text
                        HStack(alignment: .lastTextBaseline, spacing: 4) {
                            Text(formatAmount(amount))
                                .font(.system(size: 36, weight: .semibold, design: .rounded))
                            Text("sats")
                                .font(.system(size: 18, weight: .regular, design: .rounded))
                                .foregroundStyle(.secondary)
                        }
                    }
                    .padding(.horizontal)
                    // Mint info below
                    if let mint = mintURL?.host {
                        Label(mint, systemImage: "building.columns.fill")
                            .font(.caption)
                            .foregroundStyle(.secondary.opacity(0.8))
                    }
                    // Status text
                    if isGenerating {
                        Text("Generating token...")
                            .font(.headline)
                            .foregroundStyle(.secondary)
                    }
                    // Memo if present
                    if !memo.isEmpty {
                        Text(memo)
                            .font(.body)
                            .foregroundStyle(.secondary)
                            .multilineTextAlignment(.center)
                            .padding(.horizontal)
                    }
                    // Action button
                    if let token = token, !token.isEmpty {
                        Button(action: shareToken) {
                            Label("Share", systemImage: "square.and.arrow.up")
                                .frame(maxWidth: .infinity)
                                .frame(height: 50)
                        }
                        .buttonStyle(.borderedProminent)
                        .controlSize(.large)
                        .tint(.orange)
                        .padding(.horizontal)
                        .padding(.top, 8)
                    }
                    Spacer(minLength: 40)
                }
            }
            .navigationTitle(isOfflineMode ? "Offline Token" : "Ecash Token")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .confirmationAction) {
                    Button("Done") {
                        onDismiss()
                        dismiss()
                    }
                    .fontWeight(.semibold)
                    .foregroundStyle(.orange)
                }
            }
        }
        #if os(iOS)
        .sheet(isPresented: $showShareSheet) {
            ShareSheet(items: [token ?? ""])
        }
        #endif
    }
    private func formatAmount(_ amount: Int) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.groupingSeparator = ","
        return formatter.string(from: NSNumber(value: amount)) ?? String(amount)
    }
    private func copyToken() {
        guard let token = token else { return }
        #if os(iOS)
        UIPasteboard.general.string = token
        #else
        NSPasteboard.general.clearContents()
        NSPasteboard.general.setString(token, forType: .string)
        #endif
        withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
            copied = true
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            withAnimation {
                copied = false
            }
        }
    }
    private func shareToken() {
        guard token != nil else { return }
        #if os(iOS)
        showShareSheet = true
        #else
        copyToken() // On macOS, just copy instead
        #endif
    }
}
#if os(iOS)
struct ShareSheet: UIViewControllerRepresentable {
    let items: [Any]
    func makeUIViewController(context: Context) -> UIActivityViewController {
        UIActivityViewController(activityItems: items, applicationActivities: nil)
    }
    func updateUIViewController(_ uiViewController: UIActivityViewController, context: Context) {}
}
#endif
extension View {
    @ViewBuilder
    func `if`<Content: View>(_ condition: Bool, transform: (Self) -> Content) -> some View {
        if condition {
            transform(self)
        } else {
            self
        }
    }
}
</file>

<file path="Sources/NutsackiOS/Views/Wallet/WalletEventsView.swift">
import SwiftUI
import NDKSwift
import CashuSwift
struct WalletEventsView: View {
    @EnvironmentObject private var nostrManager: NostrManager
    @Environment(WalletManager.self) private var walletManager
    @State private var walletEvents: [WalletEventInfo] = []
    @State private var isLoading = true
    @State private var error: Error?
    @State private var selectedEvent: WalletEventInfo?
    var body: some View {
        List {
            if isLoading {
                    Section {
                        HStack {
                            Spacer()
                            ProgressView()
                                .progressViewStyle(CircularProgressViewStyle())
                            Text("Loading wallet events...")
                                .foregroundStyle(.secondary)
                                .padding(.leading, 8)
                            Spacer()
                        }
                        .padding(.vertical, 20)
                    }
                } else if walletEvents.isEmpty {
                    Section {
                        VStack(spacing: 16) {
                            Image(systemName: "tray")
                                .font(.system(size: 48))
                                .foregroundColor(.gray)
                            Text("No wallet events found")
                                .font(.headline)
                                .foregroundStyle(.secondary)
                            Text("Token events will appear here as you use your wallet")
                                .font(.subheadline)
                                .foregroundStyle(.tertiary)
                                .multilineTextAlignment(.center)
                        }
                        .padding(.vertical, 40)
                        .frame(maxWidth: .infinity)
                    }
                } else {
                    Section {
                        ForEach(walletEvents) { eventInfo in
                            NavigationLink(value: eventInfo) {
                                WalletEventRow(eventInfo: eventInfo)
                            }
                        }
                    } header: {
                        HStack {
                            Text("Token Events")
                            Spacer()
                            Text("\(walletEvents.count) total")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                        }
                    } footer: {
                        Text("Shows all NIP-60 token events (kind 7375) published by this wallet. Deleted events are marked with a strikethrough.")
                    }
                }
                if let error = error {
                    Section {
                        VStack(alignment: .leading, spacing: 8) {
                            Label("Error loading events", systemImage: "exclamationmark.triangle")
                                .foregroundColor(.red)
                            Text(error.localizedDescription)
                                .font(.caption)
                                .foregroundStyle(.secondary)
                        }
                    }
                }
            }
            .navigationTitle("Wallet Events")
            #if os(iOS)
            .navigationBarTitleDisplayMode(.inline)
            #endif
            .navigationDestination(for: WalletEventInfo.self) { eventInfo in
                WalletEventDetailView(eventInfo: eventInfo)
            }
            .refreshable {
                await loadWalletEvents()
            }
            .onAppear {
                Task {
                    await loadWalletEvents()
                }
            }
    }
    private func loadWalletEvents() async {
        isLoading = true
        error = nil
        do {
            let events = try await walletManager.fetchAllWalletEvents()
            await MainActor.run {
                self.walletEvents = events
                self.isLoading = false
            }
        } catch {
            await MainActor.run {
                self.error = error
                self.isLoading = false
            }
        }
    }
}
struct WalletEventRow: View {
    let eventInfo: WalletEventInfo
    private var eventDate: Date {
        Date(timeIntervalSince1970: TimeInterval(eventInfo.event.createdAt))
    }
    private var totalAmount: Int {
        eventInfo.tokenData?.proofs.reduce(0) { $0 + Int($1.amount) } ?? 0
    }
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                // Status indicator
                Image(systemName: eventInfo.isDeleted ? "xmark.circle.fill" : "checkmark.circle.fill")
                    .foregroundColor(eventInfo.isDeleted ? .red : .green)
                    .font(.system(size: 20))
                VStack(alignment: .leading, spacing: 4) {
                    HStack {
                        Text(eventInfo.event.id.prefix(8) + "...")
                            .font(.system(.subheadline, design: .monospaced))
                            .strikethrough(eventInfo.isDeleted)
                        Spacer()
                        if eventInfo.tokenData != nil {
                            Text("\(totalAmount) sats")
                                .font(.subheadline)
                                .fontWeight(.medium)
                                .foregroundColor(.orange)
                        }
                    }
                    HStack {
                        if let tokenData = eventInfo.tokenData {
                            Label("\(tokenData.proofs.count) proofs", systemImage: "key.fill")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                            Text("•")
                                .foregroundStyle(.tertiary)
                            Text(URL(string: tokenData.mint)?.host ?? tokenData.mint)
                                .font(.caption)
                                .foregroundStyle(.secondary)
                                .lineLimit(1)
                        }
                        Spacer()
                        RelativeTimeView(date: eventDate)
                            .font(.caption)
                            .foregroundStyle(.tertiary)
                    }
                    if eventInfo.isDeleted {
                        HStack {
                            Image(systemName: "trash")
                                .font(.caption)
                            Text(eventInfo.deletionReason ?? "Deleted")
                                .font(.caption)
                                .foregroundStyle(.red)
                        }
                    }
                    if let delTags = eventInfo.tokenData?.del, !delTags.isEmpty {
                        HStack {
                            Image(systemName: "arrow.triangle.2.circlepath")
                                .font(.caption)
                            Text("Replaces \(delTags.count) event\(delTags.count == 1 ? "" : "s")")
                                .font(.caption)
                                .foregroundStyle(.blue)
                        }
                    }
                }
            }
        }
        .padding(.vertical, 4)
    }
}
</file>

<file path="Sources/NutsackiOS/Views/BlacklistedMintsView.swift">
//
//  BlacklistedMintsView.swift
//  NutsackiOS
//
import SwiftUI
import CashuSwift
#if !os(macOS)
// MARK: - Blacklisted Mints View
struct BlacklistedMintsView: View {
    @EnvironmentObject private var appState: AppState
    @Environment(WalletManager.self) private var walletManager
    @State private var showAddMintSheet = false
    @State private var availableMints: [String] = []
    var body: some View {
        List {
            if appState.blacklistedMints.isEmpty {
                ContentUnavailableView(
                    "No Blacklisted Mints",
                    systemImage: "xmark.shield",
                    description: Text("Blacklisted mints will not be used or shown in your wallet")
                )
            } else {
                Section {
                    ForEach(Array(appState.blacklistedMints).sorted(), id: \.self) { mintURL in
                        BlacklistedMintRowSettings(mintURL: mintURL) {
                            appState.unblacklistMint(mintURL)
                        }
                    }
                } header: {
                    Text("Blacklisted Mints")
                } footer: {
                    Text("These mints are blocked from being used in your wallet")
                }
            }
            Section {
                Button(action: { showAddMintSheet = true }) {
                    Label("Add to Blacklist", systemImage: "plus.circle")
                }
            }
        }
        .navigationTitle("Blacklisted Mints")
        #if os(iOS)
        .navigationBarTitleDisplayMode(.inline)
        #endif
        .sheet(isPresented: $showAddMintSheet) {
            AddToBlacklistSheet(
                currentMints: availableMints,
                blacklistedMints: appState.blacklistedMints
            ) { mintURL in
                appState.blacklistMint(mintURL)
            }
        }
        .task {
            await loadAvailableMints()
        }
    }
    private func loadAvailableMints() async {
        guard let wallet = walletManager.wallet else { return }
        let mintURLs = await wallet.mints.getMintURLs()
        await MainActor.run {
            availableMints = mintURLs
        }
    }
}
// MARK: - Blacklisted Mint Row for Settings
struct BlacklistedMintRowSettings: View {
    let mintURL: String
    let onUnblock: () -> Void
    var body: some View {
        HStack {
            Image(systemName: "xmark.shield.fill")
                .foregroundColor(.red)
                .frame(width: 40, height: 40)
            VStack(alignment: .leading, spacing: 4) {
                Text(URL(string: mintURL)?.host ?? "Unknown Mint")
                    .font(.headline)
                Text(mintURL)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .lineLimit(1)
            }
            Spacer()
            Button("Unblock") {
                onUnblock()
            }
            .buttonStyle(.bordered)
            .controlSize(.small)
        }
        .padding(.vertical, 4)
    }
}
// MARK: - Add to Blacklist Sheet
struct AddToBlacklistSheet: View {
    @Environment(\.dismiss) private var dismiss
    let currentMints: [String]
    let blacklistedMints: Set<String>
    let onBlock: (String) -> Void
    @State private var manualMintURL = ""
    var availableMintsToBlock: [String] {
        currentMints.filter { !blacklistedMints.contains($0) }
    }
    var body: some View {
        NavigationStack {
            List {
                if !availableMintsToBlock.isEmpty {
                    Section("Active Mints") {
                        ForEach(availableMintsToBlock, id: \.self) { mintURL in
                            HStack {
                                VStack(alignment: .leading, spacing: 4) {
                                    Text(URL(string: mintURL)?.host ?? "Unknown Mint")
                                        .font(.headline)
                                    Text(mintURL)
                                        .font(.caption)
                                        .foregroundColor(.secondary)
                                        .lineLimit(1)
                                }
                                Spacer()
                                Button("Block") {
                                    onBlock(mintURL)
                                    dismiss()
                                }
                                .buttonStyle(.bordered)
                                .tint(.red)
                                .controlSize(.small)
                            }
                            .padding(.vertical, 4)
                        }
                    }
                }
                Section {
                    TextField("https://mint.example.com", text: $manualMintURL)
                        .textContentType(.URL)
                        #if os(iOS)
                        .autocapitalization(.none)
                        #endif
                        .autocorrectionDisabled()
                    Button("Add to Blacklist") {
                        if !manualMintURL.isEmpty {
                            onBlock(manualMintURL)
                            dismiss()
                        }
                    }
                    .disabled(manualMintURL.isEmpty)
                } header: {
                    Text("Manual Entry")
                } footer: {
                    Text("Enter a mint URL to block it from being used")
                }
            }
            .navigationTitle("Add to Blacklist")
            #if os(iOS)
            .navigationBarTitleDisplayMode(.inline)
            #endif
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { dismiss() }
                }
            }
        }
    }
}
#endif
</file>

<file path="Sources/NutsackiOS/Views/DebugLoggingView.swift">
import SwiftUI
import NDKSwift
// MARK: - Debug Logging Settings
struct DebugLoggingView: View {
    @AppStorage("ndkLogLevel") private var logLevel: Int = NDKLogLevel.debug.rawValue
    @AppStorage("ndkLogNetworkTraffic") private var logNetworkTraffic = true
    @AppStorage("ndkPrettyPrintNetworkMessages") private var prettyPrintNetworkMessages = true
    @AppStorage("ndkEnabledCategories") private var enabledCategoriesData: Data = Data()
    @State private var enabledCategories: Set<NDKLogCategory> = Set(NDKLogCategory.allCases)
    @State private var hasChanges = false
    var body: some View {
        List {
            // Log Level Section
            Section {
                Picker("Log Level", selection: $logLevel) {
                    Text("Off").tag(NDKLogLevel.off.rawValue)
                    Text("Error").tag(NDKLogLevel.error.rawValue)
                    Text("Warning").tag(NDKLogLevel.warning.rawValue)
                    Text("Info").tag(NDKLogLevel.info.rawValue)
                    Text("Debug").tag(NDKLogLevel.debug.rawValue)
                    Text("Trace").tag(NDKLogLevel.trace.rawValue)
                }
                .onChange(of: logLevel) {
                    applyLogLevel()
                    hasChanges = true
                }
            } header: {
                Text("Log Level")
            } footer: {
                Text("Higher levels include all lower levels. Debug and Trace provide the most detail.")
            }
            // Network Logging Section
            Section {
                Toggle("Log Network Traffic", isOn: $logNetworkTraffic)
                    .onChange(of: logNetworkTraffic) {
                        Task { @MainActor in
                            NDKLogger.logNetworkTraffic = logNetworkTraffic
                            hasChanges = true
                        }
                    }
                Toggle("Pretty Print Messages", isOn: $prettyPrintNetworkMessages)
                    .disabled(!logNetworkTraffic)
                    .onChange(of: prettyPrintNetworkMessages) {
                        NDKLogger.prettyPrintNetworkMessages = prettyPrintNetworkMessages
                        hasChanges = true
                    }
            } header: {
                Text("Network Logging")
            } footer: {
                Text("Network logging shows raw Nostr messages sent and received from relays.")
            }
            // Categories Section
            Section {
                ForEach(sortedCategories, id: \.self) { category in
                    Toggle(isOn: Binding(
                        get: { enabledCategories.contains(category) },
                        set: { isEnabled in
                            if isEnabled {
                                enabledCategories.insert(category)
                            } else {
                                enabledCategories.remove(category)
                            }
                            applyCategories()
                            hasChanges = true
                        }
                    )) {
                        HStack {
                            Text(emojiForCategory(category))
                            Text(displayName(for: category))
                        }
                    }
                }
            } header: {
                HStack {
                    Text("Log Categories")
                    Spacer()
                    Button(action: toggleAllCategories) {
                        Text(enabledCategories.count == NDKLogCategory.allCases.count ? "None" : "All")
                            .font(.caption)
                    }
                }
            } footer: {
                Text("Enable or disable logging for specific parts of the system.")
            }
            // Quick Presets Section
            Section {
                Button(action: applyProductionPreset) {
                    Label("Production Settings", systemImage: "shippingbox")
                }
                Button(action: applyDebugPreset) {
                    Label("Debug Settings", systemImage: "ladybug")
                }
                Button(action: applyNetworkDebugPreset) {
                    Label("Network Debug", systemImage: "network")
                }
                Button(action: applyWalletDebugPreset) {
                    Label("Wallet Debug", systemImage: "creditcard")
                }
            } header: {
                Text("Quick Presets")
            } footer: {
                Text("Quickly apply common logging configurations.")
            }
            // Current Status
            if hasChanges {
                Section {
                    HStack {
                        Image(systemName: "checkmark.circle.fill")
                            .foregroundColor(.green)
                        Text("Settings applied and saved")
                            .foregroundStyle(.secondary)
                    }
                    .font(.caption)
                } footer: {
                    Text("Your logging preferences will persist across app restarts.")
                }
            }
        }
        .navigationTitle("Debug Logging")
        #if os(iOS)
        .navigationBarTitleDisplayMode(.inline)
        #endif
        .onAppear {
            loadSettings()
        }
    }
    // MARK: - Helper Methods
    private var sortedCategories: [NDKLogCategory] {
        NDKLogCategory.allCases.sorted { displayName(for: $0) < displayName(for: $1) }
    }
    private func displayName(for category: NDKLogCategory) -> String {
        switch category {
        case .network: return "Network"
        case .relay: return "Relay"
        case .subscription: return "Subscription"
        case .event: return "Event"
        case .cache: return "Cache"
        case .auth: return "Authentication"
        case .wallet: return "Wallet"
        case .general: return "General"
        case .connection: return "Connection"
        case .outbox: return "Outbox"
        case .signer: return "Signer"
        case .sync: return "Sync"
        case .performance: return "Performance"
        case .security: return "Security"
        case .database: return "Database"
        case .signature: return "Signature"
        }
    }
    private func emojiForCategory(_ category: NDKLogCategory) -> String {
        switch category {
        case .network: return "📡"
        case .relay: return "🔗"
        case .subscription: return "🔍"
        case .event: return "📝"
        case .cache: return "💾"
        case .auth: return "🔐"
        case .wallet: return "💰"
        case .general: return "ℹ️"
        case .connection: return "🔌"
        case .outbox: return "🎯"
        case .signer: return "✍️"
        case .sync: return "🔄"
        case .performance: return "⚡"
        case .security: return "🛡️"
        case .database: return "🗄️"
        case .signature: return "✅"
        }
    }
    private func loadSettings() {
        // Load log level
        NDKLogger.logLevel = NDKLogLevel(rawValue: logLevel) ?? .debug
        // Load network settings
        NDKLogger.logNetworkTraffic = logNetworkTraffic
        NDKLogger.prettyPrintNetworkMessages = prettyPrintNetworkMessages
        // Load enabled categories
        if let categories = JSONCoding.safeDecode(Set<String>.self, from: enabledCategoriesData) {
            enabledCategories = Set(categories.compactMap { rawValue in
                NDKLogCategory(rawValue: rawValue)
            })
        } else {
            enabledCategories = Set(NDKLogCategory.allCases)
        }
        NDKLogger.enabledCategories = enabledCategories
    }
    private func applyLogLevel() {
        NDKLogger.logLevel = NDKLogLevel(rawValue: logLevel) ?? .debug
    }
    private func applyCategories() {
        NDKLogger.enabledCategories = enabledCategories
        // Save to UserDefaults
        let categoryStrings = enabledCategories.map { $0.rawValue }
        if let data = try? JSONCoding.encode(categoryStrings) {
            enabledCategoriesData = data
        }
    }
    private func toggleAllCategories() {
        if enabledCategories.count == NDKLogCategory.allCases.count {
            // Disable all
            enabledCategories.removeAll()
        } else {
            // Enable all
            enabledCategories = Set(NDKLogCategory.allCases)
        }
        applyCategories()
        hasChanges = true
    }
    // MARK: - Presets
    private func applyProductionPreset() {
        logLevel = NDKLogLevel.warning.rawValue
        logNetworkTraffic = false
        prettyPrintNetworkMessages = false
        enabledCategories = [.general, .security]
        applyLogLevel()
        applyCategories()
        NDKLogger.logNetworkTraffic = logNetworkTraffic
        NDKLogger.prettyPrintNetworkMessages = prettyPrintNetworkMessages
        hasChanges = true
    }
    private func applyDebugPreset() {
        logLevel = NDKLogLevel.debug.rawValue
        logNetworkTraffic = true
        prettyPrintNetworkMessages = true
        enabledCategories = Set(NDKLogCategory.allCases)
        applyLogLevel()
        applyCategories()
        NDKLogger.logNetworkTraffic = logNetworkTraffic
        NDKLogger.prettyPrintNetworkMessages = prettyPrintNetworkMessages
        hasChanges = true
    }
    private func applyNetworkDebugPreset() {
        logLevel = NDKLogLevel.trace.rawValue
        logNetworkTraffic = true
        prettyPrintNetworkMessages = true
        enabledCategories = [.network, .relay, .connection, .performance]
        applyLogLevel()
        applyCategories()
        NDKLogger.logNetworkTraffic = logNetworkTraffic
        NDKLogger.prettyPrintNetworkMessages = prettyPrintNetworkMessages
        hasChanges = true
    }
    private func applyWalletDebugPreset() {
        logLevel = NDKLogLevel.trace.rawValue
        logNetworkTraffic = false
        prettyPrintNetworkMessages = false
        enabledCategories = [.wallet, .event, .cache, .sync]
        applyLogLevel()
        applyCategories()
        NDKLogger.logNetworkTraffic = logNetworkTraffic
        NDKLogger.prettyPrintNetworkMessages = prettyPrintNetworkMessages
        hasChanges = true
    }
}
</file>

<file path="Sources/NutsackiOS/Views/MintsView.swift">
import SwiftUI
import NDKSwift
import CashuSwift
struct MintsView: View {
    @Environment(WalletManager.self) private var walletManager
    @EnvironmentObject private var appState: AppState
    @State private var availableMints: [MintInfo] = []
    @State private var showAddMint = false
    @State private var showDiscoverMints = false
    @State private var isDiscovering = false
    @State private var isLoading = true
    @State private var discoveredMints: [DiscoveredMint] = []
    @State private var showError = false
    @State private var errorMessage = ""
    var body: some View {
        NavigationStack {
            List {
                if isLoading {
                    HStack {
                        Spacer()
                        ProgressView("Loading mints...")
                        Spacer()
                    }
                    .listRowBackground(Color.clear)
                } else if availableMints.isEmpty {
                    VStack(spacing: 16) {
                        Image(systemName: "building.columns")
                            .font(.system(size: 60))
                            .foregroundStyle(.secondary)
                        Text("No mints configured")
                            .font(.headline)
                            .foregroundStyle(.secondary)
                        Text("Add mints to start using ecash")
                            .font(.subheadline)
                            .foregroundStyle(.tertiary)
                    }
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 40)
                    .listRowBackground(Color.clear)
                } else {
                    // Active Mints header
                    Text("Active Mints")
                        .font(.headline)
                        .foregroundColor(.secondary)
                        .listRowBackground(Color.clear)
                        .listRowInsets(EdgeInsets(top: 20, leading: 16, bottom: 5, trailing: 16))
                    ForEach(availableMints, id: \.url.absoluteString) { mint in
                        NavigationLink(destination: MintInfoDetailView(mintInfo: mint)) {
                            MintRow(mintInfo: mint)
                        }
                    }
                }
                // Add mint buttons
                Section {
                    Button(action: { showAddMint = true }) {
                        Label("Add Mint", systemImage: "plus.circle")
                    }
                    Button(action: discoverMints) {
                        if isDiscovering {
                            HStack {
                                ProgressView()
                                    .scaleEffect(0.8)
                                Text("Discovering...")
                            }
                        } else {
                            Label("Discover Mints", systemImage: "magnifyingglass")
                        }
                    }
                    .disabled(isDiscovering)
                }
            }
            .navigationTitle("Mints")
            .platformNavigationBarTitleDisplayMode(inline: true)
            .sheet(isPresented: $showAddMint) {
                AddMintView()
            }
            .sheet(isPresented: $showDiscoverMints) {
                DiscoveredMintsView(discoveredMints: discoveredMints)
            }
            .alert("Notice", isPresented: $showError) {
                Button("OK") { }
            } message: {
                Text(errorMessage)
            }
            .task {
                await loadMints()
            }
            .refreshable {
                await loadMints()
            }
        }
    }
    private func loadMints() async {
        guard walletManager.wallet != nil else {
            await MainActor.run {
                isLoading = false
            }
            return
        }
        let mintURLs = await walletManager.getActiveMintsURLs()
        let mintInfos = mintURLs.compactMap { urlString -> MintInfo? in
            guard let url = URL(string: urlString) else { return nil }
            return MintInfo(url: url, name: url.host ?? "Unknown Mint")
        }
        await MainActor.run {
            availableMints = mintInfos
            isLoading = false
        }
    }
    private func discoverMints() {
        // Just show a message to use wallet settings
        Task {
            await MainActor.run {
                errorMessage = "To discover and add mints, please use Wallet Settings."
                showError = true
            }
        }
    }
}
struct MintRow: View {
    let mintInfo: MintInfo
    @Environment(WalletManager.self) private var walletManager
    @State private var balance: Int64 = 0
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text(mintInfo.url.host ?? mintInfo.url.absoluteString)
                        .font(.headline)
                    Text(mintInfo.url.absoluteString)
                        .font(.caption)
                        .foregroundStyle(.secondary)
                        .lineLimit(1)
                }
                Spacer()
                VStack(alignment: .trailing, spacing: 4) {
                    Text("\(balance)")
                        .font(.headline)
                        .foregroundStyle(.orange)
                    Text("sats")
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }
            }
        }
        .padding(.vertical, 4)
        .task {
            await updateBalance()
        }
    }
    private func updateBalance() async {
        guard let wallet = walletManager.wallet else { return }
        let mintBalance = await wallet.getBalance(mint: mintInfo.url)
        await MainActor.run {
            balance = mintBalance
        }
    }
}
struct MintInfoDetailView: View {
    let mintInfo: MintInfo
    @Environment(WalletManager.self) private var walletManager
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject private var appState: AppState
    @State private var showInfo = false
    @State private var isSyncing = false
    @State private var showRemoveAlert = false
    @State private var showError = false
    @State private var errorMessage = ""
    @State private var balance: Int64 = 0
    @State private var isBlacklisted = false
    @State private var showBlacklistAlert = false
    var body: some View {
        List {
            // Balance section
            Section {
                HStack {
                    Text("Balance")
                    Spacer()
                    Text("\(balance) sats")
                        .font(.headline)
                        .foregroundStyle(.orange)
                }
            }
            // Mint Information
            Section("Mint Information") {
                LabeledContent("URL", value: mintInfo.url.absoluteString)
                    .textSelection(.enabled)
            }
            // Actions
            Section("Actions") {
                Button(action: { showInfo = true }) {
                    Label("View Full Info", systemImage: "info.circle")
                }
                Button(action: syncMint) {
                    if isSyncing {
                        HStack {
                            ProgressView()
                                .scaleEffect(0.8)
                            Text("Syncing...")
                        }
                    } else {
                        Label("Sync Keyset", systemImage: "arrow.triangle.2.circlepath")
                    }
                }
                .disabled(isSyncing)
                Button(role: .destructive, action: { showBlacklistAlert = true }) {
                    Label("Blacklist Mint", systemImage: "xmark.shield")
                        .foregroundColor(.red)
                }
                Button(role: .destructive, action: { showRemoveAlert = true }) {
                    Label("Remove Mint", systemImage: "trash")
                        .foregroundColor(.red)
                }
            }
        }
        .navigationTitle(mintInfo.url.host ?? "Mint")
        .platformNavigationBarTitleDisplayMode(inline: true)
        .sheet(isPresented: $showInfo) {
            MintInfoView(mintInfo: mintInfo)
                .presentationDetents([.medium, .large])
        }
        .alert("Remove Mint?", isPresented: $showRemoveAlert) {
            Button("Cancel", role: .cancel) { }
            Button("Remove", role: .destructive) {
                performRemoveMint()
            }
        } message: {
            Text("This will remove the mint from your wallet. Any tokens from this mint will no longer be usable.")
        }
        .alert("Blacklist Mint?", isPresented: $showBlacklistAlert) {
            Button("Cancel", role: .cancel) { }
            Button("Blacklist", role: .destructive) {
                performBlacklistMint()
            }
        } message: {
            Text("This will block the mint from being used. The mint will be removed from your wallet and cannot be added again until unblocked.")
        }
        .alert("Error", isPresented: $showError) {
            Button("OK") { }
        } message: {
            Text(errorMessage)
        }
        .task {
            await updateBalance()
        }
    }
    private func updateBalance() async {
        guard let wallet = walletManager.wallet else { return }
        let mintBalance = await wallet.getBalance(mint: mintInfo.url)
        await MainActor.run {
            balance = mintBalance
        }
    }
    private func syncMint() {
        isSyncing = true
        Task {
            do {
                try await walletManager.wallet?.mints.refreshMintKeysets(url: mintInfo.url)
                await MainActor.run {
                    isSyncing = false
                }
            } catch {
                await MainActor.run {
                    errorMessage = "Failed to sync mint: \(error.localizedDescription)"
                    showError = true
                    isSyncing = false
                }
            }
        }
    }
    private func performRemoveMint() {
        // Just dismiss - user should manage mints in wallet settings
        dismiss()
        // Show a message that they need to use wallet settings
        Task {
            await MainActor.run {
                errorMessage = "To remove mints, please use Wallet Settings."
                showError = true
            }
        }
    }
    private func performBlacklistMint() {
        appState.blacklistMint(mintInfo.url.absoluteString)
        dismiss()
    }
}
// MARK: - Mint Info View
struct MintInfoView: View {
    let mintInfo: MintInfo
    @Environment(\.dismiss) private var dismiss
    var body: some View {
        NavigationStack {
            List {
                Section("Technical Details") {
                    LabeledContent("URL") {
                        Text(mintInfo.url.absoluteString)
                            .font(.caption)
                            .textSelection(.enabled)
                    }
                }
            }
            .navigationTitle("Mint Information")
            .platformNavigationBarTitleDisplayMode(inline: true)
            .toolbar {
                ToolbarItem(placement: .confirmationAction) {
                    Button("Done") { dismiss() }
                }
            }
        }
    }
}
// MARK: - Add Mint View
struct AddMintView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(WalletManager.self) private var walletManager
    @State private var mintURL = ""
    @State private var isAdding = false
    @State private var showError = false
    @State private var errorMessage = ""
    var body: some View {
        NavigationStack {
            Form {
                Section {
                    TextField("https://mint.example.com", text: $mintURL)
                        .textContentType(.URL)
                        #if os(iOS)
                        .autocapitalization(.none)
                        #endif
                        .autocorrectionDisabled()
                } header: {
                    Text("Mint URL")
                } footer: {
                    Text("Enter the URL of a Cashu mint")
                }
                Section {
                    Button(action: addMint) {
                        if isAdding {
                            ProgressView()
                                .frame(maxWidth: .infinity)
                        } else {
                            Text("Add Mint")
                                .frame(maxWidth: .infinity)
                        }
                    }
                    .disabled(mintURL.isEmpty || isAdding)
                }
            }
            .navigationTitle("Add Mint")
            .platformNavigationBarTitleDisplayMode(inline: true)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { dismiss() }
                }
            }
            .alert("Error", isPresented: $showError) {
                Button("OK") { }
            } message: {
                Text(errorMessage)
            }
        }
    }
    private func addMint() {
        // Just dismiss - user should manage mints in wallet settings
        dismiss()
        // Show a message that they need to use wallet settings
        Task {
            await MainActor.run {
                errorMessage = "To add mints, please use Wallet Settings."
                showError = true
            }
        }
    }
}
</file>

<file path="Sources/NutsackiOS/Views/RelayManagementView.swift">
import SwiftUI
import NDKSwift
import NDKSwiftUI
struct RelayManagementView: View {
    @EnvironmentObject var nostrManager: NostrManager
    var body: some View {
        NDKUIRelayManagementWrapper()
            .environment(\.ndk, nostrManager.ndk)
    }
}
</file>

<file path="Sources/NutsackiOS/DataSources/WalletDataSources.swift">
import Foundation
import NDKSwift
import SwiftUI
import Combine
// MARK: - Mint Discovery Data Source
/// Data source for discovering Cashu mints
@MainActor
public class MintDiscoveryDataSource: ObservableObject {
    @Published public private(set) var discoveredMints: [DiscoveredMint] = []
    private let ndk: NDK
    private let followedPubkeys: [String]
    private var streamTask: Task<Void, Never>?
    private var mintMap: [String: DiscoveredMint] = [:]
    public init(ndk: NDK, followedPubkeys: [String] = []) {
        self.ndk = ndk
        self.followedPubkeys = followedPubkeys
    }
    public func startStreaming() {
        // Cancel any existing task
        streamTask?.cancel()
        streamTask = Task { @MainActor in
            // Stream mint announcements
            let announcementTask = Task {
                let announcementDataSource = ndk.subscribe(
                    filter: NDKFilter(kinds: [EventKind.cashuMintAnnouncement]),
                    maxAge: 300,  // 5 minute cache for discovered mints
                    cachePolicy: .cacheWithNetwork
                )
                for await event in announcementDataSource.events {
                    if Task.isCancelled { break }
                    await processMintAnnouncement(event)
                }
            }
            // Stream mint recommendations
            let recommendationTask = Task {
                let recommendationDataSource = ndk.subscribe(
                    filter: NDKFilter(
                        authors: followedPubkeys.isEmpty ? nil : followedPubkeys,
                        kinds: [EventKind.mintAnnouncement],
                        tags: ["k": Set([String(EventKind.mintAnnouncement)])]
                    ),
                    maxAge: 300,  // 5 minute cache
                    cachePolicy: .cacheWithNetwork
                )
                for await event in recommendationDataSource.events {
                    if Task.isCancelled { break }
                    await processMintRecommendation(event)
                }
            }
            // Keep streaming until cancelled
            await announcementTask.value
            await recommendationTask.value
        }
    }
    public func stopStreaming() {
        streamTask?.cancel()
        streamTask = nil
    }
    @MainActor
    private func processMintAnnouncement(_ event: NDKEvent) {
        guard let mintUrl = event.tags.first(where: { $0.first == "u" })?.dropFirst().first else {
            return
        }
        // Parse the content as JSON according to NIP-87
        var mintName = ""
        var mintDescription: String?
        var mintIconURL: String?
        var mintWebsite: String?
        var mintContact: String?
        if !event.content.isEmpty,
           let contentData = event.content.data(using: .utf8),
           let json = try? JSONSerialization.jsonObject(with: contentData) as? [String: Any] {
            // Extract metadata from JSON content
            mintName = json["name"] as? String ?? ""
            mintDescription = json["description"] as? String
            mintIconURL = json["picture"] as? String ?? json["icon"] as? String
            mintWebsite = json["website"] as? String
            mintContact = json["contact"] as? String ?? json["email"] as? String
        }
        // Fallback to mint URL if no name provided
        if mintName.isEmpty {
            if let url = URL(string: mintUrl), let host = url.host {
                mintName = host
            } else {
                mintName = "Unknown Mint"
            }
        }
        let mint = DiscoveredMint(
            url: mintUrl,
            name: mintName,
            announcedBy: event.pubkey,
            announcementId: event.id,
            announcementCreatedAt: event.createdAt,
            recommendedBy: mintMap[mintUrl]?.recommendedBy ?? [],
            description: mintDescription,
            pubkey: event.tags.first(where: { $0.first == "p" })?.dropFirst().first,
            metadata: MintMetadata(
                name: mintName,
                description: mintDescription,
                iconURL: mintIconURL,
                website: mintWebsite,
                contact: mintContact
            )
        )
        mintMap[mintUrl] = mint
        updateDiscoveredMints()
    }
    @MainActor
    private func processMintRecommendation(_ event: NDKEvent) {
        guard let mintUrl = event.tags.first(where: { $0.first == "u" })?.dropFirst().first else {
            return
        }
        if var existingMint = mintMap[mintUrl] {
            if !existingMint.recommendedBy.contains(event.pubkey) {
                existingMint.recommendedBy.append(event.pubkey)
                mintMap[mintUrl] = existingMint
            }
        } else {
            let mint = DiscoveredMint(
                url: mintUrl,
                name: event.content.isEmpty ? "Unknown Mint" : event.content,
                announcedBy: nil,
                announcementId: nil,
                announcementCreatedAt: nil,
                recommendedBy: [event.pubkey],
                description: nil,
                pubkey: nil
            )
            mintMap[mintUrl] = mint
        }
        updateDiscoveredMints()
    }
    @MainActor
    private func updateDiscoveredMints() {
        discoveredMints = Array(mintMap.values).sorted { mint1, mint2 in
            // Sort by recommendation count first
            if mint1.recommendedBy.count != mint2.recommendedBy.count {
                return mint1.recommendedBy.count > mint2.recommendedBy.count
            }
            // Then by announcement date
            if let date1 = mint1.announcementCreatedAt,
               let date2 = mint2.announcementCreatedAt {
                return date1 > date2
            }
            return mint1.name < mint2.name
        }
    }
}
// MARK: - Supporting Types
public struct MintMetadata {
    public let name: String
    public let description: String?
    public let iconURL: String?
    public let website: String?
    public let contact: String?
    public init(
        name: String,
        description: String? = nil,
        iconURL: String? = nil,
        website: String? = nil,
        contact: String? = nil
    ) {
        self.name = name
        self.description = description
        self.iconURL = iconURL
        self.website = website
        self.contact = contact
    }
}
public struct DiscoveredMint: Identifiable {
    public let id: String
    public let url: String
    public let name: String
    public let announcedBy: String?
    public let announcementId: String?
    public let announcementCreatedAt: Timestamp?
    public var recommendedBy: [String]
    public let description: String?
    public let pubkey: String?
    public var mintInfo: NDKMintInfo?
    public let metadata: MintMetadata?
    public init(
        url: String,
        name: String,
        announcedBy: String? = nil,
        announcementId: String? = nil,
        announcementCreatedAt: Timestamp? = nil,
        recommendedBy: [String] = [],
        description: String? = nil,
        pubkey: String? = nil,
        mintInfo: NDKMintInfo? = nil,
        metadata: MintMetadata? = nil
    ) {
        self.id = url
        self.url = url
        self.name = name
        self.announcedBy = announcedBy
        self.announcementId = announcementId
        self.announcementCreatedAt = announcementCreatedAt
        self.recommendedBy = recommendedBy
        self.description = description
        self.pubkey = pubkey
        self.mintInfo = mintInfo
        self.metadata = metadata
    }
}
</file>

<file path="Sources/NutsackiOS/Models/NostrManager.swift">
import Foundation
import NDKSwift
import SwiftUI
@MainActor
class NostrManager: ObservableObject {
    @Published private(set) var isInitialized = false
    let ndk: NDK
    var cache: NDKCache? {
        return ndk.cache
    }
    private var authManager: NDKAuthManager?
    private var _profileManager: NDKProfileManager?
    var profileManager: NDKProfileManager? {
        return _profileManager
    }
    // MARK: - Configuration
    var defaultRelays: [String] {
        [RelayConstants.primal]
    }
    var appRelaysKey: String {
        "NutsackAppAddedRelays"
    }
    var clientTagConfig: NDKClientTagConfig? {
        NDKClientTagConfig(
            name: "Nutsack",
            relay: RelayConstants.primal,
            autoTag: true,
            excludedKinds: [
                EventKind.encryptedDirectMessage,
                EventKind.cashuSpendingHistory,
                EventKind.cashuToken
            ]
        )
    }
    var sessionConfiguration: NDKSessionConfiguration {
        NDKSessionConfiguration(
            dataRequirements: [.followList, .muteList],
            preloadStrategy: .progressive
        )
    }
    // MARK: - App-specific initialization
    init(from: String) {
        print("🏚️ [NostrManager] Initializing...", from)
        // Initialize NDK synchronously
        self.ndk = NDK(cache: nil)
        Task {
            await setupAsync()
        }
    }
    func setupAsync() async {
        // Initialize SQLite cache and update NDK's cache
        if let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first {
            let dbPath = documentsPath.appendingPathComponent("nutsack_cache.db").path
            if let sqliteCache = try? await NDKSQLiteCache(path: dbPath) {
                // Update NDK's cache to use SQLite
                ndk.cache = sqliteCache
            }
        }
        // Add default relays
        for relay in defaultRelays {
            await ndk.addRelay(relay)
        }
        // Connect to relays
        await ndk.connect()
        // Initialize auth manager
        authManager = NDKAuthManager(ndk: ndk)
        await authManager?.initialize()
        // Initialize profile manager
        _profileManager = NDKProfileManager(ndk: ndk)
        // If authenticated, restore session
        if let authManager = authManager, authManager.isAuthenticated, let signer = authManager.activeSigner {
            do {
                try await ndk.startSession(signer: signer, config: sessionConfiguration)
                print("🔍 [NostrManager] Restored session for user: \(authManager.activePubkey?.prefix(8) ?? "unknown")")
            } catch {
                print("🔍 [NostrManager] Failed to restore session: \(error)")
                // Don't clear the session here, let user manually logout if needed
            }
        } else {
            print("🔍 [NostrManager] No existing session to restore")
        }
        isInitialized = true
    }
    // MARK: - App-specific methods
    /// Create a new account with Nutsack-specific profile defaults
    public func createNutsackAccount(displayName: String, about: String? = nil, picture: String? = nil) async throws {
        print("🏚️ [NostrManager] createNutsackAccount() called with displayName: \(displayName)")
        // Generate new key
        let signer = try NDKPrivateKeySigner.generate()
        // Start NDK session directly
        if let authManager = authManager {
            print("Starting session")
            // Add session to auth manager for persistence
            _ = try await authManager.addSession(signer, requiresBiometric: false)
            try await ndk.startSession(signer: signer, config: sessionConfiguration)
            print("Finish session")
        }
        // Create profile metadata content directly
        var profileDict: [String: String] = [:]
        profileDict["name"] = displayName
        profileDict["about"] = about ?? "Nutsack wallet user"
        if let picture = picture {
            profileDict["picture"] = picture
        }
        let metadataData = try JSONSerialization.data(withJSONObject: profileDict, options: [])
        let metadataString = String(data: metadataData, encoding: .utf8) ?? "{}"
        let profileEvent = try await NDKEventBuilder(ndk: ndk)
            .kind(0)
            .content(metadataString)
            .build(signer: ndk.signer!)
        _ = try await ndk.publish(profileEvent)
        print("🏚️ [NostrManager] createNutsackAccount() completed successfully")
    }
    /// Import an existing account
    public func importAccount(signer: NDKPrivateKeySigner, displayName: String? = nil) async throws {
        print("🏚️ [NostrManager] importAccount() called")
        // Start NDK session
        if let authManager = authManager {
            print("Starting session for import")
            // Add session to auth manager for persistence
            _ = try await authManager.addSession(signer, requiresBiometric: false)
            try await ndk.startSession(signer: signer, config: sessionConfiguration)
            print("Finish session for import")
        }
        print("🏚️ [NostrManager] importAccount() completed successfully")
    }
    // MARK: - Negentropy Sync
    /// Perform startup sync after wallet has loaded
    func performStartupSync() async {
        guard ndk.signer != nil else {
            print("NostrManager - Cannot perform startup sync: User not authenticated")
            return
        }
        // Check if we already have connected relays
        let (connectedCount, totalCount) = await ndk.getRelayConnectionSummary()
        print("NostrManager - Initial relay status: \(connectedCount)/\(totalCount) connected")
        if connectedCount == 0 {
            print("NostrManager - No relays connected yet, waiting for first connection...")
            // Wait for the first relay to connect with timeout
            let timeoutTask = Task {
                try await Task.sleep(nanoseconds: 10_000_000_000) // 10 seconds
                throw CancellationError()
            }
            let observerTask = Task {
                let relayChanges = await ndk.relayChanges
                for await change in relayChanges {
                    if case .relayConnected = change {
                        return // Exit successfully
                    }
                }
            }
            do {
                _ = try await withThrowingTaskGroup(of: Void.self) { group in
                    group.addTask { try await timeoutTask.value }
                    group.addTask { await observerTask.value }
                    // Wait for first task to complete
                    try await group.next()
                    // Cancel remaining tasks
                    group.cancelAll()
                }
            } catch {
                print("NostrManager - Timeout waiting for relay connections, proceeding anyway")
            }
        }
        print("NostrManager - Starting negentropy sync...")
        await syncWalletEvents()
        print("NostrManager - Startup sync completed")
    }
    /// Sync user's wallet events (kind:7376 and 9321)
    private func syncWalletEvents() async {
        guard let signer = ndk.signer else { return }
        do {
            let userPubkey = try await signer.pubkey
            print("NostrManager - Syncing wallet events for user: \(userPubkey.prefix(8))...")
            // Create filter for user's wallet events
            let walletEventsFilter = NDKFilter(
                authors: [userPubkey],
                kinds: [
                    EventKind.cashuSpendingHistory, // 7376
                    EventKind.cashuToken            // 9321
                ]
            )
            // Sync with all connected relays (receive-only for wallet security)
            let results = try await ndk.syncWithAllRelays(filter: walletEventsFilter, direction: .receive)
            var totalDownloaded = 0
            var totalEfficiency = 0
            for (relay, result) in results {
                totalDownloaded += result.downloadedEvents.count
                totalEfficiency += result.efficiencyRatio
                print("NostrManager - Wallet events sync on \(relay): \(result.downloadedEvents.count) new events, \(result.efficiencyRatio)% efficient")
            }
            let avgEfficiency = results.isEmpty ? 0 : totalEfficiency / results.count
            print("NostrManager - Wallet events sync completed: \(totalDownloaded) new events, \(avgEfficiency)% avg efficiency")
        } catch {
            print("NostrManager - Error syncing wallet events: \(error)")
        }
    }
    var isAuthenticated: Bool {
        return authManager?.isAuthenticated ?? false
    }
    func logout() async {
        // Remove all sessions from auth manager (complete logout)
        if let authManager = authManager {
            for session in authManager.availableSessions {
                try? await authManager.removeSession(session)
            }
            authManager.logout()
        }
        // Clear signer from NDK
        ndk.signer = nil
    }
    // MARK: - Relay Management
    func addRelay(_ url: String) async {
        await ndk.addRelay(url)
        // Save to user defaults
        var savedRelays = UserDefaults.standard.stringArray(forKey: appRelaysKey) ?? []
        if !savedRelays.contains(url) {
            savedRelays.append(url)
            UserDefaults.standard.set(savedRelays, forKey: appRelaysKey)
        }
    }
    func removeRelay(_ url: String) async {
        await ndk.removeRelay(url)
        // Remove from user defaults
        var savedRelays = UserDefaults.standard.stringArray(forKey: appRelaysKey) ?? []
        savedRelays.removeAll { $0 == url }
        UserDefaults.standard.set(savedRelays, forKey: appRelaysKey)
    }
    var userAddedRelays: [String] {
        return UserDefaults.standard.stringArray(forKey: appRelaysKey) ?? []
    }
}
// Use NDKError from NDKSwift instead of creating custom errors
typealias NostrError = NDKError
</file>

<file path="Sources/NutsackiOS/Models/WalletManager.swift">
import Foundation
import NDKSwift
import CashuSwift
import Observation
@MainActor
@Observable
class WalletManager {
    var wallet: NIP60Wallet?
    var isLoading = false
    var error: Error?
    /// Current balance that updates in real-time from wallet events
    private(set) var currentBalance: Int64 = 0
    /// Task for observing wallet events
    private var walletEventsTask: Task<Void, Never>?
    /// Recent transactions that update in real-time
    private(set) var transactions: [Transaction] = []
    /// Whether wallet is properly configured with mints
    private(set) var isWalletConfigured: Bool = false
    /// Total pending amount (negative for outgoing, positive for incoming)
    private(set) var pendingAmount: Int64 = 0
    // Guard against duplicate initialization
    private var isInitializingWallet = false
    // Mint failure handling
    var pendingMintFailure: PendingMintOperation?
    var showMintFailureAlert = false
    private let nostrManager: NostrManager
    private let appState: AppState
    init(nostrManager: NostrManager, appState: AppState) {
        self.nostrManager = nostrManager
        self.appState = appState
    }
    // Clean up in a method that can be called when needed
    func cleanup() {
        walletEventsTask?.cancel()
        walletEventsTask = nil
    }
    // MARK: - Wallet Operations
    /// Load wallet for currently authenticated user
    func loadWalletForCurrentUser() async throws {
        print("📖 WalletManager.loadWalletForCurrentUser() called")
        guard nostrManager.isAuthenticated else {
            print("📖 Not authenticated, throwing error")
            throw WalletError.notAuthenticated
        }
        print("📖 Calling loadWallet()")
        try await loadWallet()
    }
    /// Ensure wallet exists (called automatically by loadWallet)
    private func ensureWalletExists() async throws {
        print("📘 WalletManager.ensureWalletExists() called")
        guard !isInitializingWallet else {
            print("📘 Already initializing wallet, skipping duplicate call")
            return
        }
        let ndk = nostrManager.ndk
        // Wait for signer to be available before creating wallet
        guard let signer = ndk.signer else {
            print("📘 Signer not available")
            throw WalletError.signerNotAvailable
        }
        isInitializingWallet = true
        defer { isInitializingWallet = false }
        let userPubkey = try await signer.pubkey
        print("📘 Got user pubkey: \(userPubkey.prefix(8))...")
        // Create NIP60Wallet instance with mint cache if available
        print("📘 Creating NIP60Wallet instance")
        let ndkWallet = try NIP60Wallet(ndk: ndk, cache: nostrManager.cache)
        // Set the wallet
        self.wallet = ndkWallet
        print("📘 Wallet set")
        // Start observing wallet events
        startObservingWalletEvents()
        // Register the wallet with the zap manager if available
        // TODO: Add zap manager support
        // Load wallet - this will fetch initial config and subscribe to wallet events
        print("📘 Calling ndkWallet.load()")
        try await ndkWallet.load()
        print("📘 ndkWallet.load() completed")
        // Get initial balance
        if let balance = try? await ndkWallet.getBalance() {
            self.currentBalance = balance
            print("💰 WalletManager: Initial balance: \(balance) sats")
        }
        // Get initial transactions
        await updateTransactions()
        print("📝 WalletManager: Loaded \(transactions.count) transactions, pending amount: \(pendingAmount) sats")
        print("📘 Wallet loaded with balance tracking")
        // Sync blacklisted mints from wallet to AppState
        await syncBlacklistedMints()
        // Check if wallet has mints configured
        let fetchedMintURLs = await ndkWallet.mints.getMintURLs()
        self.isWalletConfigured = !fetchedMintURLs.isEmpty
        print("📘 Current mint URLs: \(fetchedMintURLs)")
        if fetchedMintURLs.isEmpty {
            print("⚠️ WalletManager - No mints configured. User needs to add mints in wallet settings.")
            print("⚠️ WalletManager - Wallet exists but is not usable without mints")
        } else {
            print("✅ WalletManager - Wallet loaded with \(fetchedMintURLs.count) mints")
            // Log balance for debugging
            let balance = try? await ndkWallet.getBalance() ?? 0
            print("💰 WalletManager - Current balance: \(balance ?? 0) sats")
        }
    }
    /// Load wallet from NIP-60 events
    func loadWallet() async throws {
        print("📗 WalletManager.loadWallet() called")
        isLoading = true
        defer { isLoading = false }
        print("📗 Calling ensureWalletExists()")
        // Ensure wallet exists (creates if needed)
        try await ensureWalletExists()
        guard wallet != nil else {
            print("📗 No wallet after ensureWalletExists, throwing error")
            throw WalletError.noActiveWallet
        }
        print("📗 Wallet loaded successfully, triggering negentropy sync")
        // Trigger negentropy sync after wallet has loaded
        Task {
            await nostrManager.performStartupSync()
        }
    }
    /// Get relays for wallet configuration
    private func getRelaysForWallet() async -> [String] {
        print("🌐 getRelaysForWallet called")
        let ndk = nostrManager.ndk
        guard let signer = ndk.signer,
              let userPubkey = try? await signer.pubkey else {
            print("🌐 getRelaysForWallet - returning default relays (guard failed)")
            // Return default relays if we can't get user's relays
            return [
                "wss://relay.primal.net"
            ]
        }
        print("🌐 getRelaysForWallet - guard ok, pubkey: \(userPubkey.prefix(8))...")
        // Try to get user's relay list
        let user = ndk.getUser(userPubkey)
        do {
            // Use the method from NDKUser.swift that returns [NDKRelayInfo]
            print("🌐 getRelaysForWallet - fetching user relay list")
            let relayInfoList: [NDKRelayInfo] = try await user.fetchRelayList()
            let writeRelays = relayInfoList
                .filter { $0.write }
                .map { $0.url }
            print("🌐 getRelaysForWallet - found \(writeRelays.count) write relays")
            if !writeRelays.isEmpty {
                print("🌐 getRelaysForWallet - returning user's write relays: \(writeRelays)")
                return writeRelays
            }
        } catch {
            print("⚠️ WalletManager - Failed to fetch user's relay list: \(error)")
        }
        print("🌐 getRelaysForWallet - falling back to default relays")
        // Fallback to default relays
        return [
            "wss://relay.primal.net"
        ]
    }
    // MARK: - Mint Operations
    // MARK: - Offline Operations
    /// Get all unspent proofs grouped by mint for offline sending
    func getUnspentProofsByMint() async throws -> [URL: [CashuSwift.Proof]] {
        guard let wallet = wallet else {
            throw WalletError.noActiveWallet
        }
        let proofsByMint = await wallet.getUnspentProofs()
        // Convert string mint URLs to URL objects
        var result: [URL: [CashuSwift.Proof]] = [:]
        for (mintString, proofs) in proofsByMint {
            if let mintURL = URL(string: mintString) {
                result[mintURL] = proofs
            }
        }
        return result
    }
    /// Send offline using specific proofs
    func sendOffline(
        proofs: [CashuSwift.Proof],
        mint: URL,
        memo: String?
    ) async throws -> (token: String, transactionId: UUID) {
        guard let wallet = wallet else {
            throw WalletError.noActiveWallet
        }
        // Create the token without P2PK locking
        let token = try await wallet.createTokenFromProofs(
            proofs: proofs,
            mint: mint,
            memo: memo
        )
        // Transaction will be tracked by wallet's transaction history
        let transactionId = UUID()
        return (token: token, transactionId: transactionId)
    }
    // MARK: - Send Operations
    /// Send ecash tokens
    func send(amount: Int64, memo: String?, fromMint: URL?) async throws -> String {
        guard let wallet = wallet else {
            throw WalletError.noActiveWallet
        }
        // Create pending transaction immediately in wallet's transaction history
        let pendingTx = await wallet.transactionHistory.createPendingTransaction(
            type: .send,
            amount: amount,
            direction: .outgoing,
            memo: memo ?? "Sent ecash",
            mint: fromMint?.absoluteString
        )
        print("Created pending transaction: \(pendingTx.id) for send operation")
        // Transaction will be added when wallet event is processed
        do {
            // Select mint if not specified
            let selectedMintURL: URL
            if let fromMint = fromMint {
                selectedMintURL = fromMint
            } else {
                // Auto-select mint with sufficient balance
                let mintURLs = await wallet.mints.getMintURLs()
                let mints = mintURLs.compactMap { URL(string: $0) }
                var selectedMint: URL?
                for mint in mints {
                    let balance = await wallet.getBalance(mint: mint)
                    if balance >= amount {
                        selectedMint = mint
                        break
                    }
                }
                guard let selected = selectedMint else {
                    throw WalletError.insufficientBalance
                }
                selectedMintURL = selected
            }
            // Generate P2PK pubkey for locking
            let p2pkPubkey = try await wallet.getP2PKPubkey()
            // Send tokens (creates P2PK locked proofs)
            let (proofs, _) = try await wallet.send(
                amount: amount,
                to: p2pkPubkey,
                mint: selectedMintURL
            )
            // Create token from proofs
            let token = CashuSwift.Token(
                proofs: [selectedMintURL.absoluteString: proofs],
                unit: "sat",
                memo: memo
            )
            // Encode token
            // Note: JSONCoding.encoder already has sorted keys formatting
            let tokenData = try JSONCoding.encoder.encode(token)
            guard String(data: tokenData, encoding: .utf8) != nil else {
                throw WalletError.encodingError
            }
            // Create base64url encoded token
            let base64Token = tokenData.base64EncodedString()
                .replacingOccurrences(of: "+", with: "-")
                .replacingOccurrences(of: "/", with: "_")
                .replacingOccurrences(of: "=", with: "")
            let tokenString = "cashuA\(base64Token)"
            // Update pending transaction status to completed
            await wallet.transactionHistory.updateTransactionStatus(id: pendingTx.id, status: .completed)
            // Create history event for sending ecash
            do {
                let ndk = nostrManager.ndk
                guard let signer = ndk.signer else {
                    print("Failed to create history event: signer not available")
                    return tokenString
                }
                try await wallet.eventManager.createSpendingHistoryEvent(
                    direction: .out,
                    amount: amount,
                    memo: memo ?? "Sent ecash",
                    signer: signer,
                    relays: wallet.resolvedWalletRelays
                )
            } catch {
                print("Failed to create history event for send: \(error)")
                // Don't throw here, the send operation succeeded even if history event failed
            }
            return tokenString
        } catch {
            // Update pending transaction status to failed
            await wallet.transactionHistory.updateTransactionStatus(id: pendingTx.id, status: .failed)
            throw error
        }
    }
    // MARK: - Receive Operations
    /// Receive ecash tokens
    func receive(tokenString: String) async throws -> Int64 {
        guard let wallet = wallet else {
            throw WalletError.noActiveWallet
        }
        // Parse token string to get amount first
        guard tokenString.hasPrefix("cashuA") else {
            throw WalletError.invalidToken
        }
        let base64Part = String(tokenString.dropFirst(6))
        // Convert base64url to base64
        var base64 = base64Part
            .replacingOccurrences(of: "-", with: "+")
            .replacingOccurrences(of: "_", with: "/")
        // Add padding if needed
        while base64.count % 4 != 0 {
            base64.append("=")
        }
        guard let tokenData = Data(base64Encoded: base64),
              let token = try? JSONCoding.decoder.decode(CashuSwift.Token.self, from: tokenData) else {
            throw WalletError.invalidToken
        }
        // Calculate total amount from token
        let totalAmount = token.proofsByMint.values.reduce(0) { sum, proofs in
            sum + proofs.reduce(0) { $0 + Int64($1.amount) }
        }
        // Create pending transaction immediately in wallet's transaction history
        let pendingTx = await wallet.transactionHistory.createPendingTransaction(
            type: .receive,
            amount: totalAmount,
            direction: .incoming,
            memo: token.memo ?? "Received ecash"
        )
        print("Created pending transaction: \(pendingTx.id) for receive operation")
        do {
            var totalReceived: Int64 = 0
            // Process proofs from each mint
            for (_, proofs) in token.proofsByMint {
                // Receive the proofs - wallet can handle proofs from any mint
                try await wallet.receive(proofs: proofs)
                // Calculate total
                totalReceived += proofs.reduce(0) { $0 + Int64($1.amount) }
            }
            // Update pending transaction status to completed
            await wallet.transactionHistory.updateTransactionStatus(id: pendingTx.id, status: .completed)
            // Create history event for receiving ecash
            if totalReceived > 0 {
                do {
                    let ndk = nostrManager.ndk
                    guard let signer = ndk.signer else {
                        print("Failed to create history event: signer not available")
                        return totalReceived
                    }
                    try await wallet.eventManager.createSpendingHistoryEvent(
                        direction: .in,
                        amount: totalReceived,
                        memo: token.memo ?? "Received ecash",
                        signer: signer,
                        relays: wallet.resolvedWalletRelays
                    )
                } catch {
                    print("Failed to create history event for receive: \(error)")
                    // Don't throw here, the receive operation succeeded even if history event failed
                }
            }
            return totalReceived
        } catch {
            // Update pending transaction status to failed
            await wallet.transactionHistory.updateTransactionStatus(id: pendingTx.id, status: .failed)
            throw error
        }
    }
    // MARK: - Lightning Operations
    /// Pay a Lightning invoice
    func payLightning(invoice: String, amount: Int64) async throws -> String {
        guard let wallet = wallet else {
            throw WalletError.noActiveWallet
        }
        // Create pending transaction immediately in wallet's transaction history
        let lightningData = LightningData(invoice: invoice)
        let pendingTx = await wallet.transactionHistory.createPendingTransaction(
            type: .melt,
            amount: amount,
            direction: .outgoing,
            memo: "Lightning payment",
            lookupKeys: TransactionLookupKeys(paymentHash: nil), // Could extract from invoice
            lightningData: lightningData
        )
        print("Created pending transaction: \(pendingTx.id) for lightning payment")
        do {
            let (preimage, feePaid) = try await wallet.payLightning(
                invoice: invoice,
                amount: amount
            )
            print("Paid Lightning invoice: \(amount) sats, fee: \(feePaid ?? 0) sats")
            // Update pending transaction status to completed
            await wallet.transactionHistory.updateTransactionStatus(id: pendingTx.id, status: .completed)
            return preimage
        } catch {
            // Update pending transaction status to failed
            await wallet.transactionHistory.updateTransactionStatus(id: pendingTx.id, status: .failed)
            throw error
        }
    }
    // MARK: - Nutzap Operations
    /// Send a nutzap
    func sendNutzap(
        to recipient: String,
        amount: Int64,
        comment: String?,
        acceptedMints: [URL]
    ) async throws {
        print("🚀 WalletManager.sendNutzap called - recipient: \(recipient), amount: \(amount), acceptedMints: \(acceptedMints)")
        guard let wallet = wallet else {
            print("❌ No wallet!")
            throw WalletError.noActiveWallet
        }
        // Create pending transaction immediately in wallet's transaction history
        let nutzapData = NutzapData(
            recipientPubkey: recipient,
            nutzapEventId: "pending-\(UUID().uuidString)", // Temporary ID until nutzap event is created
            comment: comment
        )
        let pendingTx = await wallet.transactionHistory.createPendingTransaction(
            type: .nutzapSent,
            amount: amount,
            direction: .outgoing,
            memo: comment ?? "Zap sent",
            lookupKeys: TransactionLookupKeys(recipientPubkey: recipient),
            nutzapData: nutzapData
        )
        print("Created pending transaction: \(pendingTx.id) for nutzap")
        do {
            // Create nutzap request
            let request = NutzapPaymentRequest(
                amountSats: amount,
                recipientPubkey: recipient,
                recipientP2PK: "", // Empty P2PK for now, will be set by wallet
                acceptedMints: acceptedMints,
                comment: comment
            )
            print("💳 Created NutzapPaymentRequest, calling wallet.pay()")
            // Send nutzap
            _ = try await wallet.pay(request)
            print("✅ Nutzap completed successfully!")
            // Update pending transaction status to completed
            await wallet.transactionHistory.updateTransactionStatus(id: pendingTx.id, status: .completed)
        } catch {
            // Update pending transaction status to failed
            await wallet.transactionHistory.updateTransactionStatus(id: pendingTx.id, status: .failed)
            throw error
        }
    }
    // MARK: - Mint Management
    /// Get the blacklisted mints from the wallet (source of truth)
    func getBlacklistedMints() async -> Set<String> {
        guard let wallet = wallet else { return [] }
        return await wallet.getBlacklistedMints()
    }
    /// Sync blacklisted mints from wallet to AppState
    func syncBlacklistedMints() async {
        let blacklistedMints = await getBlacklistedMints()
        // Update AppState with the wallet's blacklist (source of truth)
        await MainActor.run {
            appState.blacklistedMints = blacklistedMints
        }
    }
    /// Get mint URLs excluding blacklisted ones
    func getActiveMintsURLs() async -> [String] {
        guard let wallet = wallet else { return [] }
        let allMints = await wallet.mints.getMintURLs()
        let blacklistedMints = await wallet.getBlacklistedMints()
        return allMints.filter { !blacklistedMints.contains($0) }
    }
    /// Check if mint operations should be allowed for a URL
    func shouldAllowMintOperations(for mintURL: String) async -> Bool {
        let blacklistedMints = await getBlacklistedMints()
        return !blacklistedMints.contains(mintURL)
    }
    // MARK: - Cross-mint Operations
    /// Transfer between mints
    func transferBetweenMints(
        amount: Int64,
        fromMint: URL,
        toMint: URL
    ) async throws -> TransferResult {
        guard let wallet = wallet else {
            throw WalletError.noActiveWallet
        }
        do {
            return try await wallet.transferBetweenMints(
                amount: amount,
                fromMint: fromMint,
                toMint: toMint
            )
        } catch {
            // Check if this is a mint failure error that needs user intervention
            handleMintFailureError(error)
            throw error
        }
    }
    /// Estimate transfer fees
    func estimateTransferFees(
        amount: Int64,
        fromMint: URL,
        toMint: URL
    ) async throws -> (lightningFee: Int64, inputFee: Int64, totalFee: Int64) {
        guard wallet != nil else {
            throw WalletError.noActiveWallet
        }
        // Estimate fees for cross-mint transfer
        // Lightning fee is typically 0.5% + 1 sat
        let lightningFee = max(1, Int64(Double(amount) * 0.005) + 1)
        // Input fee is typically 0.2%
        let inputFee = max(1, Int64(Double(amount) * 0.002))
        let totalFee = lightningFee + inputFee
        return (lightningFee: lightningFee, inputFee: inputFee, totalFee: totalFee)
    }
    // MARK: - State Management
    /// Check and reconcile proof states
    func reconcileProofStates() async throws {
        guard let wallet = wallet else {
            throw WalletError.noActiveWallet
        }
        try await wallet.checkAndReconcileProofStates()
    }
    // MARK: - Wallet Events Management
    /// Fetch all wallet events (kind 7375) and their deletion status
    func fetchAllWalletEvents() async throws -> [WalletEventInfo] {
        let ndk = nostrManager.ndk
        guard let signer = ndk.signer else {
            throw WalletError.signerNotAvailable
        }
        let userPubkey = try await signer.pubkey
        // Fetch all token events (kind 7375) from this user
        let tokenFilter = NDKFilter(
            authors: [userPubkey],
            kinds: [EventKind.cashuToken]
        )
        // Fetch deletion events that target token events
        let deletionFilter = NDKFilter(
            authors: [userPubkey],
            kinds: [EventKind.deletion],
            tags: ["k": Set([String(EventKind.cashuToken)])]
        )
        // Fetch events from cache or relays using data sources
        let tokenDataSource = ndk.subscribe(filter: tokenFilter, maxAge: 3600)
        let deletionDataSource = ndk.subscribe(filter: deletionFilter, maxAge: 3600)
        // Collect events
        var tokenEvents: [NDKEvent] = []
        var deletionEvents: [NDKEvent] = []
        // Use a timeout for collecting events
        let fetchTask = Task {
            await withTaskGroup(of: Void.self) { group in
                group.addTask {
                    for await event in tokenDataSource.events {
                        tokenEvents.append(event)
                    }
                }
                group.addTask {
                    for await event in deletionDataSource.events {
                        deletionEvents.append(event)
                    }
                }
                // Wait for a reasonable timeout
                try? await Task.sleep(nanoseconds: 3_000_000_000) // 3 seconds
                group.cancelAll()
            }
        }
        await fetchTask.value
        // Build a set of deleted event IDs from deletion events
        var deletedEventIds = Set<String>()
        var deletionEventMap: [String: NDKEvent] = [:]
        for deletionEvent in deletionEvents {
            // Extract deleted event IDs from "e" tags
            for tag in deletionEvent.tags {
                if tag.count >= 2 && tag[0] == "e" {
                    deletedEventIds.insert(tag[1])
                    deletionEventMap[tag[1]] = deletionEvent
                }
            }
        }
        // Also check for del tags in newer events
        var eventsByDel: [String: Set<String>] = [:]
        for event in tokenEvents {
            // Try to decrypt and parse token data
            if let tokenData = try? await decryptTokenEvent(event, signer: signer) {
                if let delTags = tokenData.del {
                    for deletedId in delTags {
                        deletedEventIds.insert(deletedId)
                        if eventsByDel[deletedId] == nil {
                            eventsByDel[deletedId] = Set<String>()
                        }
                        eventsByDel[deletedId]?.insert(event.id)
                    }
                }
            }
        }
        // Process each token event
        var walletEvents: [WalletEventInfo] = []
        for event in tokenEvents {
            // Try to decrypt token data
            let tokenData = try? await decryptTokenEvent(event, signer: signer)
            // Check if this event is deleted
            let isDeleted = deletedEventIds.contains(event.id)
            // Determine deletion reason
            var deletionReason: String?
            var deletionEvent: NDKEvent?
            if isDeleted {
                if let delEvent = deletionEventMap[event.id] {
                    deletionReason = "Deleted via NIP-09"
                    deletionEvent = delEvent
                } else if let replacingEventIds = eventsByDel[event.id] {
                    deletionReason = "Replaced by event(s): \(replacingEventIds.joined(separator: ", ").prefix(32))..."
                }
            }
            let eventInfo = WalletEventInfo(
                event: event,
                tokenData: tokenData,
                isDeleted: isDeleted,
                deletionReason: deletionReason,
                deletionEvent: deletionEvent
            )
            walletEvents.append(eventInfo)
        }
        // Sort by creation date (newest first)
        walletEvents.sort { $0.event.createdAt > $1.event.createdAt }
        return walletEvents
    }
    /// Decrypt a token event to get its content
    private func decryptTokenEvent(_ event: NDKEvent, signer: NDKSigner) async throws -> NIP60TokenEvent? {
        let sender = NDKUser(pubkey: event.pubkey)
        let decryptedContent = try await signer.decrypt(
            sender: sender,
            value: event.content,
            scheme: .nip44
        )
        guard let data = decryptedContent.data(using: .utf8) else {
            return nil
        }
        return try JSONCoding.decoder.decode(NIP60TokenEvent.self, from: data)
    }
    /// Check proof states for specific proofs
    func checkProofStates(for proofs: [CashuSwift.Proof], mint mintURL: String) async throws -> [String: CashuSwift.Proof.ProofState] {
        guard let wallet = wallet else {
            throw WalletError.noActiveWallet
        }
        guard URL(string: mintURL) != nil else {
            throw WalletError.invalidMintURL
        }
        // Get mint instance
        let mints = await wallet.mints.getAllMints()
        guard let mint = mints[mintURL] else {
            throw WalletError.mintNotFound
        }
        // Check proof states
        let states = try await CashuSwift.check(proofs, mint: mint)
        // Build result dictionary mapping C value to state
        var result: [String: CashuSwift.Proof.ProofState] = [:]
        for (index, proof) in proofs.enumerated() {
            if index < states.count {
                result[proof.C] = states[index]
            }
        }
        return result
    }
    /// Get wallet's P2PK pubkey
    func getP2PKPubkey() async throws -> String {
        guard let wallet = wallet else {
            throw WalletError.noActiveWallet
        }
        return try await wallet.getP2PKPubkey()
    }
    // MARK: - Mint Management
    /// Get mints info as MintInfo array
    // MARK: - Session Management
    /// Clear all wallet data and cancel active subscriptions (called during logout)
    func clearWalletData() {
        // Clear wallet state
        wallet = nil
        print("WalletManager - Cleared all wallet data and cancelled subscriptions")
    }
    // MARK: - Health Monitoring
    // wallet property already exposed at the top
    // MARK: - Private Methods
    /// Start observing wallet events for real-time updates
    private func startObservingWalletEvents() {
        // Cancel any existing observation
        walletEventsTask?.cancel()
        guard let wallet = wallet else { return }
        walletEventsTask = Task {
            print("👀 WalletManager: Starting wallet event observation")
            for await event in await wallet.events {
                if Task.isCancelled { break }
                switch event.type {
                case .balanceChanged(let newBalance):
                    print("💰 WalletManager: Balance changed to \(newBalance) sats")
                    self.currentBalance = newBalance
                case .mintsAdded(let mints):
                    print("🏦 WalletManager: Mints added: \(mints)")
                    // Update wallet configuration status
                    let allMints = await wallet.mints.getMintURLs()
                    self.isWalletConfigured = !allMints.isEmpty
                    // Balance might change when new mints are added
                    if let balance = try? await wallet.getBalance() {
                        self.currentBalance = balance
                    }
                case .mintsRemoved(let mints):
                    print("🏦 WalletManager: Mints removed: \(mints)")
                    // Update wallet configuration status
                    let allMints = await wallet.mints.getMintURLs()
                    self.isWalletConfigured = !allMints.isEmpty
                    // Balance might change when mints are removed
                    if let balance = try? await wallet.getBalance() {
                        self.currentBalance = balance
                    }
                case .transactionAdded(let transaction):
                    print("📝 WalletManager: Transaction added")
                    // Refresh transactions list
                    await updateTransactions()
                case .transactionUpdated(let transaction):
                    print("📝 WalletManager: Transaction updated")
                    // Refresh transactions list
                    await updateTransactions()
                case .configurationUpdated(let mints):
                    print("⚙️ WalletManager: Configuration updated with \(mints.count) mints")
                    self.isWalletConfigured = !mints.isEmpty
                    // Sync blacklisted mints from wallet to AppState
                    await syncBlacklistedMints()
                default:
                    // Ignore other events for now
                    break
                }
            }
            print("👀 WalletManager: Stopped observing wallet events")
        }
    }
    /// Stop observing wallet events
    private func stopObservingWalletEvents() {
        walletEventsTask?.cancel()
        walletEventsTask = nil
    }
    /// Update transactions and pending amount from wallet
    private func updateTransactions() async {
        guard let wallet = wallet else { return }
        let walletTransactions = await wallet.getRecentTransactions(limit: 50)
        self.transactions = walletTransactions.map { $0.toTransaction() }
        // Calculate pending amount
        self.pendingAmount = walletTransactions
            .filter { $0.status == .pending || $0.status == .processing }
            .reduce(0) { sum, transaction in
                switch transaction.direction {
                case .incoming:
                    return sum + transaction.amount
                case .outgoing:
                    return sum - transaction.amount
                case .neutral:
                    return sum
                }
            }
    }
    // MARK: - Mint Failure Handling
    /// Handle mint failure errors from payment operations
    func handleMintFailureError(_ error: Error) {
        // Check if this is a mint failure that requires user intervention
        if case MintFailureError.requiresUserIntervention(let operation, _, _, _, _) = error {
            self.pendingMintFailure = operation
            self.showMintFailureAlert = true
        } else if case DepositMintError.requiresUserIntervention(let operation, _) = error {
            self.pendingMintFailure = operation
            self.showMintFailureAlert = true
        }
    }
    /// Retry the pending mint operation
    func retryPendingMintOperation() async throws {
        guard let wallet = wallet,
              let operation = pendingMintFailure else {
            throw WalletError.noActiveWallet
        }
        // Get the mint
        guard let mint = await wallet.mints.getMint(url: operation.mintURL) else {
            throw WalletError.mintNotFound
        }
        // Use the retry handler
        let retryHandler = MintRetryHandler()
        let proofs = try await retryHandler.retryPendingMint(operation, mint: mint)
        if !proofs.isEmpty {
            print("✅ Successfully recovered \(proofs.count) proofs after user retry")
            // Update wallet state with recovered proofs
            for proof in proofs {
                await wallet.proofStateManager.addProof(proof, mint: operation.mintURL)
            }
            let stateChange = WalletStateChange(
                store: proofs,
                destroy: [],
                mint: operation.mintURL,
                memo: "Recovered tokens from failed mint"
            )
            _ = try await wallet.update(stateChange: stateChange)
            // Clear the pending failure
            self.pendingMintFailure = nil
        }
    }
    /// Blacklist the mint from the pending operation
    func blacklistPendingMint() async throws {
        guard let wallet = wallet,
              let operation = pendingMintFailure else {
            throw WalletError.noActiveWallet
        }
        try await wallet.blacklistMint(operation.mintURL)
        // Sync blacklisted mints from wallet to AppState
        await syncBlacklistedMints()
        // Clear the pending failure
        self.pendingMintFailure = nil
    }
}
// MARK: - Errors
enum WalletError: LocalizedError {
    case ndkNotInitialized
    case noActiveWallet // TODO: rename to noWallet
    case notAuthenticated
    case insufficientBalance
    case invalidToken
    case encodingError
    case signerNotAvailable
    case invalidMintURL
    case mintNotFound
    var errorDescription: String? {
        switch self {
        case .ndkNotInitialized:
            return "NDK is not initialized"
        case .noActiveWallet:
            return "No wallet found"
        case .notAuthenticated:
            return "User not authenticated"
        case .insufficientBalance:
            return "Insufficient balance"
        case .invalidToken:
            return "Invalid token format"
        case .encodingError:
            return "Failed to encode data"
        case .signerNotAvailable:
            return "Signer not available yet"
        case .invalidMintURL:
            return "Invalid mint URL"
        case .mintNotFound:
            return "Mint not found"
        }
    }
}
// MARK: - Extensions
</file>

<file path="Sources/NutsackiOS/Views/Auth/AuthenticationFlow.swift">
import SwiftUI
import NDKSwift
struct AuthenticationFlow: View {
    @Environment(\.colorScheme) private var colorScheme
    @EnvironmentObject private var nostrManager: NostrManager
    @Environment(WalletManager.self) private var walletManager
    @Environment(\.dismiss) private var dismiss
    // Shared animation values for smooth transitions
    @State private var logoSize: CGFloat = 140
    @State private var logoOpacity: Double = 0
    @State private var logoScale: CGFloat = 0.3
    @State private var logoRotation: Double = -180
    @State private var logoPosition = CGPoint(x: 0, y: 0)
    @State private var titleText = "NUTSACK"
    @State private var titleOpacity: Double = 0
    @State private var titleOffset: CGFloat = 0
    @State private var titleSize: CGFloat = 52
    @State private var sloganOpacity: Double = 0
    @State private var contentOpacity: Double = 0
    @State private var buttonsOpacity: Double = 0
    // Background effects
    @State private var glowOpacity: Double = 0
    @State private var pulseScale: CGFloat = 1
    @State private var electricityOffset: CGFloat = -100
    // Wallet onboarding sheet
    @State private var walletOnboardingAuthMode: WalletOnboardingView.AuthMode? = nil
    @State private var checkingExistingUser = true
    var body: some View {
        ZStack {
            // Background
            backgroundGradient
            electricEffects
            // Main content - centered vertically
            VStack(spacing: 40) {
                Spacer()
                // Animated header
                AnimatedHeader(
                    logoSize: logoSize,
                    logoOpacity: logoOpacity,
                    logoScale: logoScale,
                    logoRotation: logoRotation,
                    logoPosition: logoPosition,
                    titleText: titleText,
                    titleOpacity: titleOpacity,
                    titleOffset: titleOffset,
                    titleSize: titleSize,
                    sloganOpacity: sloganOpacity,
                    showSlogan: true,
                    glowOpacity: glowOpacity,
                    pulseScale: pulseScale
                )
                // Auth buttons
                authButtons
                    .opacity(contentOpacity)
                    .animation(.easeInOut(duration: 0.4), value: contentOpacity)
                Spacer()
            }
            .padding(.vertical, 40)
        }
        .onAppear {
            startSplashAnimation()
            checkForExistingUser()
        }
        .fullScreenCover(item: $walletOnboardingAuthMode) { authMode in
            WalletOnboardingView(authMode: authMode)
                .environmentObject(nostrManager)
                .environment(walletManager)
                .onDisappear {
                    // If wallet onboarding completes, dismiss the whole auth flow
                    Task {
                        if walletManager.isWalletConfigured {
                            dismiss()
                        }
                    }
                }
        }
    }
    @ViewBuilder
    private var authButtons: some View {
        VStack(spacing: 16) {
            Button(action: {
                print("🔍 [AuthFlow] New Account clicked")
                print("🔍 [AuthFlow] NostrManager.isAuthenticated: \(nostrManager.isAuthenticated)")
                print("🔍 [AuthFlow] NostrManager has signer: \(nostrManager.ndk.signer != nil)")
                print("🔍 [AuthFlow] Setting authMode to: .create")
                walletOnboardingAuthMode = .create
            }) {
                HStack {
                    Image(systemName: "bolt.fill")
                        .font(.system(size: 20))
                    Text("New Account")
                        .font(.system(size: 18, weight: .semibold))
                }
                .frame(maxWidth: .infinity)
                .frame(height: 56)
                .background(
                    LinearGradient(
                        gradient: Gradient(colors: [
                            Color.orange,
                            Color(red: 0.9, green: 0.5, blue: 0.1)
                        ]),
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                )
                .foregroundColor(.white)
                .clipShape(RoundedRectangle(cornerRadius: 16))
                .shadow(color: Color.orange.opacity(0.3), radius: 10, x: 0, y: 4)
            }
            Button(action: {
                print("🔍 [AuthFlow] Login clicked")
                print("🔍 [AuthFlow] NostrManager.isAuthenticated: \(nostrManager.isAuthenticated)")
                print("🔍 [AuthFlow] NostrManager has signer: \(nostrManager.ndk.signer != nil)")
                print("🔍 [AuthFlow] Setting authMode to: .import")
                walletOnboardingAuthMode = .import
            }) {
                HStack {
                    Image(systemName: "key.fill")
                        .font(.system(size: 20))
                    Text("Login")
                        .font(.system(size: 18, weight: .semibold))
                }
                .frame(maxWidth: .infinity)
                .frame(height: 56)
                .background(Color.white.opacity(0.1))
                .foregroundColor(.white)
                .overlay(
                    RoundedRectangle(cornerRadius: 16)
                        .stroke(Color.white.opacity(0.3), lineWidth: 1)
                )
                .clipShape(RoundedRectangle(cornerRadius: 16))
            }
            Text("Your keys, your nuts")
                .font(.system(size: 14, weight: .medium))
                .foregroundColor(Color.white.opacity(0.4))
                .padding(.top, 8)
            // Show logout option if authenticated
            if nostrManager.isAuthenticated {
                Button(action: {
                    Task {
                        await nostrManager.logout()
                    }
                }) {
                    Text("Logout from current account")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundColor(Color.white.opacity(0.6))
                }
                .padding(.top, 16)
            }
        }
        .padding(.horizontal, 32)
        .opacity(buttonsOpacity)
    }
    // MARK: - Background Views
    @ViewBuilder
    private var backgroundGradient: some View {
        LinearGradient(
            gradient: Gradient(colors: [
                Color(red: 0.05, green: 0.02, blue: 0.08),
                Color(red: 0.02, green: 0.01, blue: 0.03),
                Color.black
            ]),
            startPoint: .topLeading,
            endPoint: .bottomTrailing
        )
        .ignoresSafeArea()
    }
    @ViewBuilder
    private var electricEffects: some View {
        ForEach(0..<5) { index in
            ElectricArc(
                startPoint: CGPoint(x: 0.5, y: 0.5),
                endPoint: CGPoint(
                    x: 0.5 + cos(Double(index) * .pi / 2.5) * 0.4,
                    y: 0.5 + sin(Double(index) * .pi / 2.5) * 0.4
                )
            )
            .stroke(
                LinearGradient(
                    gradient: Gradient(colors: [
                        Color.orange.opacity(0.6),
                        Color.purple.opacity(0.3),
                        Color.clear
                    ]),
                    startPoint: .center,
                    endPoint: .bottom
                ),
                lineWidth: 2
            )
            .blur(radius: 3)
            .opacity(glowOpacity * 0.3)
            .offset(y: electricityOffset)
            .animation(
                .easeInOut(duration: 2)
                .delay(Double(index) * 0.1)
                .repeatForever(autoreverses: true),
                value: electricityOffset
            )
        }
    }
    private var primaryButtonGradient: LinearGradient {
        LinearGradient(
            gradient: Gradient(colors: [
                Color.orange,
                Color(red: 0.9, green: 0.5, blue: 0.1)
            ]),
            startPoint: .leading,
            endPoint: .trailing
        )
    }
    // MARK: - Animation Methods
    private func startSplashAnimation() {
        // Logo animation
        withAnimation(.spring(response: 1.2, dampingFraction: 0.7)) {
            logoScale = 1
            logoOpacity = 1
            logoRotation = 0
        }
        // Glow effects
        withAnimation(.easeInOut(duration: 1.5).delay(0.2)) {
            glowOpacity = 0.8
        }
        // Start electricity animation
        withAnimation(.easeInOut(duration: 2).delay(0.5).repeatForever(autoreverses: true)) {
            electricityOffset = 100
        }
        // Title animation - no offset change to prevent bouncing
        withAnimation(.easeOut(duration: 0.8).delay(0.8)) {
            titleOpacity = 1
        }
        // Set titleOffset to 0 immediately without animation
        titleOffset = 0
        // Slogan animation
        withAnimation(.easeOut(duration: 0.8).delay(1.2)) {
            sloganOpacity = 1
        }
        // Pulse animation
        withAnimation(.easeInOut(duration: 1.5).delay(1).repeatForever(autoreverses: true)) {
            pulseScale = 1.1
        }
        // Button animation
        withAnimation(.spring(response: 0.8, dampingFraction: 0.8).delay(2.0)) {
            buttonsOpacity = 1
            contentOpacity = 1
        }
    }
    private func checkForExistingUser() {
        // Don't do anything here - this entire view shouldn't be shown if authenticated
        checkingExistingUser = false
    }
}
// MARK: - Animated Header Component
struct AnimatedHeader: View {
    let logoSize: CGFloat
    let logoOpacity: Double
    let logoScale: CGFloat
    let logoRotation: Double
    let logoPosition: CGPoint
    let titleText: String
    let titleOpacity: Double
    let titleOffset: CGFloat
    let titleSize: CGFloat
    let sloganOpacity: Double
    let showSlogan: Bool
    let glowOpacity: Double
    let pulseScale: CGFloat
    var body: some View {
        VStack(spacing: 20) {
            // Logo
            ZStack {
                // Outer pulsing glow
                Circle()
                    .fill(
                        RadialGradient(
                            gradient: Gradient(colors: [
                                Color.orange.opacity(0.8),
                                Color.purple.opacity(0.4),
                                Color.clear
                            ]),
                            center: .center,
                            startRadius: 10,
                            endRadius: logoSize * 0.8
                        )
                    )
                    .frame(width: logoSize * 2, height: logoSize * 2)
                    .blur(radius: 30)
                    .scaleEffect(pulseScale)
                    .opacity(logoOpacity * 0.7)
                // Logo background circle
                Circle()
                    .fill(
                        LinearGradient(
                            gradient: Gradient(colors: [
                                Color.orange,
                                Color.orange.opacity(0.9),
                                Color(red: 0.8, green: 0.4, blue: 0.1)
                            ]),
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .frame(width: logoSize, height: logoSize)
                    .shadow(color: Color.orange.opacity(0.5), radius: 20, x: 0, y: 5)
                    .scaleEffect(logoScale)
                    .opacity(logoOpacity)
                    .rotationEffect(.degrees(logoRotation))
                // Nut logo
                NutLogoView(size: logoSize * 0.57, color: .white)
                    .scaleEffect(logoScale)
                    .opacity(logoOpacity)
                    .rotationEffect(.degrees(logoRotation))
            }
            .offset(x: logoPosition.x, y: logoPosition.y)
            // Title and slogan
            VStack(spacing: 8) {
                Text(titleText)
                    .font(.system(size: titleSize, weight: .black, design: .default))
                    .tracking(titleSize > 40 ? 4 : 3)
                    .foregroundStyle(
                        LinearGradient(
                            gradient: Gradient(colors: [
                                Color.white,
                                Color.white.opacity(0.9)
                            ]),
                            startPoint: .top,
                            endPoint: .bottom
                        )
                    )
                    .shadow(color: Color.orange.opacity(0.3), radius: 10, x: 0, y: 2)
                    .opacity(titleOpacity)
                    .offset(y: titleOffset)
                if showSlogan {
                    Text("A WALLET FOR THE RELAYS")
                        .font(.system(size: 16, weight: .medium, design: .monospaced))
                        .tracking(2)
                        .foregroundColor(Color.white.opacity(0.7))
                        .opacity(sloganOpacity)
                        .transition(.opacity.combined(with: .scale))
                }
            }
        }
        .padding(.horizontal, 32)
    }
}
</file>

<file path="Sources/NutsackiOS/Views/Utils/UserProfileViews.swift">
import SwiftUI
import NDKSwift
import NDKSwiftUI
// Lightweight wrappers around NDKSwiftUI components to maintain API compatibility
// while leveraging NDKSwiftUI's proven implementation
struct UserDisplayName: View {
    let pubkey: String
    @EnvironmentObject private var nostrManager: NostrManager
    init(user: NDKUser) {
        self.pubkey = user.pubkey
    }
    init(pubkey: String) {
        self.pubkey = pubkey
    }
    var body: some View {
        NDKUIDisplayName(ndk: nostrManager.ndk, pubkey: pubkey)
    }
}
struct UserProfilePicture: View {
    let pubkey: String
    let size: CGFloat
    @EnvironmentObject private var nostrManager: NostrManager
    init(user: NDKUser, size: CGFloat = 40) {
        self.pubkey = user.pubkey
        self.size = size
    }
    init(pubkey: String, size: CGFloat = 40) {
        self.pubkey = pubkey
        self.size = size
    }
    var body: some View {
        NDKUIProfilePicture(ndk: nostrManager.ndk, pubkey: pubkey, size: size)
    }
}
struct UserNIP05: View {
    let pubkey: String
    @EnvironmentObject private var nostrManager: NostrManager
    init(user: NDKUser) {
        self.pubkey = user.pubkey
    }
    init(pubkey: String) {
        self.pubkey = pubkey
    }
    var body: some View {
        NDKUIUsername(ndk: nostrManager.ndk, pubkey: pubkey)
    }
}
</file>

<file path="Sources/NutsackiOS/Views/Wallet/BalanceCard.swift">
import SwiftUI
struct BalanceCardMint: Identifiable, Equatable {
    let id = UUID()
    let mint: String
    let balance: Int64
    let percentage: Double
    static func == (lhs: BalanceCardMint, rhs: BalanceCardMint) -> Bool {
        lhs.mint == rhs.mint && lhs.balance == rhs.balance && lhs.percentage == rhs.percentage
    }
}
struct BalanceCard: View {
    @EnvironmentObject private var appState: AppState
    @Environment(WalletManager.self) private var walletManager
    @State private var convertedBalance: String = ""
    @State private var mintBalances: [BalanceCardMint] = []
    @State private var isLoadingMints = false
    @State private var isExpanded = false
    @State private var pulseAnimation = false
    private let mintColors: [Color] = [
        Color(red: 0.98, green: 0.54, blue: 0.13), // Orange
        Color(red: 0.13, green: 0.59, blue: 0.95), // Blue
        Color(red: 0.96, green: 0.26, blue: 0.21), // Red
        Color(red: 0.30, green: 0.69, blue: 0.31) // Green
    ]
    private let compactChartSize: CGFloat = 20
    private let expandedChartSize: CGFloat = 160
    var body: some View {
        VStack(spacing: 12) {
            // Balance display - centered
            VStack(spacing: 4) {
                HStack(alignment: .firstTextBaseline, spacing: 8) {
                    Text(formatBalance(Int(walletManager.currentBalance)))
                        .font(.system(size: isExpanded ? 48 : 56, weight: .semibold, design: .rounded))
                        .foregroundStyle(.primary)
                    Text("sats")
                        .font(.system(size: isExpanded ? 20 : 24, weight: .medium, design: .rounded))
                        .foregroundStyle(.secondary)
                }
                .animation(.spring(response: 0.4, dampingFraction: 0.8), value: isExpanded)
                // Show pending amount if any
                if walletManager.pendingAmount != 0 {
                    Text("\(walletManager.pendingAmount > 0 ? "+" : "")\(abs(walletManager.pendingAmount)) pending")
                        .font(.system(size: 14, weight: .medium, design: .rounded))
                        .foregroundStyle(.orange)
                        .opacity(0.8)
                }
                // Fiat conversion and/or mini pie chart
                HStack(spacing: 12) {
                    // Compact pie chart on the left - show if there are any mints at all
                    if !mintBalances.isEmpty && !isExpanded {
                        ZStack {
                            ExpandablePieChart(
                                mintBalances: mintBalances,
                                mintColors: mintColors,
                                size: compactChartSize,
                                useGrayscale: true
                            )
                            // Subtle pulsing ring hint
                            Circle()
                                .stroke(Color.orange.opacity(0.3), lineWidth: 1)
                                .frame(width: compactChartSize + 8, height: compactChartSize + 8)
                                .scaleEffect(pulseAnimation ? 1.3 : 1.0)
                                .opacity(pulseAnimation ? 0.2 : 0.6)
                                .animation(
                                    Animation.easeInOut(duration: 2)
                                        .repeatForever(autoreverses: true),
                                    value: pulseAnimation
                                )
                        }
                        .onTapGesture {
                            withAnimation(.spring(response: 0.5, dampingFraction: 0.8)) {
                                isExpanded.toggle()
                            }
                        }
                    }
                    // Show fiat conversion if available
                    if appState.preferredConversionUnit != .sat && !convertedBalance.isEmpty && convertedBalance != "..." {
                        Text(convertedBalance)
                            .font(.system(size: 18, weight: .regular, design: .rounded))
                            .foregroundStyle(.secondary)
                            .opacity(isExpanded ? 0.5 : 0.8)
                    }
                }
                .animation(.default, value: convertedBalance)
            }
            // Expanded pie chart with legend
            if !mintBalances.isEmpty && isExpanded {
                VStack(spacing: 16) {
                    // Large pie chart
                    ExpandablePieChart(
                        mintBalances: mintBalances,
                        mintColors: mintColors,
                        size: expandedChartSize,
                        useGrayscale: false
                    )
                    .onTapGesture {
                        withAnimation(.spring(response: 0.5, dampingFraction: 0.8)) {
                            isExpanded.toggle()
                        }
                    }
                    // Legend
                    VStack(alignment: .leading, spacing: 8) {
                        ForEach(Array(mintBalances.enumerated()), id: \.element.id) { index, item in
                            HStack(spacing: 10) {
                                Circle()
                                    .fill(mintColors[index % mintColors.count])
                                    .frame(width: 14, height: 14)
                                VStack(alignment: .leading, spacing: 1) {
                                    Text(formatMintURL(item.mint))
                                        .font(.system(size: 14, weight: .medium))
                                        .foregroundStyle(.primary)
                                    Text("\(formatBalance(Int(item.balance))) sats (\(String(format: "%.1f", item.percentage))%)")
                                        .font(.system(size: 12))
                                        .foregroundStyle(.secondary)
                                }
                                Spacer()
                            }
                        }
                    }
                    .padding(.horizontal)
                    // Reconcile button
                    NavigationLink(destination: SwapView()) {
                        HStack(spacing: 6) {
                            Image(systemName: "arrow.triangle.swap")
                                .font(.system(size: 14))
                            Text("Reconcile")
                        }
                        .font(.system(size: 15, weight: .medium))
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 10)
                        .background(Color.orange)
                        .cornerRadius(10)
                    }
                    .padding(.horizontal)
                    .padding(.top, 4)
                }
                .transition(.asymmetric(
                    insertion: .scale.combined(with: .opacity),
                    removal: .scale.combined(with: .opacity)
                ))
            }
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, 16)
        .task(id: walletManager.currentBalance) {
            await convert()
            await loadMintBalances()
        }
        .task {
            await convert()
            await loadMintBalances()
        }
        .onAppear {
            pulseAnimation = true
        }
        .onChange(of: appState.preferredConversionUnit) { _, _ in
            Task {
                await convert()
            }
        }
        .onChange(of: appState.exchangeRates) { _, _ in
            Task {
                await convert()
            }
        }
    }
    private func formatBalance(_ sats: Int) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.groupingSeparator = ","
        return formatter.string(from: NSNumber(value: sats)) ?? String(sats)
    }
    private func formatMintURL(_ urlString: String) -> String {
        guard let url = URL(string: urlString),
              let host = url.host else {
            return urlString
        }
        var cleanHost = host
        if cleanHost.hasPrefix("www.") {
            cleanHost = String(cleanHost.dropFirst(4))
        }
        if cleanHost.count > 20 {
            return String(cleanHost.prefix(17)) + "..."
        }
        return cleanHost
    }
    @MainActor
    private func convert() async {
        convertedBalance = "..."
        guard let prices = appState.exchangeRates else {
            print("⚠️ BalanceCard: No exchange rates available")
            convertedBalance = ""
            // Try to reload exchange rates
            appState.loadExchangeRates()
            return
        }
        let bitcoinPrice: Int
        switch appState.preferredConversionUnit {
        case .usd: bitcoinPrice = prices.usd
        case .eur: bitcoinPrice = prices.eur
        case .btc:
            let btcAmount = Double(walletManager.currentBalance) / 100_000_000.0
            convertedBalance = String(format: "%.8f BTC", btcAmount)
            return
        case .sat:
            print("⚠️ BalanceCard: Conversion unit is SAT, not showing fiat balance")
            convertedBalance = ""
            return
        }
        let bitcoinAmount = Double(walletManager.currentBalance) / 100_000_000.0
        let fiatValue = bitcoinAmount * Double(bitcoinPrice)
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.currencyCode = appState.preferredConversionUnit.rawValue.uppercased()
        convertedBalance = formatter.string(from: NSNumber(value: fiatValue)) ?? ""
        print("✅ BalanceCard: Converted \(walletManager.currentBalance) sats to \(convertedBalance) (\(appState.preferredConversionUnit.rawValue))")
    }
    private func loadMintBalances() async {
        isLoadingMints = true
        defer { isLoadingMints = false }
        guard let wallet = walletManager.wallet else { return }
        // Use the efficient getBalancesByMint method instead of looping
        let balancesByMint = await wallet.getBalancesByMint()
        var balances: [BalanceCardMint] = []
        let totalBalance = balancesByMint.values.reduce(0, +)
        // Convert to BalanceCardMint array with percentages
        for (mint, balance) in balancesByMint where balance > 0 {
            let percentage = totalBalance > 0 ? (Double(balance) / Double(totalBalance)) * 100 : 0
            balances.append(BalanceCardMint(mint: mint, balance: balance, percentage: percentage))
        }
        // Sort by balance (largest first) and take top 4
        balances.sort { $0.balance > $1.balance }
        if balances.count > 4 {
            balances = Array(balances.prefix(4))
        }
        await MainActor.run {
            self.mintBalances = balances
        }
    }
}
struct ExpandablePieChart: View {
    let mintBalances: [BalanceCardMint]
    let mintColors: [Color]
    let size: CGFloat
    var useGrayscale: Bool = false
    @State private var showChart = false
    private let grayscaleColors: [Color] = [
        Color(white: 0.7),
        Color(white: 0.5),
        Color(white: 0.3),
        Color(white: 0.4)
    ]
    var body: some View {
        ZStack {
            ForEach(Array(mintBalances.enumerated()), id: \.element.id) { index, _ in
                Circle()
                    .trim(from: startAngle(for: index), to: endAngle(for: index))
                    .stroke(
                        useGrayscale ? grayscaleColors[index % grayscaleColors.count] : mintColors[index % mintColors.count],
                        style: StrokeStyle(
                            lineWidth: size > 50 ? size * 0.25 : size * 0.25,
                            lineCap: .butt
                        )
                    )
                    .rotationEffect(.degrees(-90))
                    .scaleEffect(showChart ? 1 : 0)
                    .opacity(showChart ? 1 : 0)
                    .animation(
                        .spring(response: 0.5, dampingFraction: 0.7)
                        .delay(Double(index) * 0.05),
                        value: showChart
                    )
            }
            // Subtle inner shadow for depth (only for larger sizes)
            if size > 50 {
                Circle()
                    .stroke(
                        LinearGradient(
                            gradient: Gradient(colors: [
                                Color(.label).opacity(0.2),
                                Color.clear
                            ]),
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        ),
                        lineWidth: 1
                    )
                    .frame(width: size * 0.5, height: size * 0.5)
                    .blur(radius: 2)
            }
        }
        .frame(width: size, height: size)
        .onAppear {
            withAnimation(.easeOut(duration: 0.3)) {
                showChart = true
            }
        }
        .onChange(of: mintBalances) { _, _ in
            showChart = false
            withAnimation(.easeOut(duration: 0.3).delay(0.1)) {
                showChart = true
            }
        }
    }
    private func startAngle(for index: Int) -> CGFloat {
        guard index > 0 else { return 0 }
        let previousAngles = mintBalances[0..<index].reduce(0) { sum, item in
            sum + (item.percentage / 100.0)
        }
        return previousAngles
    }
    private func endAngle(for index: Int) -> CGFloat {
        let cumulativeAngle = mintBalances[0...index].reduce(0) { sum, item in
            sum + (item.percentage / 100.0)
        }
        return cumulativeAngle
    }
}
</file>

<file path="Sources/NutsackiOS/Views/Wallet/MintDetailView.swift">
import SwiftUI
import NDKSwift
import CashuSwift
struct MintDetailView: View {
    let mintURL: String
    @Environment(WalletManager.self) private var walletManager
    @EnvironmentObject private var nostrManager: NostrManager
    @Environment(\.dismiss) private var dismiss
    @State private var balance: Int64 = 0
    @State private var mintInfo: NDKMintInfo?
    @State private var walletEvents: [WalletEventInfo] = []
    @State private var proofEntries: [ProofStateManager.ProofEntry] = []
    @State private var isLoadingEvents = true
    @State private var isLoadingProofs = true
    @State private var isValidatingProofs = false
    @State private var validationResult: ProofValidationResult?
    @State private var showValidationDetails = false
    @State private var selectedTab = 0
    struct ProofValidationResult {
        let totalProofs: Int
        let validProofs: Int
        let spentProofs: Int
        let pendingProofs: Int
        let invalidProofs: Int
        let proofStates: [String: CashuSwift.Proof.ProofState]
    }
    var body: some View {
        VStack(spacing: 0) {
            // Header with mint info and balance
            VStack(spacing: 16) {
                HStack {
                    VStack(alignment: .leading, spacing: 4) {
                        Text(mintInfo?.name ?? URL(string: mintURL)?.host ?? "Unknown Mint")
                            .font(.title2)
                            .fontWeight(.semibold)
                        Text(mintURL)
                            .font(.caption)
                            .foregroundStyle(.secondary)
                            .lineLimit(1)
                    }
                    Spacer()
                    VStack(alignment: .trailing, spacing: 4) {
                        Text("\(balance)")
                            .font(.title)
                            .fontWeight(.bold)
                            .foregroundColor(.orange)
                        Text("sats")
                            .font(.caption)
                            .foregroundStyle(.secondary)
                    }
                }
                // Quick actions
                HStack(spacing: 12) {
                    Button(action: { isValidatingProofs = true; Task { await validateAllProofs() } }) {
                        Label("Validate Proofs", systemImage: "checkmark.shield")
                            .font(.caption)
                    }
                    .buttonStyle(.bordered)
                    .disabled(isValidatingProofs)
                    if validationResult != nil {
                        Button(action: { showValidationDetails = true }) {
                            Label("View Results", systemImage: "doc.text.magnifyingglass")
                                .font(.caption)
                        }
                        .buttonStyle(.borderedProminent)
                        .tint(.orange)
                    }
                }
            }
            .padding()
            .background(Color(.secondarySystemGroupedBackground))
            // Tab selection
            Picker("View", selection: $selectedTab) {
                Text("Token Events").tag(0)
                Text("Proofs").tag(1)
                Text("Mint Info").tag(2)
            }
            .pickerStyle(.segmented)
            .padding()
            // Content based on selected tab
            switch selectedTab {
            case 0:
                TokenEventsTab(mintURL: mintURL, walletEvents: $walletEvents, isLoading: $isLoadingEvents)
            case 1:
                ProofsTab(proofEntries: $proofEntries, isLoading: $isLoadingProofs, validationResult: validationResult)
            case 2:
                MintInfoTab(mintInfo: mintInfo, mintURL: mintURL)
            default:
                EmptyView()
            }
        }
        .navigationTitle("Mint Details")
        .navigationBarTitleDisplayMode(.inline)
        .task {
            await loadMintData()
        }
        .refreshable {
            await loadMintData()
        }
        .sheet(isPresented: $showValidationDetails) {
            if let result = validationResult {
                ValidationResultsView(result: result, proofEntries: proofEntries)
            }
        }
    }
    private func loadMintData() async {
        await withTaskGroup(of: Void.self) { group in
            group.addTask { await loadBalance() }
            group.addTask { await loadMintInfo() }
            group.addTask { await loadWalletEvents() }
            group.addTask { await loadProofs() }
        }
    }
    private func loadBalance() async {
        guard let wallet = walletManager.wallet else { return }
        guard let url = URL(string: mintURL) else { return }
        let mintBalance = await wallet.getBalance(mint: url)
        await MainActor.run {
            self.balance = mintBalance
        }
    }
    private func loadMintInfo() async {
        guard let wallet = walletManager.wallet else { return }
        guard let url = URL(string: mintURL) else { return }
        do {
            let info = try await wallet.mints.getMintInfo(url: url)
            await MainActor.run {
                self.mintInfo = info
            }
        } catch {
            print("Failed to load mint info: \(error)")
        }
    }
    private func loadWalletEvents() async {
        isLoadingEvents = true
        do {
            // Fetch all wallet events and filter by mint
            let allEvents = try await walletManager.fetchAllWalletEvents()
            let mintEvents = allEvents.filter { event in
                event.tokenData?.mint == mintURL
            }
            await MainActor.run {
                self.walletEvents = mintEvents.sorted { $0.event.createdAt > $1.event.createdAt }
                self.isLoadingEvents = false
            }
        } catch {
            await MainActor.run {
                self.isLoadingEvents = false
            }
        }
    }
    private func loadProofs() async {
        isLoadingProofs = true
        guard let wallet = walletManager.wallet else {
            await MainActor.run { isLoadingProofs = false }
            return
        }
        let entries = await wallet.proofStateManager.getEntries(mint: mintURL)
        await MainActor.run {
            self.proofEntries = entries.filter { $0.state != .deleted }
                .sorted { $0.proof.amount > $1.proof.amount }
            self.isLoadingProofs = false
        }
    }
    private func validateAllProofs() async {
        guard let wallet = walletManager.wallet,
              let url = URL(string: mintURL) else { return }
        do {
            let states = try await wallet.checkProofStates(mintURL: url)
            // Count different states
            var validCount = 0
            var spentCount = 0
            var pendingCount = 0
            for (_, state) in states {
                switch state {
                case .unspent:
                    validCount += 1
                case .spent:
                    spentCount += 1
                case .pending:
                    pendingCount += 1
                }
            }
            let result = ProofValidationResult(
                totalProofs: states.count,
                validProofs: validCount,
                spentProofs: spentCount,
                pendingProofs: pendingCount,
                invalidProofs: 0,
                proofStates: states
            )
            await MainActor.run {
                self.validationResult = result
                self.isValidatingProofs = false
                self.showValidationDetails = true
            }
        } catch {
            print("Failed to validate proofs: \(error)")
            await MainActor.run {
                self.isValidatingProofs = false
            }
        }
    }
}
// MARK: - Token Events Tab
struct TokenEventsTab: View {
    let mintURL: String
    @Binding var walletEvents: [WalletEventInfo]
    @Binding var isLoading: Bool
    var body: some View {
        if isLoading {
            ProgressView("Loading events...")
                .frame(maxWidth: .infinity, maxHeight: .infinity)
        } else if walletEvents.isEmpty {
            ContentUnavailableView(
                "No Token Events",
                systemImage: "doc.text",
                description: Text("No token events found for this mint")
            )
        } else {
            List {
                Section {
                    ForEach(walletEvents) { eventInfo in
                        NavigationLink(value: eventInfo) {
                            WalletEventRow(eventInfo: eventInfo)
                        }
                    }
                } header: {
                    HStack {
                        Text("Token Events")
                        Spacer()
                        Text("\(walletEvents.count) total")
                            .font(.caption)
                            .foregroundStyle(.secondary)
                    }
                }
            }
            .navigationDestination(for: WalletEventInfo.self) { eventInfo in
                WalletEventDetailView(eventInfo: eventInfo)
            }
        }
    }
}
// MARK: - Proofs Tab
struct ProofsTab: View {
    @Binding var proofEntries: [ProofStateManager.ProofEntry]
    @Binding var isLoading: Bool
    let validationResult: MintDetailView.ProofValidationResult?
    var activeProofs: [ProofStateManager.ProofEntry] {
        proofEntries.filter { $0.state == .available }
    }
    var reservedProofs: [ProofStateManager.ProofEntry] {
        proofEntries.filter { $0.state == .reserved }
    }
    var body: some View {
        if isLoading {
            ProgressView("Loading proofs...")
                .frame(maxWidth: .infinity, maxHeight: .infinity)
        } else if proofEntries.isEmpty {
            ContentUnavailableView(
                "No Proofs",
                systemImage: "key",
                description: Text("No proofs found for this mint")
            )
        } else {
            List {
                if !activeProofs.isEmpty {
                    Section {
                        ForEach(activeProofs, id: \.proof.C) { entry in
                            ProofEntryRow(entry: entry, validationState: validationResult?.proofStates[entry.proof.C])
                        }
                    } header: {
                        HStack {
                            Text("Available Proofs")
                            Spacer()
                            Text("\(activeProofs.count)")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                        }
                    }
                }
                if !reservedProofs.isEmpty {
                    Section {
                        ForEach(reservedProofs, id: \.proof.C) { entry in
                            ProofEntryRow(entry: entry, validationState: validationResult?.proofStates[entry.proof.C])
                        }
                    } header: {
                        HStack {
                            Text("Reserved Proofs")
                            Spacer()
                            Text("\(reservedProofs.count)")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                        }
                    }
                }
            }
        }
    }
}
// MARK: - Mint Info Tab
struct MintInfoTab: View {
    let mintInfo: NDKMintInfo?
    let mintURL: String
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 20) {
                if let info = mintInfo {
                    mintInfoContent(info: info)
                } else {
                    noMintInfoContent
                }
            }
            .padding()
        }
    }
    @ViewBuilder
    private func mintInfoContent(info: NDKMintInfo) -> some View {
        // Basic Info
        basicInfoSection(info: info)
        // Contact Info
        ContactInfoSection(contacts: info.contact)
        // Supported Methods
        supportedMethodsSection(nuts: info.nuts)
    }
    @ViewBuilder
    private func basicInfoSection(info: NDKMintInfo) -> some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Mint Information")
                .font(.headline)
            LabeledContent("Name", value: info.name ?? "Unknown")
            LabeledContent("Public Key", value: String(info.pubkey?.prefix(16) ?? "Unknown") + "...")
                .font(.system(.body, design: .monospaced))
            if let description = info.description {
                VStack(alignment: .leading, spacing: 4) {
                    Text("Description")
                        .font(.caption)
                        .foregroundStyle(.secondary)
                    Text(description)
                        .font(.body)
                }
            }
        }
        .padding()
        .background(Color(.secondarySystemGroupedBackground))
        .cornerRadius(12)
    }
    @ViewBuilder
    private func supportedMethodsSection(nuts: NDKMintInfo.Nuts?) -> some View {
        if let nuts = nuts {
            VStack(alignment: .leading, spacing: 12) {
                Text("Supported NIPs")
                    .font(.headline)
                VStack(alignment: .leading, spacing: 8) {
                    if nuts.nut04 != nil {
                        nutRow(number: "04", description: "Mint tokens")
                    }
                    if nuts.nut05 != nil {
                        nutRow(number: "05", description: "Melt tokens")
                    }
                    if nuts.nut07 != nil {
                        nutRow(number: "07", description: "Spendable check")
                    }
                    if nuts.nut08 != nil {
                        nutRow(number: "08", description: "Melt with Lightning")
                    }
                    if nuts.nut09 != nil {
                        nutRow(number: "09", description: "Restore")
                    }
                    if nuts.nut10 != nil {
                        nutRow(number: "10", description: "Spending conditions")
                    }
                    if nuts.nut12 != nil {
                        nutRow(number: "12", description: "DLEQ proofs")
                    }
                }
            }
            .padding()
            .background(Color(.secondarySystemGroupedBackground))
            .cornerRadius(12)
        }
    }
    private func nutRow(number: String, description: String) -> some View {
        HStack {
            Text("NUT-\(number)")
                .font(.system(.body, design: .monospaced))
            Text(description)
                .font(.caption)
                .foregroundStyle(.secondary)
            Spacer()
            Image(systemName: "checkmark.circle.fill")
                .foregroundColor(.green)
        }
    }
    private var noMintInfoContent: some View {
        VStack(spacing: 16) {
            Image(systemName: "building.columns")
                .font(.system(size: 48))
                .foregroundColor(.gray)
            Text("Mint information not available")
                .font(.headline)
                .foregroundStyle(.secondary)
            Text(mintURL)
                .font(.caption)
                .foregroundStyle(.tertiary)
        }
        .padding(.vertical, 40)
        .frame(maxWidth: .infinity)
    }
}
// MARK: - Proof Entry Row
struct ProofEntryRow: View {
    let entry: ProofStateManager.ProofEntry
    let validationState: CashuSwift.Proof.ProofState?
    @State private var isExpanded = false
    var stateColor: Color {
        if let validationState = validationState {
            switch validationState {
            case .unspent: return .green
            case .spent: return .red
            case .pending: return .orange
            }
        }
        switch entry.state {
        case .available: return .green
        case .reserved: return .orange
        case .deleted: return .red
        }
    }
    var stateText: String {
        if let validationState = validationState {
            switch validationState {
            case .unspent: return "Valid ✓"
            case .spent: return "Spent ✗"
            case .pending: return "Pending"
            }
        }
        switch entry.state {
        case .available: return "Available"
        case .reserved: return "Reserved"
        case .deleted: return "Deleted"
        }
    }
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    HStack {
                        Text("\(entry.proof.amount) sats")
                            .font(.system(.body, design: .monospaced))
                            .fontWeight(.medium)
                        if validationState != nil {
                            Text("•")
                                .foregroundStyle(.tertiary)
                            Text(stateText)
                                .font(.caption)
                                .foregroundColor(stateColor)
                                .fontWeight(.medium)
                        }
                    }
                    Text("C: " + entry.proof.C.prefix(16) + "...")
                        .font(.system(.caption, design: .monospaced))
                        .foregroundStyle(.secondary)
                }
                Spacer()
                VStack(alignment: .trailing, spacing: 4) {
                    if validationState == nil {
                        Text(stateText)
                            .font(.caption)
                            .foregroundColor(stateColor)
                    }
                    if let eventId = entry.ownerEventId {
                        Text("Event: " + eventId.prefix(8) + "...")
                            .font(.system(.caption2, design: .monospaced))
                            .foregroundStyle(.tertiary)
                    }
                }
                Image(systemName: isExpanded ? "chevron.up" : "chevron.down")
                    .font(.caption)
                    .foregroundStyle(.secondary)
            }
            .contentShape(Rectangle())
            .onTapGesture {
                withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                    isExpanded.toggle()
                }
            }
            if isExpanded {
                VStack(alignment: .leading, spacing: 6) {
                    Divider()
                    Group {
                        LabeledContent("Secret") {
                            Text(entry.proof.secret.prefix(32) + "...")
                                .font(.system(.caption, design: .monospaced))
                                .foregroundStyle(.secondary)
                        }
                        LabeledContent("Keyset ID") {
                            Text(entry.proof.keysetID.prefix(16) + "...")
                                .font(.system(.caption, design: .monospaced))
                                .foregroundStyle(.secondary)
                        }
                        if let eventId = entry.ownerEventId {
                            LabeledContent("Owner Event") {
                                Text(eventId)
                                    .font(.system(.caption, design: .monospaced))
                                    .foregroundStyle(.secondary)
                                    .lineLimit(1)
                            }
                        }
                        if let timestamp = entry.ownerTimestamp {
                            LabeledContent("Created") {
                                Text(Date(timeIntervalSince1970: TimeInterval(timestamp)), style: .relative)
                                    .font(.caption)
                                    .foregroundStyle(.secondary)
                            }
                        }
                    }
                    .font(.caption)
                }
                .padding(.top, 4)
            }
        }
        .padding(.vertical, 4)
    }
}
// MARK: - Validation Results View
struct ValidationResultsView: View {
    let result: MintDetailView.ProofValidationResult
    let proofEntries: [ProofStateManager.ProofEntry]
    @Environment(\.dismiss) private var dismiss
    var body: some View {
        NavigationStack {
            List {
                // Summary Section
                Section("Summary") {
                    HStack {
                        Label("Total Proofs", systemImage: "key.fill")
                        Spacer()
                        Text("\(result.totalProofs)")
                            .fontWeight(.medium)
                    }
                    HStack {
                        Label("Valid", systemImage: "checkmark.circle.fill")
                            .foregroundColor(.green)
                        Spacer()
                        Text("\(result.validProofs)")
                            .fontWeight(.medium)
                            .foregroundColor(.green)
                    }
                    HStack {
                        Label("Spent", systemImage: "xmark.circle.fill")
                            .foregroundColor(.red)
                        Spacer()
                        Text("\(result.spentProofs)")
                            .fontWeight(.medium)
                            .foregroundColor(.red)
                    }
                    if result.pendingProofs > 0 {
                        HStack {
                            Label("Pending", systemImage: "clock.fill")
                                .foregroundColor(.orange)
                            Spacer()
                            Text("\(result.pendingProofs)")
                                .fontWeight(.medium)
                                .foregroundColor(.orange)
                        }
                    }
                }
                // Invalid/Spent Proofs Details
                if result.spentProofs > 0 {
                    Section("Spent Proofs") {
                        ForEach(proofEntries.filter { entry in
                            result.proofStates[entry.proof.C] == .spent
                        }, id: \.proof.C) { entry in
                            ProofEntryRow(entry: entry, validationState: .spent)
                        }
                    }
                }
            }
            .navigationTitle("Validation Results")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .confirmationAction) {
                    Button("Done") { dismiss() }
                }
            }
        }
    }
}
// MARK: - Contact Info Section
private struct ContactInfoSection: View {
    let contacts: [NDKMintInfo.Contact]?
    var body: some View {
        if let contacts = contacts, !contacts.isEmpty {
            VStack(alignment: .leading, spacing: 12) {
                Text("Contact")
                    .font(.headline)
                ForEach(Array(contacts.enumerated()), id: \.offset) { _, contact in
                    HStack(alignment: .top, spacing: 8) {
                        Text("\(contact.method):")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        Text(contact.info)
                            .font(.body)
                    }
                }
            }
            .padding()
            .background(Color(.secondarySystemGroupedBackground))
            .cornerRadius(12)
        }
    }
}
</file>

<file path="Sources/NutsackiOS/Views/Wallet/MintView.swift">
import SwiftUI
import NDKSwift
import CashuSwift
#if os(iOS)
import UIKit
#elseif os(macOS)
import AppKit
#endif
struct MintView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(WalletManager.self) private var walletManager
    @EnvironmentObject private var appState: AppState
    @State private var amount = ""
    @State private var selectedMintURL: String = ""
    @State private var availableMints: [MintInfo] = []
    @State private var isMinting = false
    @State private var showError = false
    @State private var errorMessage = ""
    @State private var mintQuote: CashuMintQuote?
    @State private var showInvoice = false
    @State private var depositTask: Task<Void, Never>?
    @State private var loadMintTask: Task<Void, Never>?
    @State private var showPaymentAnimation = false
    @State private var mintedAmount: Int64 = 0
    @State private var manualCheckContinuation: AsyncStream<Void>.Continuation?
    @FocusState private var amountFieldFocused: Bool
    var body: some View {
        VStack(spacing: 0) {
            ScrollView {
                VStack(spacing: 24) {
                    amountInputSection
                    mintSelectionSection
                }
                .padding(.vertical)
                .padding(.bottom, 120) // Add space for the fixed button and keyboard
            }
            createInvoiceButton
        }
        .navigationTitle("Mint Ecash")
        .platformNavigationBarTitleDisplayMode(inline: true)
        #if os(iOS)
        .ignoresSafeArea(.keyboard, edges: [])
        #endif
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button("Create Invoice") {
                    createMintQuote()
                }
                .foregroundColor(.orange)
                .disabled(!isValidAmount || isMinting)
            }
        }
        .alert("Error", isPresented: $showError) {
            Button("OK") { }
        } message: {
            Text(errorMessage)
        }
        .sheet(isPresented: $showInvoice) {
            if let quote = mintQuote {
                InvoiceView(
                    invoice: quote.invoice,
                    amount: Int(quote.amount),
                    onPaid: { checkMintStatus() },
                    onCheckNow: { manualCheckContinuation?.yield() }
                )
            }
        }
        .task {
            await startMintLoading()
        }
        .onDisappear {
            depositTask?.cancel()
            loadMintTask?.cancel()
        }
        .background(Color(.systemBackground))
        .fullScreenCover(isPresented: $showPaymentAnimation) {
            PaymentReceivedAnimation(amount: mintedAmount) {
                dismiss()
            }
        }
    }
    private func loadMints() async {
        guard let wallet = walletManager.wallet else { return }
        let mintURLs = await wallet.mints.getMintURLs()
        let mints = mintURLs.compactMap { urlString -> MintInfo? in
            guard let url = URL(string: urlString) else { return nil }
            return MintInfo(url: url, name: url.host ?? "Unknown Mint")
        }
        await MainActor.run {
            availableMints = mints
            if selectedMintURL.isEmpty && !mints.isEmpty {
                selectedMintURL = mints.first?.url.absoluteString ?? ""
            }
        }
    }
    private func startMintLoading() async {
        // Initial load
        await loadMints()
        // If no mints found, periodically check until they're available
        if availableMints.isEmpty {
            loadMintTask = Task {
                var attempts = 0
                while attempts < 10 && !Task.isCancelled {
                    try? await Task.sleep(nanoseconds: 1_000_000_000) // 1 second
                    await loadMints()
                    if !availableMints.isEmpty {
                        break
                    }
                    attempts += 1
                }
            }
        }
    }
    // MARK: - Computed Properties
    private var formattedAmount: String {
        if amount.isEmpty {
            return "0"
        }
        // Format with thousand separators
        if let number = Int(amount) {
            let formatter = NumberFormatter()
            formatter.numberStyle = .decimal
            formatter.groupingSeparator = ","
            return formatter.string(from: NSNumber(value: number)) ?? amount
        }
        return amount
    }
    private var isValidAmount: Bool {
        guard let amountInt = Int(amount), amountInt > 0 else { return false }
        return !selectedMintURL.isEmpty
    }
    // MARK: - View Components
    private var amountInputSection: some View {
        VStack(spacing: 16) {
            // Hidden text field that drives the amount
            TextField("0", text: $amount)
                .keyboardType(.numberPad)
                .opacity(0)
                .frame(height: 0)
                .focused($amountFieldFocused)
            // Visual amount display
            VStack(spacing: 8) {
                HStack(alignment: .firstTextBaseline, spacing: 8) {
                    Text(formattedAmount)
                        .font(.system(size: 48, weight: .semibold, design: .rounded))
                        .foregroundStyle(.primary)
                    Text("sats")
                        .font(.system(size: 20, weight: .medium, design: .rounded))
                        .foregroundStyle(.secondary)
                }
                .contentShape(Rectangle())
                .onTapGesture {
                    amountFieldFocused = true
                }
                // USD equivalent (placeholder)
                Text("≈ $0.00 USD")
                    .font(.system(size: 16, weight: .regular, design: .rounded))
                    .foregroundStyle(.secondary)
                    .opacity(0.6)
            }
            // Quick amount buttons
            HStack(spacing: 12) {
                ForEach(AmountPresets.nutzapAmounts, id: \.self) { preset in
                    Button(action: { setAmount(preset) }) {
                        Text("\(preset / 1000)k")
                            .font(.system(size: 14, weight: .medium, design: .rounded))
                            .foregroundColor(.orange)
                            .padding(.horizontal, 14)
                            .padding(.vertical, 6)
                            .background(Color.orange.opacity(0.15))
                            .cornerRadius(16)
                    }
                }
            }
        }
        .padding(.horizontal)
    }
    private var mintSelectionSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Select Mint")
                .font(.headline)
                .padding(.horizontal)
            if availableMints.isEmpty {
                HStack {
                    ProgressView()
                        .scaleEffect(0.8)
                    Text("Loading mints...")
                        .foregroundStyle(.secondary)
                }
                .padding(.vertical, 8)
            } else {
                VStack(spacing: 8) {
                    ForEach(availableMints, id: \.url.absoluteString) { mint in
                        mintRow(for: mint)
                    }
                }
            }
        }
    }
    private func mintRow(for mint: MintInfo) -> some View {
        HStack {
            // Mint icon
            Circle()
                .fill(Color.orange.opacity(0.15))
                .frame(width: 40, height: 40)
                .overlay(
                    Image(systemName: "building.columns")
                        .font(.system(size: 16))
                        .foregroundColor(.orange)
                )
            VStack(alignment: .leading, spacing: 2) {
                Text(mint.name ?? mint.url.host ?? "Unknown Mint")
                    .font(.system(size: 16, weight: .medium))
                Text(mint.url.host ?? mint.url.absoluteString)
                    .font(.system(size: 12))
                    .foregroundStyle(.secondary)
            }
            Spacer()
            if selectedMintURL == mint.url.absoluteString {
                Image(systemName: "checkmark.circle.fill")
                    .foregroundColor(.orange)
            }
        }
        .contentShape(Rectangle())
        .onTapGesture {
            selectedMintURL = mint.url.absoluteString
        }
        .padding(.horizontal)
    }
    private var createInvoiceButton: some View {
        VStack {
            Divider()
            Button(action: createMintQuote) {
                if isMinting {
                    HStack {
                        ProgressView()
                            .scaleEffect(0.8)
                        Text("Creating...")
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.orange.opacity(0.3))
                    .foregroundColor(.orange)
                    .cornerRadius(12)
                } else {
                    Text("Create Invoice")
                        .frame(maxWidth: .infinity)
                        .fontWeight(.semibold)
                        .padding()
                        .background(Color.orange)
                        .foregroundColor(.white)
                        .cornerRadius(12)
                }
            }
            .disabled(!isValidAmount || isMinting)
            .padding()
        }
        .background(Color(.systemBackground))
    }
    // MARK: - Helper Functions
    private func setAmount(_ preset: Int) {
        amount = "\(preset)"
    }
    private func createMintQuote() {
        guard let amountInt = Int(amount),
              amountInt > 0,
              !selectedMintURL.isEmpty else { return }
        isMinting = true
        Task {
            do {
                // Request mint quote from the wallet
                guard let wallet = walletManager.wallet else {
                    throw WalletError.noActiveWallet
                }
                let quote = try await wallet.requestMint(
                    amount: Int64(amountInt),
                    mintURL: selectedMintURL
                )
                await MainActor.run {
                    mintQuote = quote
                    showInvoice = true
                    isMinting = false
                }
                // Start monitoring for deposit
                startDepositMonitoring(quote: quote)
            } catch {
                await MainActor.run {
                    errorMessage = error.localizedDescription
                    showError = true
                    isMinting = false
                }
            }
        }
    }
    private func startDepositMonitoring(quote: CashuMintQuote) {
        depositTask?.cancel()
        // Create manual check trigger stream
        let (triggerStream, continuation) = AsyncStream<Void>.makeStream()
        manualCheckContinuation = continuation
        depositTask = Task {
            do {
                guard let wallet = walletManager.wallet else { return }
                #if DEBUG
                // Check if we should simulate mint failure
                if appState.debugSimulateMintFailure {
                    // Wait a bit to simulate the payment being confirmed
                    try await Task.sleep(nanoseconds: 3_000_000_000) // 3 seconds
                    // Create a fake pending operation
                    let pendingOp = PendingMintOperation(
                        quoteId: quote.quoteId,
                        mintURL: quote.mintURL,
                        amount: quote.amount,
                        invoice: quote.invoice,
                        paymentProof: "debug_payment_proof_\(UUID().uuidString)",
                        createdAt: Date(),
                        lastAttemptAt: Date()
                    )
                    // Throw the mint failure error
                    throw DepositMintError.requiresUserIntervention(
                        pendingOperation: pendingOp,
                        invoice: quote.invoice
                    )
                }
                #endif
                let depositSequence = await wallet.monitorDeposit(
                    quote: quote,
                    manualCheckTrigger: triggerStream
                )
                for try await status in depositSequence {
                    switch status {
                    case .pending:
                        // Still waiting for payment
                        print("Deposit pending for quote: \(quote.quoteId)")
                    case .minted(let proofs):
                        // Success! Tokens have been minted
                        print("Successfully minted \(proofs.count) proofs")
                        // Calculate total amount from proofs
                        let totalAmount = proofs.reduce(0) { $0 + $1.amount }
                        await MainActor.run {
                            // Update wallet balance in UI
                            // The wallet manager already saved the proofs
                            mintedAmount = Int64(totalAmount)
                            showInvoice = false
                            showPaymentAnimation = true
                        }
                        return
                    case .expired:
                        await MainActor.run {
                            errorMessage = "Lightning invoice expired"
                            showError = true
                            showInvoice = false
                        }
                        return
                    case .cancelled:
                        return
                    }
                }
            } catch {
                await MainActor.run {
                    // Check if this is a mint failure error that needs user intervention
                    walletManager.handleMintFailureError(error)
                    // Still show the regular error
                    errorMessage = "Failed to monitor deposit: \(error.localizedDescription)"
                    showError = true
                    showInvoice = false
                }
            }
        }
    }
    private func checkMintStatus() {
        // This is called when the invoice view is shown
        // The actual monitoring is handled by startDepositMonitoring
    }
}
// MARK: - Invoice View
struct InvoiceView: View {
    let invoice: String
    let amount: Int
    let onPaid: () -> Void
    let onCheckNow: () -> Void
    @State private var copied = false
    @State private var isChecking = false
    @Environment(\.dismiss) private var dismiss
    var body: some View {
        NavigationStack {
            VStack(spacing: 30) {
                // Amount
                VStack(spacing: 8) {
                    Text("\(amount)")
                        .font(.system(size: 48, weight: .bold))
                    Text("sats")
                        .font(.title3)
                        .foregroundStyle(.secondary)
                }
                .padding(.top, 40)
                // QR Code
                QRCodeView(content: invoice)
                // Invoice text
                VStack(spacing: 12) {
                    Text(invoice)
                        .font(.system(.caption, design: .monospaced))
                        .lineLimit(3)
                        .truncationMode(.middle)
                        .padding()
                        .background(Color.secondary.opacity(0.2))
                        .cornerRadius(8)
                    Button(action: copyInvoice) {
                        Label(
                            copied ? "Copied!" : "Copy Invoice",
                            systemImage: copied ? "checkmark.circle.fill" : "doc.on.doc"
                        )
                    }
                    .buttonStyle(.bordered)
                    .tint(copied ? .green : .orange)
                }
                .padding(.horizontal)
                // Check Now button
                Button(action: checkNow) {
                    HStack {
                        if isChecking {
                            ProgressView()
                                .progressViewStyle(CircularProgressViewStyle())
                                .scaleEffect(0.8)
                        } else {
                            Image(systemName: "arrow.clockwise")
                        }
                        Text("Check Payment Status")
                    }
                }
                .buttonStyle(.borderedProminent)
                .tint(.orange)
                .disabled(isChecking)
                Spacer()
                // Status
                VStack(spacing: 16) {
                    ProgressView()
                    Text("Waiting for payment...")
                        .foregroundStyle(.secondary)
                }
                .padding(.bottom, 40)
            }
            .navigationTitle("Lightning Invoice")
            .platformNavigationBarTitleDisplayMode(inline: true)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { dismiss() }
                }
            }
        }
    }
    private func copyInvoice() {
        invoice.copyToPasteboard()
        withAnimation {
            copied = true
        }
        // Reset copied state after 2 seconds
        Task {
            try? await Task.sleep(nanoseconds: 2_000_000_000)
            await MainActor.run {
                withAnimation {
                    copied = false
                }
            }
        }
    }
    private func checkNow() {
        withAnimation {
            isChecking = true
        }
        // Trigger manual check
        onCheckNow()
        // Reset checking state after a brief delay
        Task {
            try? await Task.sleep(nanoseconds: 1_000_000_000) // 1 second
            await MainActor.run {
                withAnimation {
                    isChecking = false
                }
            }
        }
    }
}
</file>

<file path="Sources/NutsackiOS/Views/Wallet/NutzapView.swift">
import SwiftUI
import NDKSwift
enum PaymentMethod {
    case nutzap
    case lightning
}
struct NutzapView: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject private var nostrManager: NostrManager
    @Environment(WalletManager.self) private var walletManager
    let recipientPubkey: String?
    @State private var resolvedUser: NDKUser?
    @State private var recipientMetadata: NDKUserMetadata?
    @State private var amount = ""
    @State private var comment = ""
    @State private var isLoadingProfile = false
    @State private var isSending = false
    @State private var showError = false
    @State private var errorMessage = ""
    @State private var showSuccess = false
    @State private var acceptedMints: [String] = []
    @State private var availableBalance: Int = 0
    @State private var profileTask: Task<Void, Never>?
    @State private var supportsLightning = false
    @State private var paymentMethod: PaymentMethod = .nutzap
    @FocusState private var amountFieldFocused: Bool
    init(recipientPubkey: String? = nil) {
        self.recipientPubkey = recipientPubkey
    }
    var amountInt: Int {
        Int(amount) ?? 0
    }
    private var formattedAmount: String {
        if amount.isEmpty {
            return "0"
        }
        // Format with thousand separators
        if let number = Int(amount) {
            let formatter = NumberFormatter()
            formatter.numberStyle = .decimal
            formatter.groupingSeparator = ","
            return formatter.string(from: NSNumber(value: number)) ?? amount
        }
        return amount
    }
    private var isButtonDisabled: Bool {
        let hasNoUser = resolvedUser == nil
        let hasNoAmount = amount.isEmpty
        let hasInvalidAmount = amountInt <= 0
        let hasInsufficientBalance = (paymentMethod == .nutzap && amountInt > availableBalance)
        let isCurrentlySending = isSending
        let hasNoPaymentMethod = (!supportsLightning && acceptedMints.isEmpty)
        return hasNoUser || hasNoAmount || hasInvalidAmount || hasInsufficientBalance || isCurrentlySending || hasNoPaymentMethod
    }
    private func setAmount(_ preset: Int) {
        amount = "\(preset)"
    }
    // MARK: - View Components
    private var recipientSection: some View {
        Group {
            if let user = resolvedUser {
                VStack(spacing: 16) {
                    // Profile picture centered on top
                    UserProfilePicture(user: user, size: 80)
                    VStack(spacing: 4) {
                        // User name centered below avatar
                        UserDisplayName(user: user)
                            .font(.title2)
                            .fontWeight(.semibold)
                            .multilineTextAlignment(.center)
                        // NIP-05 or identifier below name
                        UserNIP05(user: user)
                            .font(.subheadline)
                            .foregroundStyle(.secondary)
                            .multilineTextAlignment(.center)
                    }
                }
                .frame(maxWidth: .infinity)
                .padding(.vertical, 8)
            } else if isLoadingProfile {
                VStack(spacing: 16) {
                    ProgressView()
                        .scaleEffect(1.2)
                    Text("Loading profile...")
                        .font(.subheadline)
                        .foregroundStyle(.secondary)
                }
                .frame(maxWidth: .infinity)
                .padding(.vertical, 32)
            }
        }
    }
    private var amountInputSection: some View {
        VStack(spacing: 16) {
            // Hidden text field that drives the amount
            TextField("0", text: $amount)
                .keyboardType(.numberPad)
                .opacity(0)
                .frame(height: 0)
                .focused($amountFieldFocused)
            // Visual amount display
            VStack(spacing: 8) {
                HStack(alignment: .firstTextBaseline, spacing: 8) {
                    Text(formattedAmount)
                        .font(.system(size: 48, weight: .semibold, design: .rounded))
                        .foregroundStyle(.primary)
                    Text("sats")
                        .font(.system(size: 20, weight: .medium, design: .rounded))
                        .foregroundStyle(.secondary)
                }
                .contentShape(Rectangle())
                .onTapGesture {
                    amountFieldFocused = true
                }
                // USD equivalent (placeholder)
                Text("≈ $0.00 USD")
                    .font(.system(size: 16, weight: .regular, design: .rounded))
                    .foregroundStyle(.secondary)
                    .opacity(0.6)
            }
            // Quick amount buttons
            HStack(spacing: 12) {
                ForEach(AmountPresets.nutzapAmounts, id: \.self) { preset in
                    Button(action: { setAmount(preset) }) {
                        Text("\(preset / 1000)k")
                            .font(.system(size: 14, weight: .medium, design: .rounded))
                            .foregroundColor(.orange)
                            .padding(.horizontal, 14)
                            .padding(.vertical, 6)
                            .background(Color.orange.opacity(0.15))
                            .cornerRadius(16)
                    }
                }
            }
        }
        .padding(.horizontal)
    }
    private var commentSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Comment")
                .font(.headline)
                .padding(.horizontal)
            TextField("Comment (optional)", text: $comment, axis: .vertical)
                .lineLimit(2...4)
                .padding(.horizontal)
        }
    }
    private var paymentMethodSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                if paymentMethod == .nutzap {
                    Image(systemName: "bitcoinsign.square.fill")
                        .foregroundColor(.orange)
                    Text("Zap")
                        .font(.headline)
                } else {
                    Image(systemName: "bolt.fill")
                        .foregroundColor(.yellow)
                    Text("Lightning")
                        .font(.headline)
                }
                Spacer()
            }
            .padding(.horizontal)
            if paymentMethod == .nutzap && !acceptedMints.isEmpty {
                VStack(alignment: .leading, spacing: 4) {
                    ForEach(acceptedMints, id: \.self) { mint in
                        Text(URL(string: mint)?.host ?? mint)
                            .font(.caption)
                            .foregroundStyle(.secondary)
                    }
                }
                .padding(.horizontal)
            }
        }
    }
    private var sendButton: some View {
        VStack {
            Divider()
            Button(action: sendPayment) {
                if isSending {
                    HStack {
                        ProgressView()
                            .scaleEffect(0.8)
                        Text("Sending...")
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.orange.opacity(0.3))
                    .foregroundColor(.orange)
                    .cornerRadius(12)
                } else {
                    HStack {
                        if paymentMethod == .nutzap {
                            Image(systemName: "bitcoinsign.square.fill")
                            Text("Zap")
                        } else {
                            Image(systemName: "bolt.fill")
                            Text("Send Lightning")
                        }
                    }
                    .frame(maxWidth: .infinity)
                    .fontWeight(.semibold)
                    .padding()
                    .background(paymentMethod == .nutzap ? Color.orange : Color.yellow)
                    .foregroundColor(paymentMethod == .nutzap ? .white : .black)
                    .cornerRadius(12)
                }
            }
            .disabled(isButtonDisabled)
            .padding()
        }
        .background(Color(.systemBackground))
        .frame(maxWidth: .infinity)
    }
    var body: some View {
        VStack(spacing: 0) {
            ScrollView {
                VStack(spacing: 24) {
                    recipientSection
                    amountInputSection
                    if resolvedUser != nil {
                        commentSection
                        paymentMethodSection
                    }
                }
                .padding(.vertical)
                .padding(.bottom, 120) // Add space for the fixed button and keyboard
            }
            sendButton
        }
        .navigationTitle("Zap")
        .platformNavigationBarTitleDisplayMode(inline: true)
        #if os(iOS)
        .ignoresSafeArea(.keyboard, edges: [])
        #endif
        .toolbar {
            ToolbarItem(placement: .confirmationAction) {
                Button("Zap") {
                    sendPayment()
                }
                .foregroundColor(.orange)
                .disabled(isButtonDisabled)
            }
        }
        .alert("Error", isPresented: $showError) {
            Button("OK") { }
        } message: {
            Text(errorMessage)
        }
        .sheet(isPresented: $showSuccess) {
            NutzapSuccessView(
                user: resolvedUser!,
                amount: amountInt
            ) {
                dismiss()
            }
        }
        .onAppear {
            loadBalance()
            // If a recipient pubkey was provided, resolve it
            if let pubkey = recipientPubkey {
                Task {
                    await resolveRecipient(pubkey: pubkey)
                }
            }
        }
        .onDisappear {
            profileTask?.cancel()
        }
    }
    private func resolveRecipient(pubkey: String) async {
        guard !pubkey.isEmpty else {
            await MainActor.run {
                resolvedUser = nil
                recipientMetadata = nil
            }
            return
        }
        await MainActor.run {
            isLoadingProfile = true
        }
        profileTask?.cancel()
        let ndk = nostrManager.ndk
        let user = NDKUser(pubkey: pubkey)
        await MainActor.run {
            resolvedUser = user
            isLoadingProfile = false
        }
        // Use profile manager to load metadata
        profileTask = Task {
            for await metadata in await ndk.profileManager.subscribe(for: pubkey, maxAge: 3600) {
                await MainActor.run {
                    self.recipientMetadata = metadata
                }
                break // Take first result
            }
        }
        // Load accepted mints and check Lightning support
        await loadAcceptedMints(for: pubkey)
        await checkLightningSupport(for: pubkey)
    }
    private func sendPayment() {
        guard let recipient = resolvedUser,
              amountInt > 0 else { return }
        let recipientPubkey = recipient.pubkey
        isSending = true
        // Show success immediately for better UX
        showSuccess = true
        Task {
            do {
                if paymentMethod == .nutzap && !acceptedMints.isEmpty {
                    // Convert accepted mints to URLs
                    let mintURLs = acceptedMints.compactMap { URL(string: $0) }
                    // This creates a pending transaction immediately
                    try await walletManager.sendNutzap(
                        to: recipientPubkey,
                        amount: Int64(amountInt),
                        comment: comment.isEmpty ? nil : comment,
                        acceptedMints: mintURLs
                    )
                } else if supportsLightning {
                    // Send Lightning zap (either chosen or fallback)
                    let ndk = nostrManager.ndk
                    let user = NDKUser(pubkey: recipientPubkey)
                    user.ndk = ndk
                    // For now, throw error as zap manager is not available
                    // TODO: Implement lightning zaps when NDKZapManager is available
                    throw ZapError.zapManagerNotAvailable
                } else {
                    // No payment method available
                    throw ZapError.zapManagerNotAvailable
                }
                // Keep success showing
                await MainActor.run {
                    isSending = false
                }
            } catch {
                await MainActor.run {
                    errorMessage = error.localizedDescription
                    showError = true
                    isSending = false
                    showSuccess = false  // Hide success on error
                }
            }
        }
    }
    private func loadAcceptedMints(for pubkey: String) async {
        let ndk = nostrManager.ndk
        // Fetch nutzap preferences event (kind 10019) - NIP-61
        let filter = NDKFilter(
            authors: [pubkey],
            kinds: [EventKind.nutzapPreferences]
        )
        // Use declarative data source to fetch preferences
        let preferencesDataSource = ndk.subscribe(
            filter: filter,
            maxAge: 3600,
            cachePolicy: .cacheWithNetwork
        )
        var events: [NDKEvent] = []
        let fetchTask = Task {
            for await event in preferencesDataSource.events {
                events.append(event)
                if events.count >= 1 {
                    break // Only need first event
                }
            }
        }
        // Wait a bit for the event
        try? await Task.sleep(nanoseconds: 2_000_000_000) // 2 seconds
        fetchTask.cancel()
        guard let preferencesEvent = events.first else {
            // If recipient has no nutzap preferences, they can't receive nutzaps
            await MainActor.run {
                acceptedMints = []
            }
            return
        }
        // Parse mints from event tags
        var mints: [String] = []
        for tag in preferencesEvent.tags where tag.count >= 2 && tag[0] == "mint" {
            mints.append(tag[1])
        }
        // Don't add fallback mints - recipient must have configured mints
        await MainActor.run {
            acceptedMints = mints
            // Determine payment method: prefer nutzap if mints available, otherwise lightning
            if !mints.isEmpty {
                paymentMethod = .nutzap
            } else if supportsLightning {
                paymentMethod = .lightning
            } else {
                paymentMethod = .nutzap // Will show error when trying to send
            }
        }
    }
    private func loadBalance() {
        Task {
            do {
                let balance = try await walletManager.wallet?.getBalance() ?? 0
                await MainActor.run {
                    availableBalance = Int(balance)
                }
            } catch {
                print("Failed to get balance: \(error)")
            }
        }
    }
    private func checkLightningSupport(for pubkey: String) async {
        guard let profileManager = nostrManager.profileManager else { return }
        // Use profile manager to fetch metadata
        var metadata: NDKUserMetadata?
        for await fetchedMetadata in await profileManager.subscribe(for: pubkey, maxAge: TimeConstants.hour) {
            metadata = fetchedMetadata
            break  // Only need the metadata once
        }
        await MainActor.run {
            supportsLightning = metadata?.lud16 != nil || metadata?.lud06 != nil
        }
    }
}
// MARK: - Errors
enum ZapError: LocalizedError {
    case zapManagerNotAvailable
    var errorDescription: String? {
        switch self {
        case .zapManagerNotAvailable:
            return "Zap manager is not available."
        }
    }
}
// MARK: - Nutzap Success View
struct NutzapSuccessView: View {
    let user: NDKUser
    let amount: Int
    let onDone: () -> Void
    @State private var animationScale = 0.5
    @State private var showBolt = false
    var body: some View {
        VStack(spacing: 30) {
            Spacer()
            // Animation
            ZStack {
                // Profile picture
                UserProfilePicture(user: user, size: 100)
                // Bolt overlay
                if showBolt {
                    Image(systemName: "bolt.heart.fill")
                        .font(.system(size: 50))
                        .foregroundStyle(.orange)
                        .scaleEffect(animationScale)
                        .transition(.scale.combined(with: .opacity))
                }
            }
            VStack(spacing: 8) {
                Text("Zapped!")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                HStack(spacing: 4) {
                    Text("\(amount) sats to")
                    UserDisplayName(user: user)
                }
                    .multilineTextAlignment(.center)
                    .font(.title3)
                    .foregroundStyle(.secondary)
                    .multilineTextAlignment(.center)
            }
            Spacer()
            Button(action: onDone) {
                Text("Done")
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.orange)
                    .foregroundColor(.white)
                    .cornerRadius(12)
            }
            .padding(.horizontal, 40)
            .padding(.bottom, 40)
        }
        .onAppear {
            withAnimation(.easeOut(duration: 0.3)) {
                showBolt = true
            }
            withAnimation(.easeOut(duration: 0.6).delay(0.1)) {
                animationScale = 1.2
            }
        }
    }
}
</file>

<file path="Sources/NutsackiOS/Views/Wallet/RecentTransactionsView.swift">
import SwiftUI
import NDKSwift
struct RecentTransactionsView: View {
    @Environment(WalletManager.self) private var walletManager
    var recentTransactions: [Transaction] {
        Array(walletManager.transactions.prefix(5))
    }
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            HStack {
                Text("Recent Activity")
                    .font(.headline)
                Spacer()
                NavigationLink(destination: TransactionHistoryView()) {
                    Text("See All")
                        .font(.caption)
                        .foregroundStyle(.orange)
                }
            }
            if recentTransactions.isEmpty {
                HStack {
                    Spacer()
                    VStack(spacing: 8) {
                        Image(systemName: "clock.arrow.circlepath")
                            .font(.title2)
                            .foregroundStyle(.secondary)
                        Text("No transactions yet")
                            .font(.caption)
                            .foregroundStyle(.secondary)
                    }
                    .padding(.vertical, 20)
                    Spacer()
                }
                .background(Color.secondary.opacity(0.1))
                .cornerRadius(12)
            } else {
                VStack(spacing: 8) {
                    ForEach(recentTransactions) { transaction in
                        TransactionRow(transaction: transaction)
                            .animation(.easeInOut(duration: 0.3), value: transaction.status)
                    }
                }
                .background(Color.secondary.opacity(0.1))
                .cornerRadius(12)
            }
        }
    }
}
struct TransactionRow: View {
    let transaction: Transaction
    @EnvironmentObject private var nostrManager: NostrManager
    @Environment(WalletManager.self) private var walletManager
    @State private var senderMetadata: NDKUserMetadata?
    @State private var recipientMetadata: NDKUserMetadata?
    @State private var showDetailDrawer = false
    @State private var mintInfo: NDKMintInfo?
    var icon: String {
        switch transaction.type {
        case .mint, .deposit: return "bolt.fill"
        case .melt, .withdraw: return "bolt"
        case .send: return "arrow.up"
        case .receive: return "arrow.down"
        case .nutzap: return "bolt.heart.fill"
        case .swap: return "arrow.2.circlepath"
        }
    }
    var color: Color {
        // Failed transactions should always show in red
        if transaction.status == .failed {
            return .red
        }
        switch transaction.type {
        case .mint, .deposit, .receive, .nutzap: return .green  // Nutzaps are received, so green
        case .melt, .withdraw, .send: return .orange
        case .swap: return .blue
        }
    }
    var sign: String {
        // Don't show a sign for failed transactions
        if transaction.status == .failed {
            return ""
        }
        switch transaction.direction {
        case .incoming: return "+"
        case .outgoing: return "-"
        case .neutral: return ""
        }
    }
    var displayText: String {
        if transaction.type == .nutzap {
            // For incoming nutzaps (received), show sender
            if transaction.direction == .incoming {
                if let senderMetadata = senderMetadata {
                    let senderName = senderMetadata.name ?? senderMetadata.displayName ?? "Anonymous"
                    return "Zap from \(senderName)"
                } else if let senderPubkey = transaction.senderPubkey {
                    return "Zap from \(senderPubkey.prefix(8))..."
                } else {
                    return "Zap received"
                }
            }
            // For outgoing nutzaps (sent), show recipient
            else if transaction.direction == .outgoing {
                if let recipientMetadata = recipientMetadata {
                    let recipientName = recipientMetadata.name ?? recipientMetadata.displayName ?? "Anonymous"
                    return "Zap to \(recipientName)"
                } else if let recipientPubkey = transaction.recipientPubkey {
                    return "Zap to \(recipientPubkey.prefix(8))..."
                } else {
                    return "Zap sent"
                }
            } else {
                return "Zap"
            }
        } else if let memo = transaction.memo {
            return memo
        } else {
            return transaction.type.displayName
        }
    }
    var body: some View {
        Button(action: { showDetailDrawer = true }) {
            HStack {
                // Avatar for nutzaps, icon for other transactions
                if transaction.type == .nutzap {
                    let metadata = transaction.direction == .incoming ? senderMetadata : recipientMetadata
                    let pubkey = transaction.direction == .incoming ? transaction.senderPubkey : transaction.recipientPubkey
                    if pubkey != nil {
                        ZStack {
                            // User avatar
                            AsyncImage(url: URL(string: metadata?.picture ?? "")) { image in
                                image
                                    .resizable()
                                    .aspectRatio(contentMode: .fill)
                            } placeholder: {
                                Circle()
                                    .fill(Color.secondary.opacity(0.3))
                                    .overlay(
                                        Image(systemName: "person.fill")
                                            .foregroundColor(.secondary)
                                    )
                            }
                            .frame(width: 30, height: 30)
                            .clipShape(Circle())
                    // Overlay icon based on status
                    if transaction.status == .failed {
                        // Failed icon
                        Image(systemName: "xmark.circle.fill")
                            .font(.caption)
                            .foregroundColor(.red)
                            .background(Circle().fill(.white).frame(width: 14, height: 14))
                            .offset(x: 10, y: -10)
                    } else {
                        // Normal zap icon
                        Image(systemName: "bolt.heart.fill")
                            .font(.caption2)
                            .foregroundColor(.yellow)
                            .background(Circle().fill(.white).frame(width: 12, height: 12))
                            .offset(x: 10, y: -10)
                    }
                        }
                        .frame(width: 30, height: 30)
                    } else {
                        // Fallback to icon if no pubkey
                        Image(systemName: icon)
                            .font(.body)
                            .foregroundStyle(color)
                            .frame(width: 30)
                    }
                } else {
                    Image(systemName: icon)
                        .font(.body)
                        .foregroundStyle(color)
                        .frame(width: 30)
                }
            VStack(alignment: .leading, spacing: 2) {
                Text(displayText)
                    .font(.subheadline)
                    .fontWeight(.medium)
                    .lineLimit(1)
                // Show mint info or nutzap comment or transaction type
                if let mintURL = transaction.mintURL {
                    HStack(spacing: 4) {
                        Image(systemName: "server.rack")
                            .font(.caption2)
                        Text(mintInfo?.name ?? URL(string: mintURL)?.host ?? mintURL)
                            .font(.caption)
                            .lineLimit(1)
                    }
                    .foregroundStyle(.secondary)
                } else if transaction.type == .nutzap && transaction.memo != nil && !transaction.memo!.isEmpty {
                    Text(transaction.memo!)
                        .font(.caption)
                        .foregroundStyle(.secondary)
                        .lineLimit(2)
                } else if transaction.memo != nil && transaction.type != .nutzap {
                    Text(transaction.type.displayName)
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }
            }
            Spacer()
            VStack(alignment: .trailing, spacing: 2) {
                HStack(spacing: 4) {
                    Text("\(sign)\(transaction.amount)")
                        .font(.subheadline)
                        .fontWeight(.medium)
                        .foregroundStyle(color)
                    // Show pending indicator
                    if transaction.status == .pending {
                        ProgressView()
                            .progressViewStyle(CircularProgressViewStyle())
                            .scaleEffect(0.7)
                            .frame(width: 16, height: 16)
                    }
                }
                RelativeTimeView(date: transaction.createdAt)
                    .font(.caption2)
                    .foregroundStyle(.secondary)
            }
            }
        }
        .buttonStyle(.plain)
        .padding(.horizontal, 12)
        .padding(.vertical, 8)
        .opacity(transaction.status == .pending ? 0.85 : (transaction.status == .failed ? 0.7 : 1.0))
        .sheet(isPresented: $showDetailDrawer) {
            TransactionDetailDrawer(transaction: transaction)
        }
        .task {
            // Fetch sender profile for incoming nutzaps
            if transaction.type == .nutzap,
               transaction.direction == .incoming,
               let senderPubkey = transaction.senderPubkey,
               let profileManager = nostrManager.profileManager {
                // Use profile manager for efficient fetching
                for await metadata in await profileManager.subscribe(for: senderPubkey, maxAge: TimeConstants.hour) {
                    senderMetadata = metadata
                    break  // Only need the metadata once
                }
            }
            // Fetch recipient profile for outgoing nutzaps
            if transaction.type == .nutzap,
               transaction.direction == .outgoing,
               let recipientPubkey = transaction.recipientPubkey,
               let profileManager = nostrManager.profileManager {
                // Use profile manager for efficient fetching
                for await metadata in await profileManager.subscribe(for: recipientPubkey, maxAge: TimeConstants.hour) {
                    recipientMetadata = metadata
                    break  // Only need the metadata once
                }
            }
            // Fetch mint info if we have a mint URL
            if let mintURL = transaction.mintURL,
               let wallet = walletManager.wallet,
               let url = URL(string: mintURL) {
                do {
                    mintInfo = try await wallet.mints.getMintInfo(url: url)
                } catch {
                    // Silently fail - we'll just show the URL
                    NDKLogger.log(.debug, category: .wallet, "Failed to fetch mint info for \(mintURL): \(error)")
                }
            }
        }
    }
}
// MARK: - Transaction History View
struct TransactionHistoryView: View {
    @Environment(WalletManager.self) private var walletManager
    @State private var selectedFilter: TransactionFilter = .all
    enum TransactionFilter: String, CaseIterable {
        case all = "All"
        case sent = "Sent"
        case received = "Received"
        func matches(_ transaction: Transaction) -> Bool {
            switch self {
            case .all: return true
            case .sent: return [.send, .melt, .withdraw, .swap].contains(transaction.type)
            case .received: return [.receive, .mint, .deposit, .nutzap].contains(transaction.type)
            }
        }
    }
    var filteredTransactions: [Transaction] {
        walletManager.transactions
            .filter { selectedFilter.matches($0) }
            .sorted { $0.createdAt > $1.createdAt }
    }
    var body: some View {
        List {
            // Filter picker
            Picker("Filter", selection: $selectedFilter) {
                ForEach(TransactionFilter.allCases, id: \.self) { filter in
                    Text(filter.rawValue).tag(filter)
                }
            }
            .pickerStyle(.segmented)
            .listRowBackground(Color.clear)
            .listRowInsets(EdgeInsets())
            // Transactions
            ForEach(filteredTransactions) { transaction in
                TransactionDetailRow(transaction: transaction)
            }
        }
        .navigationTitle("Transaction History")
        .platformNavigationBarTitleDisplayMode(inline: true)
        .listStyle(.plain)
    }
}
struct TransactionDetailRow: View {
    let transaction: Transaction
    @State private var showOfflineToken = false
    @State private var showDetailDrawer = false
    @State private var mintInfo: NDKMintInfo?
    @Environment(WalletManager.self) private var walletManager
    var body: some View {
        Button(action: { showDetailDrawer = true }) {
            VStack(alignment: .leading, spacing: 8) {
                TransactionRow(transaction: transaction)
            if transaction.status != .completed {
                HStack {
                    Image(systemName: "clock")
                        .font(.caption2)
                    Text(transaction.status.rawValue.capitalized)
                        .font(.caption2)
                }
                .foregroundStyle(.yellow)
                .padding(.horizontal, 12)
                .padding(.bottom, 4)
            }
            // Show mint info if available and not already shown in TransactionRow
            if let mintURL = transaction.mintURL,
               transaction.type != .nutzap || transaction.memo == nil || transaction.memo!.isEmpty {
                HStack(spacing: 4) {
                    Image(systemName: "server.rack")
                        .font(.caption2)
                    Text(mintInfo?.name ?? URL(string: mintURL)?.host ?? mintURL)
                        .font(.caption)
                }
                .foregroundStyle(.secondary)
                .padding(.horizontal, 12)
                .padding(.bottom, 4)
            }
            // Show offline token button if available
            if transaction.offlineToken != nil && transaction.type == .send {
                Button(action: { showOfflineToken = true }) {
                    HStack {
                        Image(systemName: "qrcode")
                            .font(.caption)
                        Text("View Token")
                            .font(.caption)
                    }
                    .foregroundStyle(.orange)
                }
                .padding(.horizontal, 12)
                .padding(.bottom, 4)
            }
            }
        }
        .buttonStyle(.plain)
        .listRowBackground(Color.secondary.opacity(0.1))
        .listRowInsets(EdgeInsets(top: 4, leading: 8, bottom: 4, trailing: 8))
        .sheet(isPresented: $showDetailDrawer) {
            TransactionDetailDrawer(transaction: transaction)
        }
        .sheet(isPresented: $showOfflineToken) {
            if let token = transaction.offlineToken {
                TokenConfirmationView(
                    token: token,
                    amount: transaction.amount,
                    memo: transaction.memo ?? "",
                    mintURL: transaction.mintURL.flatMap { URL(string: $0) },
                    isOfflineMode: true,
                    onDismiss: { }
                )
            }
        }
        .task {
            // Fetch mint info if we have a mint URL
            if let mintURL = transaction.mintURL,
               let wallet = walletManager.wallet,
               let url = URL(string: mintURL) {
                do {
                    mintInfo = try await wallet.mints.getMintInfo(url: url)
                } catch {
                    // Silently fail - we'll just show the URL
                }
            }
        }
    }
}
// Transaction.TransactionType extension moved to DataModels.swift
</file>

<file path="Sources/NutsackiOS/Views/Wallet/SwapView.swift">
import SwiftUI
import NDKSwift
struct SwapView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(WalletManager.self) private var walletManager
    @EnvironmentObject private var appState: AppState
    @State private var sourceMint: MintBalance?
    @State private var destinationMint: MintBalance?
    @State private var isSwapping = false
    @State private var showError = false
    @State private var errorMessage = ""
    @State private var showSuccess = false
    @State private var transferResult: TransferResult?
    @State private var mintBalances: [MintBalance] = []
    // Allocation slider
    @State private var allocationPercentage: Double = 50.0
    var transferAmount: Int64 {
        guard let source = sourceMint, let destination = destinationMint else { return 0 }
        let totalBalance = source.balance + destination.balance
        let targetSourceBalance = Int64(Double(totalBalance) * (allocationPercentage / 100.0))
        return source.balance - targetSourceBalance
    }
    var canSwap: Bool {
        guard let source = sourceMint else { return false }
        guard let destination = destinationMint else { return false }
        guard source.url != destination.url else { return false }
        guard transferAmount > 0 else { return false }
        guard source.balance >= transferAmount else { return false }
        guard !isSwapping else { return false }
        return true
    }
    @ViewBuilder
    var allocationSection: some View {
        if let source = sourceMint, let destination = destinationMint {
            Section {
                VStack(spacing: 16) {
                    // Visual representation
                    HStack {
                        VStack(alignment: .leading, spacing: 4) {
                            HStack {
                                Circle()
                                    .fill(.orange)
                                    .frame(width: 8, height: 8)
                                Text(source.displayName)
                                    .font(.caption)
                                    .fontWeight(.medium)
                            }
                            Text("\(Int64(Double(source.balance + destination.balance) * (allocationPercentage / 100.0))) sats")
                                .font(.title2)
                                .fontWeight(.bold)
                        }
                        Spacer()
                        // Flow arrow
                        VStack {
                            Image(systemName: "arrow.right")
                                .font(.title2)
                                .foregroundStyle(.secondary)
                            Text("\(abs(transferAmount)) sats")
                                .font(.caption)
                                .foregroundStyle(.orange)
                        }
                        Spacer()
                        VStack(alignment: .trailing, spacing: 4) {
                            HStack {
                                Text(destination.displayName)
                                    .font(.caption)
                                    .fontWeight(.medium)
                                Circle()
                                    .fill(.blue)
                                    .frame(width: 8, height: 8)
                            }
                            Text("\(Int64(Double(source.balance + destination.balance) * ((100.0 - allocationPercentage) / 100.0))) sats")
                                .font(.title2)
                                .fontWeight(.bold)
                        }
                    }
                    // Allocation slider
                    VStack(spacing: 8) {
                        HStack {
                            Text("0%")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                            Spacer()
                            Text("\(Int(allocationPercentage))% / \(100 - Int(allocationPercentage))%")
                                .font(.caption)
                                .fontWeight(.medium)
                            Spacer()
                            Text("100%")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                        }
                        Slider(value: $allocationPercentage, in: 0...100, step: 1)
                            .tint(.orange)
                    }
                }
            } header: {
                Text("Balance Allocation")
            } footer: {
                if transferAmount != 0 {
                    Text("Transfer \(abs(transferAmount)) sats between mints")
                } else {
                    Text("Balances are already allocated as desired")
                }
            }
        }
    }
    @ViewBuilder
    var mintPickerSection: some View {
        Section {
            HStack(spacing: 16) {
                // Source mint selector
                Menu {
                    ForEach(mintBalances.filter { $0.balance > 0 }, id: \.url) { mintBalance in
                        Button(action: { sourceMint = mintBalance }) {
                            HStack {
                                Text(mintBalance.displayName)
                                Spacer()
                                Text("\(mintBalance.balance) sats")
                                    .foregroundStyle(.secondary)
                            }
                        }
                    }
                } label: {
                    VStack(spacing: 8) {
                        Circle()
                            .fill(.orange)
                            .frame(width: 40, height: 40)
                            .overlay {
                                Image(systemName: "building.columns")
                                    .foregroundStyle(.white)
                            }
                        Text(sourceMint?.displayName ?? "Select Mint")
                            .font(.caption)
                            .lineLimit(1)
                        if let source = sourceMint {
                            Text("\(source.balance) sats")
                                .font(.caption2)
                                .foregroundStyle(.secondary)
                        }
                    }
                    .frame(maxWidth: .infinity)
                }
                .buttonStyle(.plain)
                // Swap button
                Button(action: swapMints) {
                    Image(systemName: "arrow.left.arrow.right")
                        .font(.body)
                        .foregroundStyle(.secondary)
                }
                .disabled(sourceMint == nil || destinationMint == nil)
                // Destination mint selector
                Menu {
                    ForEach(mintBalances, id: \.url) { mintBalance in
                        Button(action: { destinationMint = mintBalance }) {
                            HStack {
                                Text(mintBalance.displayName)
                                Spacer()
                                Text("\(mintBalance.balance) sats")
                                    .foregroundStyle(.secondary)
                            }
                        }
                    }
                } label: {
                    VStack(spacing: 8) {
                        Circle()
                            .fill(.blue)
                            .frame(width: 40, height: 40)
                            .overlay {
                                Image(systemName: "building.columns")
                                    .foregroundStyle(.white)
                            }
                        Text(destinationMint?.displayName ?? "Select Mint")
                            .font(.caption)
                            .lineLimit(1)
                        if let destination = destinationMint {
                            Text("\(destination.balance) sats")
                                .font(.caption2)
                                .foregroundStyle(.secondary)
                        }
                    }
                    .frame(maxWidth: .infinity)
                }
                .buttonStyle(.plain)
            }
            .padding(.vertical, 8)
        } header: {
            Text("Select Mints")
        }
    }
    @ViewBuilder
    var actionSection: some View {
        Section {
            Button(action: performSwap) {
                if isSwapping {
                    ProgressView()
                        .frame(maxWidth: .infinity)
                } else {
                    Text("Transfer")
                        .frame(maxWidth: .infinity)
                }
            }
            .disabled(!canSwap)
        }
    }
    var body: some View {
        Form {
            mintPickerSection
            allocationSection
            actionSection
        }
        .navigationTitle("Balance Reconcile")
        .platformNavigationBarTitleDisplayMode(inline: true)
        .toolbar {
            ToolbarItem(placement: .cancellationAction) {
                Button("Cancel") { dismiss() }
            }
        }
        .alert("Error", isPresented: $showError) {
            Button("OK") { }
        } message: {
            Text(errorMessage)
        }
        .alert("Transfer Successful", isPresented: $showSuccess) {
            Button("OK") { dismiss() }
        } message: {
            if let result = transferResult {
                Text("Transferred \(result.amountTransferred) sats\nFee paid: \(result.feePaid) sats")
            }
        }
        .onChange(of: sourceMint) { _, _ in
            updateAllocationPercentage()
        }
        .onChange(of: destinationMint) { _, _ in
            updateAllocationPercentage()
        }
        .onAppear {
            loadMintBalances()
        }
    }
    private func swapMints() {
        let temp = sourceMint
        sourceMint = destinationMint
        destinationMint = temp
    }
    private func updateAllocationPercentage() {
        guard let source = sourceMint, let destination = destinationMint else { return }
        let totalBalance = source.balance + destination.balance
        if totalBalance > 0 {
            allocationPercentage = Double(source.balance) / Double(totalBalance) * 100.0
        }
    }
    private func performSwap() {
        guard canSwap else { return }
        let actualTransferAmount = abs(transferAmount)
        let actualSource = transferAmount > 0 ? sourceMint! : destinationMint!
        let actualDestination = transferAmount > 0 ? destinationMint! : sourceMint!
        isSwapping = true
        Task {
            do {
                #if DEBUG
                // Check if we should simulate mint failure
                if appState.debugSimulateMintFailure {
                    // Wait a bit to simulate the payment being processed
                    try await Task.sleep(nanoseconds: 2_000_000_000) // 2 seconds
                    // Create a fake pending operation
                    let pendingOp = PendingMintOperation(
                        quoteId: "debug_quote_\(UUID().uuidString)",
                        mintURL: actualDestination.url.absoluteString,
                        amount: actualTransferAmount,
                        invoice: "lnbc\(actualTransferAmount)...",
                        paymentProof: "debug_payment_proof_\(UUID().uuidString)",
                        createdAt: Date(),
                        lastAttemptAt: Date()
                    )
                    // Throw the mint failure error
                    throw MintFailureError.requiresUserIntervention(
                        pendingOperation: pendingOp,
                        sourceMint: actualSource.url.absoluteString,
                        destinationMint: actualDestination.url.absoluteString,
                        amount: actualTransferAmount,
                        paymentProof: "debug_payment_proof_\(UUID().uuidString)"
                    )
                }
                #endif
                let result = try await walletManager.transferBetweenMints(
                    amount: actualTransferAmount,
                    fromMint: actualSource.url,
                    toMint: actualDestination.url
                )
                await MainActor.run {
                    transferResult = result
                    showSuccess = true
                    isSwapping = false
                }
            } catch {
                await MainActor.run {
                    // Check if this is a mint failure error that needs user intervention
                    walletManager.handleMintFailureError(error)
                    // Still show the regular error
                    errorMessage = error.localizedDescription
                    showError = true
                    isSwapping = false
                }
            }
        }
    }
    private func loadMintBalances() {
        Task {
            guard let wallet = walletManager.wallet else { return }
            // Get balances by mint from the wallet
            let balancesByMint = await wallet.getBalancesByMint()
            // Create MintBalance objects
            let loadedMintBalances = balancesByMint.map { (mintUrl, balance) in
                MintBalance(url: URL(string: mintUrl)!, balance: balance)
            }.sorted { $0.balance > $1.balance } // Sort by balance descending
            await MainActor.run {
                mintBalances = loadedMintBalances
                // Auto-select the two mints with highest balances
                if mintBalances.count >= 2 {
                    sourceMint = mintBalances[0]
                    destinationMint = mintBalances[1]
                    updateAllocationPercentage()
                } else if mintBalances.count == 1 {
                    sourceMint = mintBalances[0]
                }
            }
        }
    }
}
// MARK: - Supporting Types
struct MintBalance: Hashable {
    let url: URL
    let balance: Int64
    var displayName: String {
        url.host ?? url.absoluteString
    }
}
</file>

<file path="Sources/NutsackiOS/Views/Wallet/TransactionDetailDrawer.swift">
import SwiftUI
import NDKSwift
import CashuSwift
#if os(iOS)
import UIKit
#endif
struct TransactionDetailDrawer: View {
    let transaction: Transaction
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject private var nostrManager: NostrManager
    @Environment(WalletManager.self) private var walletManager
    @State private var senderMetadata: NDKUserMetadata?
    @State private var recipientMetadata: NDKUserMetadata?
    @State private var showTokenDetail = false
    @State private var showShareSheet = false
    @State private var copiedToClipboard = false
    @State private var copiedBech32 = false
    @State private var mintInfo: NDKMintInfo?
    @State private var loadedNostrEvent: NDKEvent?
    private var formattedDate: String {
        DateFormatters.display.string(from: transaction.createdAt)
    }
    private var statusColor: Color {
        switch transaction.status {
        case .completed: return .green
        case .pending, .processing: return .orange
        case .failed, .expired: return .red
        }
    }
    private var directionIcon: String {
        switch transaction.direction {
        case .incoming: return "arrow.down.circle.fill"
        case .outgoing: return "arrow.up.circle.fill"
        case .neutral: return "arrow.2.circlepath.circle.fill"
        }
    }
    private var directionColor: Color {
        switch transaction.direction {
        case .incoming: return .green
        case .outgoing: return .orange
        case .neutral: return .blue
        }
    }
    private var headerView: some View {
        VStack(spacing: 16) {
            // For Nutzaps, show the user avatar prominently
            if transaction.type == .nutzap {
                let metadata = transaction.direction == .incoming ? senderMetadata : recipientMetadata
                let pubkey = transaction.direction == .incoming ? transaction.senderPubkey : transaction.recipientPubkey
                if let pubkey = pubkey {
                    VStack(spacing: 12) {
                        // User avatar
                        UserProfilePicture(pubkey: pubkey, size: 80)
                        .overlay(
                            // Direction indicator
                            Image(systemName: transaction.direction == .incoming ? "arrow.down.circle.fill" : "arrow.up.circle.fill")
                                .font(.title2)
                                .foregroundStyle(directionColor)
                                .background(Circle().fill(.white).frame(width: 30, height: 30))
                                .offset(x: 25, y: 25)
                        )
                        // User name
                        VStack(spacing: 4) {
                            Text(transaction.direction == .incoming ? "From" : "To")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                            if let metadata = metadata {
                                Text(metadata.name ?? metadata.displayName ?? "Anonymous")
                                    .font(.title3)
                                    .fontWeight(.semibold)
                            } else {
                                Text(pubkey.prefix(16) + "...")
                                    .font(.title3)
                                    .fontWeight(.semibold)
                                    .font(.system(.body, design: .monospaced))
                            }
                        }
                    }
                }
            } else {
                // Regular transaction icon
                Image(systemName: directionIcon)
                    .font(.system(size: 50))
                    .foregroundStyle(directionColor)
            }
            // Amount
            Text("\(transaction.direction == .outgoing ? "-" : "+")\(transaction.amount) sats")
                .font(.largeTitle)
                .fontWeight(.bold)
                .foregroundStyle(directionColor)
            // Transaction Type
            Text(transaction.type.displayName)
                .font(.headline)
                .foregroundStyle(.secondary)
        }
    }
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(alignment: .leading, spacing: 20) {
                    headerView
                        .frame(maxWidth: .infinity)
                        .padding(.vertical)
                    // Transaction Details
                    VStack(alignment: .leading, spacing: 16) {
                        // Status
                        TransactionInfoRow(
                            label: "Status",
                            value: transaction.status.rawValue.capitalized,
                            valueColor: statusColor,
                            icon: statusIcon(for: transaction.status)
                        )
                        // Error details for failed transactions
                        if transaction.status == .failed, let errorDetails = transaction.errorDetails {
                            TransactionInfoRow(
                                label: "Error",
                                value: errorDetails,
                                valueColor: .red,
                                icon: "exclamationmark.triangle",
                                multiline: true
                            )
                        }
                        // Date and Time
                        TransactionInfoRow(
                            label: "Date",
                            value: formattedDate,
                            icon: "calendar"
                        )
                        // Memo/Description
                        if let memo = transaction.memo, !memo.isEmpty {
                            TransactionInfoRow(
                                label: "Memo",
                                value: memo,
                                icon: "text.alignleft",
                                multiline: true
                            )
                        }
                        // Mint URL
                        if let mintURL = transaction.mintURL {
                            TransactionInfoRow(
                                label: "Mint",
                                value: mintInfo?.name ?? URL(string: mintURL)?.host ?? mintURL,
                                icon: "server.rack",
                                action: {
                                    if let url = URL(string: mintURL) {
                                        #if os(iOS)
                                        UIApplication.shared.open(url)
                                        #endif
                                    }
                                }
                            )
                            // Show mint description if available
                            if let description = mintInfo?.description, !description.isEmpty {
                                TransactionInfoRow(
                                    label: "Mint Info",
                                    value: description,
                                    icon: "info.circle",
                                    multiline: true
                                )
                            }
                        }
                        // Lightning Invoice
                        if let invoice = transaction.lightningInvoice {
                            TransactionInfoRow(
                                label: "Lightning Invoice",
                                value: String(invoice.prefix(20)) + "...",
                                icon: "bolt",
                                action: {
                                    #if os(iOS)
                                    UIPasteboard.general.string = invoice
                                    #endif
                                    withAnimation {
                                        copiedToClipboard = true
                                    }
                                    DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                                        copiedToClipboard = false
                                    }
                                }
                            )
                            if copiedToClipboard {
                                Text("Copied to clipboard!")
                                    .font(.caption)
                                    .foregroundStyle(.green)
                                    .transition(.opacity)
                            }
                        }
                        // Nostr Event
                        if transaction.nostrEventID != nil {
                            HStack {
                                TransactionInfoRow(
                                    label: "Nostr Event",
                                    value: "View event details",
                                    icon: "link"
                                )
                                Spacer()
                                HStack(spacing: 12) {
                                    // Copy button
                                    if let event = loadedNostrEvent,
                                       let bech32 = try? event.encode(includeRelays: true) {
                                        Button(action: {
                                            #if os(iOS)
                                            UIPasteboard.general.string = bech32
                                            #endif
                                            withAnimation {
                                                copiedBech32 = true
                                            }
                                            DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                                                copiedBech32 = false
                                            }
                                        }) {
                                            Image(systemName: copiedBech32 ? "checkmark.circle.fill" : "doc.on.doc")
                                                .foregroundColor(copiedBech32 ? .green : .accentColor)
                                        }
                                        .buttonStyle(.plain)
                                        // Open in njump.me button
                                        Button(action: {
                                            if let url = URL(string: "https://njump.me/\(bech32)") {
                                                #if os(iOS)
                                                UIApplication.shared.open(url)
                                                #endif
                                            }
                                        }) {
                                            Image(systemName: "arrow.up.forward.square")
                                                .foregroundColor(.accentColor)
                                        }
                                        .buttonStyle(.plain)
                                    }
                                }
                            }
                            if copiedBech32 {
                                Text("Copied to clipboard!")
                                    .font(.caption)
                                    .foregroundStyle(.green)
                                    .transition(.opacity)
                                    .padding(.horizontal)
                            }
                        }
                    }
                    .padding()
                    .background(Color(.secondarySystemGroupedBackground))
                    .cornerRadius(12)
                    // Action Buttons
                    VStack(spacing: 12) {
                        // View Token Button
                        if transaction.offlineToken != nil && (transaction.type == .send || transaction.type == .receive) {
                            Button(action: { showTokenDetail = true }) {
                                Label("View Token", systemImage: "qrcode")
                                    .frame(maxWidth: .infinity)
                            }
                            .buttonStyle(.borderedProminent)
                            .controlSize(.large)
                        }
                        // Share Transaction Button
                        Button(action: { showShareSheet = true }) {
                            Label("Share Transaction", systemImage: "square.and.arrow.up")
                                .frame(maxWidth: .infinity)
                        }
                        .buttonStyle(.bordered)
                        .controlSize(.large)
                    }
                    .padding(.horizontal)
                }
                .padding(.vertical)
            }
            .navigationTitle("Transaction Details")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
        }
        .task {
            await loadProfiles()
        }
        .sheet(isPresented: $showTokenDetail) {
            if let token = transaction.offlineToken {
                TokenConfirmationView(
                    token: token,
                    amount: transaction.amount,
                    memo: transaction.memo ?? "",
                    mintURL: transaction.mintURL.flatMap { URL(string: $0) },
                    isOfflineMode: true,
                    onDismiss: { }
                )
            }
        }
        #if os(iOS)
        .sheet(isPresented: $showShareSheet) {
            ShareSheet(items: [transactionShareText()])
        }
        #endif
    }
    private func statusIcon(for status: Transaction.TransactionStatus) -> String {
        switch status {
        case .completed: return "checkmark.circle.fill"
        case .pending: return "clock.fill"
        case .processing: return "arrow.trianglehead.2.clockwise"
        case .failed: return "xmark.circle.fill"
        case .expired: return "exclamationmark.triangle.fill"
        }
    }
    private func loadProfiles() async {
        let ndk = nostrManager.ndk
        guard let profileManager = nostrManager.profileManager else { return }
        // Load Nostr event if we have an event ID
        if let eventID = transaction.nostrEventID {
            let eventDataSource = ndk.subscribe(
                filter: NDKFilter(
                    ids: [eventID]
                ),
                maxAge: 3600,
                cachePolicy: .cacheWithNetwork
            )
            for await event in eventDataSource.events {
                loadedNostrEvent = event
                break
            }
        }
        // Load sender metadata
        if let senderPubkey = transaction.senderPubkey {
            for await metadata in await profileManager.subscribe(for: senderPubkey, maxAge: TimeConstants.hour) {
                senderMetadata = metadata
                break
            }
        }
        // Load recipient metadata
        if let recipientPubkey = transaction.recipientPubkey {
            for await metadata in await profileManager.subscribe(for: recipientPubkey, maxAge: TimeConstants.hour) {
                recipientMetadata = metadata
                break
            }
        }
        // Load mint info
        if let mintURL = transaction.mintURL,
           let wallet = walletManager.wallet,
           let url = URL(string: mintURL) {
            do {
                mintInfo = try await wallet.mints.getMintInfo(url: url)
            } catch {
                // Silently fail - we'll just show the URL
                NDKLogger.log(.debug, category: .wallet, "Failed to fetch mint info for \(mintURL): \(error)")
            }
        }
    }
    private func transactionShareText() -> String {
        var text = "Transaction Details\n"
        text += "==================\n\n"
        text += "Type: \(transaction.type.displayName)\n"
        text += "Amount: \(transaction.amount) sats\n"
        text += "Status: \(transaction.status.rawValue.capitalized)\n"
        text += "Date: \(formattedDate)\n"
        if let memo = transaction.memo, !memo.isEmpty {
            text += "Memo: \(memo)\n"
        }
        if let eventID = transaction.nostrEventID {
            text += "\nNostr Event ID: \(eventID)\n"
            if let event = loadedNostrEvent,
               let bech32 = try? event.encode(includeRelays: true) {
                text += "Bech32 Event: \(bech32)\n"
                text += "View on njump.me: https://njump.me/\(bech32)\n"
            }
        }
        return text
    }
}
// MARK: - Supporting Views
struct TransactionInfoRow: View {
    let label: String
    let value: String
    var valueColor: Color = .primary
    var icon: String?
    var multiline: Bool = false
    var action: (() -> Void)?
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Label(label, systemImage: icon ?? "info.circle")
                .font(.caption)
                .foregroundStyle(.secondary)
            if let action = action {
                Button(action: action) {
                    Text(value)
                        .font(.body)
                        .foregroundStyle(valueColor)
                        .multilineTextAlignment(multiline ? .leading : .trailing)
                        .lineLimit(multiline ? nil : 1)
                }
                .buttonStyle(.plain)
            } else {
                Text(value)
                    .font(.body)
                    .foregroundStyle(valueColor)
                    .multilineTextAlignment(multiline ? .leading : .trailing)
                    .lineLimit(multiline ? nil : 1)
            }
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }
}
struct ProfileDetailRow: View {
    let label: String
    let pubkey: String
    let metadata: NDKUserMetadata?
    private var displayName: String {
        if let metadata = metadata {
            return metadata.name ?? metadata.displayName ?? pubkey.prefix(16) + "..."
        }
        return pubkey.prefix(16) + "..."
    }
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Label(label, systemImage: "person.fill")
                .font(.caption)
                .foregroundStyle(.secondary)
            HStack {
                UserProfilePicture(pubkey: pubkey, size: 24)
                Text(displayName)
                    .font(.body)
                    .lineLimit(1)
            }
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }
}
</file>

<file path="Sources/NutsackiOS/Views/Wallet/WalletSettingsView.swift">
import SwiftUI
import NDKSwift
import CashuSwift
struct WalletSettingsView: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject private var nostrManager: NostrManager
    @Environment(WalletManager.self) private var walletManager
    @EnvironmentObject private var appState: AppState
    @State private var mints: [MintInfo] = []
    @State private var relays: [String] = []
    @State private var hasWalletInfo = false
    @State private var isLoading = true
    @State private var isSaving = false
    @State private var showError = false
    @State private var errorMessage = ""
    @State private var showAddMintSheet = false
    @State private var showAddRelaySheet = false
    @State private var showDiscoveredMints = false
    @State private var discoveryTask: Task<Void, Never>?
    // Wallet warning section
    @ViewBuilder
    private var walletWarningSection: some View {
        if !hasWalletInfo && walletManager.wallet != nil {
            Section {
                HStack {
                    Image(systemName: "exclamationmark.triangle")
                        .foregroundColor(.orange)
                        .font(.caption)
                    Text("Wallet not published - tap to sync across devices")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Spacer()
                }
                .contentShape(Rectangle())
                .onTapGesture {
                    Task { await saveSettings() }
                }
            }
        }
    }
    // Mints section
    @ViewBuilder
    private var mintsSection: some View {
        Section {
            if mints.isEmpty {
                VStack(spacing: 16) {
                    ContentUnavailableView(
                        "No Mints Configured",
                        systemImage: "building.columns",
                        description: Text("Add mints to start using ecash")
                    )
                    .scaleEffect(0.85)
                    HStack(spacing: 12) {
                        Button(action: { showAddMintSheet = true }) {
                            Label("Add URL", systemImage: "link")
                        }
                        .buttonStyle(.bordered)
                        .controlSize(.regular)
                        Button(action: discoverMints) {
                            Label("Discover", systemImage: "sparkle.magnifyingglass")
                        }
                        .buttonStyle(.borderedProminent)
                        .controlSize(.regular)
                    }
                }
            } else {
                ForEach(mints, id: \.url.absoluteString) { mint in
                    NavigationLink(destination: MintDetailView(mintURL: mint.url.absoluteString)) {
                        MintSettingsRow(mintInfo: mint) {
                            mints.removeAll { $0.url == mint.url }
                        }
                    }
                    .buttonStyle(.plain)
                    .padding(.leading, 2)
                }
            }
        } header: {
            mintsSectionHeader
        }
    }
    // Mints section header
    @ViewBuilder
    private var mintsSectionHeader: some View {
        HStack {
            Text("MINTS")
                .font(.caption)
                .foregroundColor(.secondary)
                .textCase(.none)
            Spacer()
            Menu {
                Button(action: { showAddMintSheet = true }) {
                    Label("Add by URL", systemImage: "link")
                }
                Button(action: discoverMints) {
                    Label("Discover Mints", systemImage: "sparkle.magnifyingglass")
                }
            } label: {
                Image(systemName: "plus")
                    .font(.caption)
                    .foregroundColor(.accentColor)
            }
        }
    }
    // Relays section
    @ViewBuilder
    private var relaysSection: some View {
        Section {
            if relays.isEmpty {
                ContentUnavailableView(
                    "No Relays Configured",
                    systemImage: "antenna.radiowaves.left.and.right",
                    description: Text("Add relays to sync your wallet data")
                )
                .scaleEffect(0.85)
            } else {
                ForEach(relays, id: \.self) { relay in
                    RelaySettingsRow(relayURL: relay) {
                        relays.removeAll { $0 == relay }
                    }
                }
            }
        } header: {
            HStack {
                Text("WALLET RELAYS")
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .textCase(.none)
                Spacer()
                Button(action: { showAddRelaySheet = true }) {
                    Image(systemName: "plus.circle")
                        .font(.footnote)
                }
            }
        } footer: {
            Text("These relays will be used to sync your wallet events and mint lists")
                .font(.caption2)
                .foregroundColor(.secondary.opacity(0.7))
                .padding(.top, -6)
        }
    }
    var body: some View {
        NavigationStack {
            Form {
                walletWarningSection
                mintsSection
                relaysSection
            }
            .formStyle(.grouped)
            .navigationTitle("Wallet Settings")
            .platformNavigationBarTitleDisplayMode(inline: true)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { dismiss() }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Save") {
                        Task { await saveSettings() }
                    }
                    .fontWeight(.bold)
                    .tint(.blue)
                    .disabled(isSaving)
                }
            }
            .sheet(isPresented: $showAddMintSheet) {
                AddMintSheet { url in
                    print("DEBUG: AddMintSheet callback - adding mint URL: \(url)")
                    print("DEBUG: Current mints before addition: \(mints.map { $0.url.absoluteString })")
                    do {
                        let mintInfo = try await fetchMintInfo(url: url)
                        mints.append(mintInfo)
                        print("DEBUG: Successfully added mint with info: \(mintInfo.name ?? "Unknown")")
                    } catch {
                        // Still add the mint even if we can't fetch info
                        // This allows users to add mints that might be temporarily down
                        let fallbackMintInfo = MintInfo(
                            url: url,
                            name: url.host ?? "Unknown Mint"
                        )
                        mints.append(fallbackMintInfo)
                        print("DEBUG: Added mint with fallback info due to error: \(error)")
                        // Show error but don't prevent mint addition
                        errorMessage = "Note: Could not fetch mint details (\(error.localizedDescription)). Mint added with basic info."
                        showError = true
                    }
                    print("DEBUG: Mints after addition: \(mints.map { $0.url.absoluteString })")
                    print("DEBUG: Total mints count: \(mints.count)")
                }
            }
            .sheet(isPresented: $showAddRelaySheet) {
                AddRelaySheet { relay in
                    if !relays.contains(relay) {
                        relays.append(relay)
                    }
                }
            }
            .sheet(isPresented: $showDiscoveredMints) {
                DiscoveredMintsSheet(discoveryTask: discoveryTask) { selectedMints in
                    for mint in selectedMints {
                        // Skip if blacklisted
                        if appState.isMintBlacklisted(mint.url) {
                            continue
                        }
                        if !mints.contains(where: { $0.url.absoluteString == mint.url }) {
                            // Note: mint.url should already be validated by MintDiscoveryManager
                            // but we double-check here for safety
                            let trimmedURL = mint.url.trimmingCharacters(in: .whitespacesAndNewlines)
                            if let url = URL(string: trimmedURL),
                               url.scheme != nil,
                               url.host != nil {
                                do {
                                    let mintInfo = try await fetchMintInfo(url: url)
                                    mints.append(mintInfo)
                                } catch {
                                    // Still add the mint with basic info
                                    let fallbackMintInfo = MintInfo(
                                        url: url,
                                        name: mint.name.isEmpty ? (url.host ?? "Unknown Mint") : mint.name
                                    )
                                    mints.append(fallbackMintInfo)
                                }
                            }
                        }
                    }
                }
            }
            .alert("Error", isPresented: $showError) {
                Button("OK") { }
            } message: {
                Text(errorMessage)
            }
            .task {
                await loadCurrentSettings()
            }
        }
    }
    private func loadCurrentSettings() async {
        isLoading = true
        print("DEBUG: loadCurrentSettings() called")
        // Load current configuration directly from the wallet
        if let wallet = walletManager.wallet {
            // Get mints from the wallet's mint manager, filtering out blacklisted ones
            let mintURLs = await wallet.mints.getMintURLs()
            print("DEBUG: Loaded mint URLs from wallet: \(mintURLs)")
            let mintURLObjects = mintURLs
                .filter { !appState.isMintBlacklisted($0) }
                .compactMap { URL(string: $0) }
            mints = mintURLObjects.map { MintInfo(url: $0, name: $0.host ?? "Unknown Mint") }
            print("DEBUG: Loaded \(mints.count) mints after filtering: \(mints.map { $0.url.absoluteString })")
            // Get relays from the wallet's configuration
            relays = await wallet.walletConfigRelays
            // Check if wallet info exists
            hasWalletInfo = await checkWalletInfo()
        }
        isLoading = false
    }
    private func checkWalletInfo() async -> Bool {
        let ndk = nostrManager.ndk
        guard let pubkey = try? await ndk.signer?.pubkey else { return false }
        let filter = NDKFilter(
            authors: [pubkey],
            kinds: [17375]
        )
        // Use declarative data source to check if user has published wallet events
        let dataSource = ndk.subscribe(
            filter: filter,
            maxAge: 3600,
            cachePolicy: .cacheWithNetwork
        )
        for await _ in dataSource.events {
            return true // Found at least one event
        }
        return false
    }
    private func fetchMintInfo(url: URL) async throws -> MintInfo {
        // Use wallet's mint manager to fetch proper mint info
        if let wallet = walletManager.wallet {
            do {
                let ndkMintInfo = try await wallet.mints.getMintInfo(url: url)
                // Convert NDKMintInfo to local MintInfo
                return MintInfo(
                    url: url,
                    name: ndkMintInfo.name ?? url.host ?? "Unknown Mint"
                )
            } catch {
                // Fallback to basic info if fetch fails
                return MintInfo(url: url, name: url.host ?? "Unknown Mint")
            }
        } else {
            // No active wallet, use basic info
            return MintInfo(url: url, name: url.host ?? "Unknown Mint")
        }
    }
    private func saveSettings() async {
        isSaving = true
        do {
            guard let wallet = walletManager.wallet else {
                throw WalletError.noActiveWallet
            }
            // Debug logging
            print("DEBUG: saveSettings() called")
            print("DEBUG: mints array before conversion: \(mints.map { $0.url.absoluteString })")
            print("DEBUG: mints count: \(mints.count)")
            // Convert mints to URL strings, filtering out blacklisted ones
            let allMintURLs = mints.map { $0.url.absoluteString }
            print("DEBUG: All mint URLs: \(allMintURLs)")
            let mintURLs = mints
                .map { $0.url.absoluteString }
                .filter { url in
                    let isBlacklisted = appState.isMintBlacklisted(url)
                    print("DEBUG: Mint \(url) blacklisted: \(isBlacklisted)")
                    return !isBlacklisted
                }
            print("DEBUG: Filtered mint URLs to setup: \(mintURLs)")
            print("DEBUG: Filtered mint count: \(mintURLs.count)")
            // Setup wallet with new configuration
            try await wallet.setup(
                mints: mintURLs,
                relays: relays,
                publishMintList: true
            )
            // Update wallet info flag
            hasWalletInfo = true
            dismiss()
        } catch {
            errorMessage = "Failed to save settings: \(error.localizedDescription)"
            showError = true
        }
        isSaving = false
    }
    private func discoverMints() {
        // Cancel any existing discovery task
        discoveryTask?.cancel()
        // Start new discovery task
        discoveryTask = Task {
            // Just show the sheet - the DiscoveredMintsSheet will handle the discovery
        }
        // Show the sheet immediately
        showDiscoveredMints = true
    }
}
// MARK: - Mint Row
struct MintSettingsRow: View {
    let mintInfo: MintInfo
    let onDelete: () -> Void
    @State private var balance: Int64 = 0
    @State private var favicon: Image?
    @Environment(WalletManager.self) private var walletManager
    var body: some View {
        HStack(spacing: 6) {
            // Favicon
            Group {
                if let favicon = favicon {
                    favicon
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .frame(width: 28, height: 28)
                        .clipShape(RoundedRectangle(cornerRadius: 6))
                } else {
                    Image(systemName: "building.columns.fill")
                        .font(.footnote)
                        .foregroundColor(.orange)
                        .frame(width: 28, height: 28)
                        .background(Color.orange.opacity(0.1))
                        .clipShape(RoundedRectangle(cornerRadius: 6))
                }
            }
            VStack(alignment: .leading, spacing: 1) {
                Text(mintInfo.name ?? mintInfo.url.host ?? "Unknown Mint")
                    .font(.footnote)
                    .fontWeight(.medium)
                Text(mintInfo.url.host ?? mintInfo.url.absoluteString)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .lineLimit(1)
                    .truncationMode(.middle)
            }
            Spacer(minLength: 2)
            VStack(alignment: .trailing, spacing: 0) {
                Text("\(balance)")
                    .font(.footnote)
                    .fontWeight(.semibold)
                    .foregroundColor(.orange)
                Text("sats")
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
            Button(action: onDelete) {
                Image(systemName: "xmark.circle.fill")
                    .font(.footnote)
                    .foregroundColor(.secondary)
            }
            .buttonStyle(.plain)
            .padding(.leading, 2)
        }
        .padding(.vertical, 1)
        .task {
            await updateBalance()
            await loadFavicon()
        }
    }
    private func updateBalance() async {
        guard let wallet = walletManager.wallet else { return }
        let mintBalance = await wallet.getBalance(mint: mintInfo.url)
        await MainActor.run {
            balance = mintBalance
        }
    }
    private func loadFavicon() async {
        guard let host = mintInfo.url.host else { return }
        let faviconURL = URL(string: "https://\(host)/favicon.ico")
        // Simple favicon loading - in production you'd want proper caching
        if let url = faviconURL,
           let data = try? await URLSession.shared.data(from: url).0,
           let uiImage = UIImage(data: data) {
            await MainActor.run {
                favicon = Image(uiImage: uiImage)
            }
        }
    }
}
// MARK: - Relay Row
struct RelaySettingsRow: View {
    let relayURL: String
    let onDelete: () -> Void
    @State private var relayState: NDKRelay.State?
    @State private var relayIcon: Image?
    @State private var observationTask: Task<Void, Never>?
    @EnvironmentObject private var nostrManager: NostrManager
    var body: some View {
        HStack(spacing: 6) {
            // Relay Icon
            if let icon = relayIcon {
                icon
                    .font(.system(size: 28))
                    .foregroundColor(.secondary)
            } else {
                Image(systemName: "network")
                    .font(.system(size: 28))
                    .foregroundColor(.secondary)
            }
            VStack(alignment: .leading, spacing: 1) {
                // Use NIP-11 name if available, otherwise use hostname
                Text(relayState?.info?.name ?? getRelayHost(relayURL) ?? "Unknown Relay")
                    .font(.footnote)
                    .fontWeight(.medium)
                HStack(spacing: 4) {
                    Text(getRelayHost(relayURL) ?? relayURL)
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .lineLimit(1)
                        .truncationMode(.middle)
                    // Connection status indicator
                    if let state = relayState {
                        Circle()
                            .fill(state.connectionState == .connected ? Color.green : 
                                  state.connectionState == .connecting ? Color.orange : Color.red)
                            .frame(width: 6, height: 6)
                    }
                }
            }
            Spacer()
            // Show NIP-11 info if available
            if let info = relayState?.info {
                HStack(spacing: 4) {
                    if info.supportedNips?.contains(60) == true {
                        Image(systemName: "bitcoinsign.circle")
                            .font(.caption)
                            .foregroundColor(.orange)
                    }
                    if info.pubkey != nil {
                        Image(systemName: "checkmark.shield")
                            .font(.caption)
                            .foregroundColor(.green)
                    }
                }
            }
            Button(action: onDelete) {
                Image(systemName: "xmark.circle.fill")
                    .font(.footnote)
                    .foregroundColor(.secondary)
            }
            .buttonStyle(.plain)
            .padding(.leading, 2)
        }
        .padding(.vertical, 1)
        .task {
            await loadRelayInfo()
        }
        .onDisappear {
            stopObserving()
        }
    }
    private func getRelayHost(_ url: String) -> String? {
        URL(string: url)?.host
    }
    private func loadRelayInfo() async {
        let ndk = nostrManager.ndk
        // Get the relay from NDK
        let relays = await ndk.relays
        guard let relay = relays.first(where: { $0.url == relayURL }) else {
            // If relay not found in NDK, just use basic formatting
            if getRelayHost(relayURL) != nil {
                await MainActor.run {
                    relayState = NDKRelay.State(
                        connectionState: .disconnected,
                        stats: NDKRelayStats(),
                        info: nil
                    )
                }
            }
            return
        }
        // Start observing relay state
        observationTask = Task {
            for await state in relay.stateStream {
                await MainActor.run {
                    self.relayState = state
                    // Load relay icon from NIP-11 data if available
                    if let iconURL = state.info?.icon,
                       let url = URL(string: iconURL),
                       relayIcon == nil {
                        Task {
                            if let data = try? await URLSession.shared.data(from: url).0,
                               let uiImage = UIImage(data: data) {
                                await MainActor.run {
                                    self.relayIcon = Image(uiImage: uiImage)
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    private func stopObserving() {
        observationTask?.cancel()
        observationTask = nil
    }
}
// MARK: - Add Mint Sheet
struct AddMintSheet: View {
    @Environment(\.dismiss) private var dismiss
    @State private var mintURL = ""
    @State private var isValidating = false
    @State private var validationError = ""
    let onAdd: (URL) async -> Void
    var isValidURL: Bool {
        // Trim whitespace
        let trimmed = mintURL.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty,
              let url = URL(string: trimmed),
              let scheme = url.scheme?.lowercased(),
              scheme == "https" || scheme == "http",
              let host = url.host,
              !host.isEmpty else {
            return false
        }
        // No spaces in the URL
        if trimmed.contains(" ") {
            return false
        }
        // Host should be a valid domain
        let hostPattern = #"^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$"#
        let hostRegex = try? NSRegularExpression(pattern: hostPattern, options: .caseInsensitive)
        let hostRange = NSRange(location: 0, length: host.utf16.count)
        if let regex = hostRegex {
            if regex.firstMatch(in: host, options: [], range: hostRange) == nil {
                return false
            }
        }
        return true
    }
    var body: some View {
        NavigationStack {
            Form {
                Section {
                    TextField("https://mint.example.com", text: $mintURL)
                        .textContentType(.URL)
                        #if os(iOS)
                        .autocapitalization(.none)
                        #endif
                        .autocorrectionDisabled()
                        .onChange(of: mintURL) { _, _ in
                            validationError = ""
                        }
                } header: {
                    Text("Mint URL")
                } footer: {
                    VStack(alignment: .leading, spacing: 4) {
                        Text("Enter the URL of a Cashu mint")
                        if !validationError.isEmpty {
                            Text(validationError)
                                .foregroundColor(.red)
                                .font(.caption)
                        }
                    }
                }
            }
            .navigationTitle("Add Mint")
            .platformNavigationBarTitleDisplayMode(inline: true)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { dismiss() }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Add") {
                        let trimmedURL = mintURL.trimmingCharacters(in: .whitespacesAndNewlines)
                        guard isValidURL,
                              let url = URL(string: trimmedURL) else {
                            validationError = "Please enter a valid URL"
                            return
                        }
                        Task {
                            isValidating = true
                            await onAdd(url)
                            dismiss()
                        }
                    }
                    .disabled(mintURL.isEmpty || !isValidURL || isValidating)
                }
            }
        }
    }
}
// MARK: - Add Relay Sheet
struct AddRelaySheet: View {
    @Environment(\.dismiss) private var dismiss
    @State private var relayURL = ""
    let onAdd: (String) -> Void
    var body: some View {
        NavigationStack {
            Form {
                Section {
                    TextField("wss://relay.example.com", text: $relayURL)
                        .textContentType(.URL)
                        #if os(iOS)
                        .autocapitalization(.none)
                        #endif
                        .autocorrectionDisabled()
                } header: {
                    Text("Relay URL")
                } footer: {
                    Text("Enter a Nostr relay URL (must start with wss:// or ws://)")
                }
            }
            .navigationTitle("Add Relay")
            .platformNavigationBarTitleDisplayMode(inline: true)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { dismiss() }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Add") {
                        guard relayURL.starts(with: "wss://") || relayURL.starts(with: "ws://") else { return }
                        onAdd(relayURL)
                        dismiss()
                    }
                    .disabled(relayURL.isEmpty || (!relayURL.starts(with: "wss://") && !relayURL.starts(with: "ws://")))
                }
            }
        }
    }
}
// MARK: - Discovered Mints Sheet  
struct DiscoveredMintsSheet: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject private var nostrManager: NostrManager
    let discoveryTask: Task<Void, Never>?
    let onSelect: ([DiscoveredMint]) async -> Void
    @State private var selectedMints: Set<String> = []
    @State private var discoveryDataSource: MintDiscoveryDataSource?
    init(discoveryTask: Task<Void, Never>?, onSelect: @escaping ([DiscoveredMint]) async -> Void) {
        self.discoveryTask = discoveryTask
        self.onSelect = onSelect
    }
    var body: some View {
        NavigationStack {
            mintsList
                .navigationTitle("Discovered Mints")
                .platformNavigationBarTitleDisplayMode(inline: true)
                .toolbar {
                    toolbarContent
                }
                .task {
                    await setupDiscovery()
                }
                .onDisappear {
                    discoveryDataSource?.stopStreaming()
                }
        }
    }
    private func setupDiscovery() async {
        let ndk = nostrManager.ndk
        // Get user's followed pubkeys for mint recommendations
        var followedPubkeys: [String] = []
        if let signer = ndk.signer {
            do {
                let userPubkey = try await signer.pubkey
                let user = NDKUser(pubkey: userPubkey)
                user.ndk = ndk
                let contactList = try? await user.fetchContactList()
                if let contactList = contactList {
                    followedPubkeys = contactList.contacts.map { $0.user.pubkey }
                }
            } catch {
                print("Failed to get user pubkey: \(error)")
            }
        }
        // Create proper data source and start streaming
        let dataSource = MintDiscoveryDataSource(ndk: ndk, followedPubkeys: followedPubkeys)
        await MainActor.run {
            self.discoveryDataSource = dataSource
        }
        dataSource.startStreaming()
    }
    @ViewBuilder
    private var mintsList: some View {
        List {
            if discoveryDataSource?.discoveredMints.isEmpty ?? true {
                // Show empty state immediately - no spinner
                Section {
                    VStack(spacing: 12) {
                        Image(systemName: "magnifyingglass")
                            .font(.system(size: 48))
                            .foregroundStyle(.secondary)
                        Text("No mints found")
                            .font(.headline)
                            .foregroundStyle(.secondary)
                        Text("Mints will appear here")
                            .font(.caption)
                            .foregroundStyle(.tertiary)
                            .multilineTextAlignment(.center)
                    }
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 40)
                }
                .listRowBackground(Color.clear)
                .listRowInsets(EdgeInsets())
            } else {
                Section {
                    ForEach(discoveryDataSource?.discoveredMints ?? []) { mint in
                        DiscoveredMintRowItem(
                            mint: mint,
                            isSelected: selectedMints.contains(mint.url),
                            onToggle: {
                                if selectedMints.contains(mint.url) {
                                    selectedMints.remove(mint.url)
                                } else {
                                    selectedMints.insert(mint.url)
                                }
                            }
                        )
                    }
                } header: {
                    if let count = discoveryDataSource?.discoveredMints.count, count > 0 {
                        Text("\(count) mint\(count == 1 ? "" : "s") discovered")
                            .font(.caption)
                            .foregroundStyle(.secondary)
                    }
                }
            }
        }
    }
    @ToolbarContentBuilder
    private var toolbarContent: some ToolbarContent {
        ToolbarItem(placement: .cancellationAction) {
            Button("Cancel") { dismiss() }
        }
        ToolbarItem(placement: .confirmationAction) {
            Button("Add Selected") {
                Task {
                    let selected = (discoveryDataSource?.discoveredMints ?? []).filter { selectedMints.contains($0.url) }
                    await onSelect(selected)
                    dismiss()
                }
            }
            .disabled(selectedMints.isEmpty)
        }
    }
}
// MARK: - Discovered Mint Row Item
private struct DiscoveredMintRowItem: View {
    let mint: DiscoveredMint
    let isSelected: Bool
    let onToggle: () -> Void
    var body: some View {
        HStack {
            mintInfo
            Spacer()
            selectionIndicator
        }
        .contentShape(Rectangle())
        .onTapGesture(perform: onToggle)
    }
    @ViewBuilder
    private var mintInfo: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(mint.name)
                .font(.headline)
            Text(mint.url)
                .font(.caption)
                .foregroundColor(.secondary)
                .lineLimit(1)
        }
    }
    @ViewBuilder
    private var selectionIndicator: some View {
        if isSelected {
            Image(systemName: "checkmark.circle.fill")
                .foregroundColor(.green)
        }
    }
}
</file>

<file path="Sources/NutsackiOS/Views/Wallet/WalletView.swift">
import SwiftUI
import NDKSwift
// import Popovers - Removed for build compatibility
struct WalletView: View {
    @EnvironmentObject private var appState: AppState
    @EnvironmentObject private var nostrManager: NostrManager
    @Environment(WalletManager.self) private var walletManager
    @Binding var urlState: URLState?
    @Binding var showScanner: Bool
    @State private var navigationDestination: WalletDestination?
    @State private var isLoadingWallet = false
    @State private var scannedInvoice: String?
    @State private var showInvoicePreview = false
    @State private var showWalletSettings = false
    @State private var showSettings = false
    @State private var showWalletOnboarding = false
    enum WalletDestination: Identifiable, Hashable {
        case mint
        case send
        case receive(urlString: String?)
        case nutzap(pubkey: String? = nil)
        case swap
        case relayHealth
        case contacts
        case walletEvents
        case proofManagement
        case receivedNutzaps
        var id: String {
            switch self {
            case .mint: return "mint"
            case .send: return "send"
            case .receive(let url): return "receive_\(url ?? "nil")"
            case .nutzap(let pubkey): return "nutzap_\(pubkey ?? "nil")"
            case .swap: return "swap"
            case .relayHealth: return "relayHealth"
            case .contacts: return "contacts"
            case .walletEvents: return "walletEvents"
            case .proofManagement: return "proofManagement"
            case .receivedNutzaps: return "receivedNutzaps"
            }
        }
    }
    var body: some View {
        NavigationStack {
            VStack {
                if walletManager.wallet == nil {
                    // No wallet at all - show full onboarding
                    EmptyWalletView(showWalletOnboarding: $showWalletOnboarding)
                } else {
                    ScrollView {
                        VStack(spacing: 12) {
                            // Balance card with expandable pie chart
                            BalanceCard()
                                .padding(.horizontal)
                                .zIndex(1) // Ensure it stays on top during expansion
                            // Contacts horizontal scroll
                            ContactsScrollView(navigationDestination: $navigationDestination)
                                .padding(.top, -8)
                            // Recent transactions
                            RecentTransactionsView()
                                .padding(.horizontal)
                        }
                        .padding(.top, 8)
                    }
                    .scrollIndicators(.hidden)
                    Spacer()
                    // Action buttons
                    ActionButtonsView(navigationDestination: $navigationDestination, showScanner: $showScanner)
                        .padding()
                }
            }
            .background(
                RadialGradient(
                    gradient: Gradient(colors: [
                        Color(.systemBackground),
                        Color(.secondarySystemBackground)
                    ]),
                    center: .top,
                    startRadius: 0,
                    endRadius: 400
                )
            )
            .navigationTitle("")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .topBarLeading) {
                    Button(action: { showSettings = true }) {
                        Image(systemName: "person.circle.fill")
                            .font(.title3)
                    }
                }
                if walletManager.wallet != nil {
                    ToolbarItem(placement: .topBarTrailing) {
                        Button(action: { showWalletSettings = true }) {
                            Image(systemName: "gearshape")
                                .font(.title3)
                        }
                    }
                }
            }
            .sheet(isPresented: $showInvoicePreview) {
                if let invoice = scannedInvoice {
                    LightningInvoicePreviewView(invoice: invoice)
                }
            }
            .sheet(isPresented: $showWalletSettings) {
                WalletSettingsView()
                    .environmentObject(nostrManager)
                    .environment(walletManager)
            }
            .sheet(isPresented: $showSettings) {
                SettingsView()
                    .environmentObject(nostrManager)
                    .environment(walletManager)
            }
            .sheet(isPresented: Binding(
                get: { walletManager.showMintFailureAlert },
                set: { walletManager.showMintFailureAlert = $0 }
            )) {
                if let operation = walletManager.pendingMintFailure {
                    MintFailureAlert(
                        operation: operation,
                        onRetry: {
                            Task {
                                do {
                                    try await walletManager.retryPendingMintOperation()
                                } catch {
                                    print("Failed to retry mint operation: \(error)")
                                }
                            }
                        },
                        onBlacklist: {
                            Task {
                                do {
                                    try await walletManager.blacklistPendingMint()
                                } catch {
                                    print("Failed to blacklist mint: \(error)")
                                }
                            }
                        },
                        onCancel: {
                            walletManager.pendingMintFailure = nil
                        }
                    )
                }
            }
            .navigationDestination(item: $navigationDestination) { destination in
                switch destination {
                case .mint:
                    MintView()
                case .send:
                    SendView()
                case .receive(let urlString):
                    ReceiveView(tokenString: urlString)
                case .nutzap(let pubkey):
                    NutzapView(recipientPubkey: pubkey)
                case .swap:
                    SwapView()
                case .relayHealth:
                    RelayHealthView()
                case .contacts:
                    ContactsView(navigationDestination: $navigationDestination)
                case .walletEvents:
                    WalletEventsView()
                case .proofManagement:
                    ProofManagementView()
                case .receivedNutzaps:
                    ReceivedNutzapsView(walletManager: walletManager)
                }
            }
            .onAppear {
                print("\n=== 🟢 [WalletView] VIEW LIFECYCLE ===")
                print("🟢 [WalletView] onAppear called at \(Date())")
                print("🟢 [WalletView] activeWallet exists: \(walletManager.wallet != nil)")
                print("🟢 [WalletView] isAuthenticated: \(nostrManager.isAuthenticated)")
                print("🟢 [WalletView] signer available: \(nostrManager.ndk.signer != nil)")
                loadWalletIfNeeded()
                // Check wallet status for logging purposes
                Task {
                    let wallet = walletManager.wallet
                    let mintUrls = await wallet?.mints.getMintURLs() ?? []
                    print("🟢 [WalletView] Wallet status check:")
                    print("  - wallet exists: \(wallet != nil)")
                    print("  - mint count: \(mintUrls.count)")
                    print("  - mints: \(mintUrls)")
                    if wallet == nil {
                        print("🚨 [WalletView] NO WALLET - Will show EmptyWalletView")
                    } else {
                        print("✅ [WalletView] Wallet exists - Will show normal wallet UI (even without mints)")
                    }
                }
                print("=== [WalletView] END VIEW LIFECYCLE ===\n")
            }
            .onChange(of: urlState) { _, newValue in
                if let newValue {
                    navigationDestination = .receive(urlString: newValue.url)
                    urlState = nil
                }
            }
            .onChange(of: nostrManager.isAuthenticated) { _, newValue in
                if newValue && walletManager.wallet == nil {
                    loadWalletIfNeeded()
                }
            }
            .fullScreenCover(isPresented: $showWalletOnboarding) {
                WalletOnboardingView(authMode: .none)
                    .environmentObject(nostrManager)
                    .environment(walletManager)
                    .onDisappear {
                        // Reload wallet after onboarding
                        Task {
                            try? await walletManager.loadWalletForCurrentUser()
                        }
                    }
            }
            .task {
                print("🔵 WalletView - Task started at \(Date())")
                // Monitor for signer availability when authenticated
                var attempts = 0
                while nostrManager.isAuthenticated && walletManager.wallet == nil {
                    attempts += 1
                    print("🔵 WalletView - Task checking signer (attempt \(attempts))")
                    if nostrManager.ndk.signer != nil {
                        print("🔵 WalletView - Task found signer, calling loadWalletIfNeeded")
                        loadWalletIfNeeded()
                        break
                    }
                    try? await Task.sleep(nanoseconds: 100_000_000) // 0.1 seconds
                }
                print("🔵 WalletView - Task completed")
            }
        }
        .tint(.orange)
    }
    private func loadWalletIfNeeded() {
        print("🟡 loadWalletIfNeeded called from \(Thread.current)")
        guard nostrManager.isAuthenticated else {
            print("🟡 loadWalletIfNeeded - Not authenticated, skipping")
            return
        }
        guard walletManager.wallet == nil else {
            print("🟡 loadWalletIfNeeded - Wallet already active, skipping")
            return
        }
        guard !isLoadingWallet else {
            print("🟡 loadWalletIfNeeded - Already loading wallet, skipping duplicate call")
            return
        }
        print("🟡 loadWalletIfNeeded - Starting wallet load task")
        isLoadingWallet = true
        Task {
            defer { isLoadingWallet = false }
            do {
                print("🟡 loadWalletIfNeeded - Calling loadWalletForCurrentUser")
                try await walletManager.loadWalletForCurrentUser()
                print("✅ loadWalletIfNeeded - Wallet loaded successfully")
            } catch WalletError.signerNotAvailable {
                // Signer not ready yet, retry after a short delay
                print("⚠️ loadWalletIfNeeded - Signer not available yet, retrying...")
                try? await Task.sleep(nanoseconds: 500_000_000) // 0.5 seconds
                // Retry once more
                do {
                    print("🟡 loadWalletIfNeeded - Retrying loadWalletForCurrentUser")
                    try await walletManager.loadWalletForCurrentUser()
                    print("✅ loadWalletIfNeeded - Wallet loaded successfully on retry")
                } catch {
                    print("❌ loadWalletIfNeeded - Failed to load wallet after retry: \(error)")
                }
            } catch {
                print("❌ loadWalletIfNeeded - Failed to load wallet: \(error)")
            }
        }
    }
}
// MARK: - Empty Wallet View
struct EmptyWalletView: View {
    @EnvironmentObject private var nostrManager: NostrManager
    @Binding var showWalletOnboarding: Bool
    var body: some View {
        VStack(spacing: 24) {
            Spacer()
            // Icon
            ZStack {
                Circle()
                    .fill(Color.orange.opacity(0.1))
                    .frame(width: 120, height: 120)
                Image(systemName: "wallet.pass")
                    .font(.system(size: 60))
                    .foregroundColor(.orange)
            }
            // Title
            Text("Welcome to Nutsack")
                .font(.title)
                .fontWeight(.bold)
            // Description
            Text("Your wallet is not set up yet. Tap the button below to configure your Cashu wallet and start using instant, private payments.")
                .font(.body)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
                .padding(.horizontal, 40)
            // Setup button
            Button(action: {
                print("🔍 [EmptyWalletView] User manually initiated wallet setup")
                showWalletOnboarding = true
            }) {
                Label("Set Up Wallet", systemImage: "arrow.right.circle.fill")
                    .font(.headline)
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .frame(height: 50)
                    .background(Color.orange)
                    .cornerRadius(12)
            }
            .padding(.horizontal, 40)
            Spacer()
        }
        .onAppear {
            print("\n=== 🚀 [EmptyWalletView] VIEW DISPLAYED ===")
            print("🔍 [EmptyWalletView] Detected authenticated user with no configured wallet")
            print("🔍 [EmptyWalletView] NostrManager has signer: \(nostrManager.ndk.signer != nil)")
            print("🔍 [EmptyWalletView] NostrManager.isAuthenticated: \(nostrManager.isAuthenticated)")
            // If we have auth state but no signer, clear the lingering auth state
            if nostrManager.ndk.signer == nil && nostrManager.isAuthenticated {
                print("🔍 [EmptyWalletView] DECISION: Clear lingering auth state (no signer found)")
                Task {
                    await nostrManager.logout()
                }
                // Don't show wallet onboarding, let ContentView handle showing AuthenticationFlow
            } else {
                // User is authenticated but has no wallet configured
                // Don't automatically show onboarding - let user initiate it manually
                print("🔍 [EmptyWalletView] DECISION: User authenticated but wallet not configured - showing setup prompt")
                print("🔍 [EmptyWalletView] User can tap 'Set Up Wallet' button to begin setup")
            }
            print("=== [EmptyWalletView] END VIEW DISPLAYED ===\n")
        }
    }
}
// Premium button style with subtle press effect
struct PremiumButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed ? 0.95 : 1.0)
            .opacity(configuration.isPressed ? 0.8 : 1.0)
            .animation(.easeInOut(duration: 0.1), value: configuration.isPressed)
    }
}
// MARK: - Action Buttons
struct ActionButtonsView: View {
    @Binding var navigationDestination: WalletView.WalletDestination?
    @Binding var showScanner: Bool
    @State private var showReceiveMenu = false
    @State private var showSendMenu = false
    @State private var scanButtonPressed = false
    var body: some View {
        ZStack {
            // Base layer - receive and send buttons touching
            HStack(spacing: 0) {
                // Receive button
                Button(action: { navigationDestination = .mint }) {
                    HStack(spacing: 8) {
                        Image(systemName: "arrow.down")
                            .font(.system(size: 20, weight: .medium))
                        Text("Receive")
                            .font(.system(size: 16, weight: .medium))
                    }
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity, alignment: .center)
                    .frame(height: 60)
                    .padding(.trailing, 40) // Offset for floating circle (80px width / 2)
                }
                .buttonStyle(PremiumButtonStyle())
                // Send button - direct to send view
                Button(action: { navigationDestination = .send }) {
                    HStack(spacing: 8) {
                        Image(systemName: "arrow.up")
                            .font(.system(size: 20, weight: .medium))
                        Text("Send")
                            .font(.system(size: 16, weight: .medium))
                    }
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity, alignment: .center)
                    .frame(height: 60)
                    .padding(.leading, 40) // Offset for floating circle (80px width / 2)
                }
                .buttonStyle(PremiumButtonStyle())
            }
            .background(
                RoundedRectangle(cornerRadius: 16)
                    .fill(
                        LinearGradient(
                            gradient: Gradient(colors: [
                                Color(white: 0.18),
                                Color(white: 0.12)
                            ]),
                            startPoint: .top,
                            endPoint: .bottom
                        )
                    )
            )
            .shadow(color: Color(.label).opacity(0.2), radius: 20, x: 0, y: 10)
            // Floating scan button on top
            Button(action: {
                withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {
                    scanButtonPressed = true
                }
                showScanner = true
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                    scanButtonPressed = false
                }
            }) {
                Circle()
                    .fill(
                        LinearGradient(
                            gradient: Gradient(colors: [
                                Color.orange,
                                Color.orange.opacity(0.85)
                            ]),
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .frame(width: 80, height: 80)
                    .shadow(color: Color.orange.opacity(0.4), radius: 12, x: 0, y: 6)
                    .overlay(
                        Image(systemName: "qrcode.viewfinder")
                            .font(.system(size: 36, weight: .medium))
                            .foregroundColor(.white)
                    )
                    .scaleEffect(scanButtonPressed ? 0.92 : 1.0)
            }
            .buttonStyle(PlainButtonStyle())
        }
        .frame(height: 76) // Match the reduced scan button
    }
}
// MARK: - Contacts Scroll View
struct ContactsScrollView: View {
    @Binding var navigationDestination: WalletView.WalletDestination?
    @EnvironmentObject private var nostrManager: NostrManager
    @State private var contacts: [NDKUser] = []
    @State private var scrollOffset: CGFloat = 0
    // Default users to show when no contacts
    private let defaultUsers: [NDKUser] = {
        // Pre-calculated pubkeys for reliability
        let defaultPubkeys = [
            // Pablo Fernandez
            "fcb220c3af11b08325c8ad74c37b2ab5b9e665e3c39076c20c8d36c5b5c3de78",
            // Jack Dorsey  
            "82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2",
            // Calle (Cashu creator)
            "50d94fc2d8580c682b071a542f8b1e31a200b0508bab95a33bef0855df281d63"
        ]
        return defaultPubkeys.map { NDKUser(pubkey: $0) }
    }()
    var body: some View {
        ScrollViewReader { _ in
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 16) {
                    // Show default users if no contacts, otherwise show contacts
                    ForEach(contacts.isEmpty ? defaultUsers : contacts, id: \.pubkey) { contact in
                        ContactAvatarView(user: contact) {
                            navigationDestination = .nutzap(pubkey: contact.pubkey)
                        }
                    }
                    // View All button at the end
                    Button(action: {
                        navigationDestination = .contacts
                    }) {
                        VStack(spacing: 4) {
                            ZStack {
                                Circle()
                                    .fill(Color(white: 0.15))
                                    .frame(width: 64, height: 64)
                                Image(systemName: "ellipsis")
                                    .font(.system(size: 24, weight: .medium))
                                    .foregroundColor(.white.opacity(0.6))
                            }
                            Text("All")
                                .font(.caption2)
                                .foregroundStyle(.secondary)
                        }
                    }
                    .id("viewAll")
                }
                .padding(.horizontal)
                .background(GeometryReader { geometry in
                    Color.clear
                        .preference(key: ScrollOffsetPreferenceKey.self,
                                  value: geometry.frame(in: .named("scroll")).minX)
                })
            }
            .coordinateSpace(name: "scroll")
            .onPreferenceChange(ScrollOffsetPreferenceKey.self) { @MainActor value in
                scrollOffset = value
                // If scrolled far enough to the right (view all button visible)
                if value < -UIScreen.main.bounds.width {
                    navigationDestination = .contacts
                }
            }
        }
        .task {
            await loadContacts()
        }
    }
    @MainActor
    private func loadContacts() async {
        let ndk = nostrManager.ndk
        do {
            // Get user's contact list
            guard let signer = ndk.signer else { return }
            let pubkey = try await signer.pubkey
            let filter = NDKFilter(
                authors: [pubkey],
                kinds: [3]
            )
            // Use declarative data source to fetch contact list
            let contactDataSource = ndk.subscribe(
                filter: filter,
                maxAge: 3600,
                cachePolicy: .cacheWithNetwork
            )
            var contactListEvent: NDKEvent?
            for await event in contactDataSource.events {
                contactListEvent = event
                break // Take first event
            }
            if let contactListEvent = contactListEvent {
                // Parse the contact list
                var contactPubkeys: [String] = []
                for tag in contactListEvent.tags {
                    if tag.count >= 2 && tag[0] == "p" {
                        contactPubkeys.append(tag[1])
                    }
                }
                // Limit to first 20 contacts for performance
                let limitedPubkeys = Array(contactPubkeys.prefix(20))
                // Create NDKUser objects and show them immediately
                contacts = limitedPubkeys.map { NDKUser(pubkey: $0) }
            }
        } catch {
            print("Failed to load contacts: \(error)")
        }
    }
}
struct ContactAvatarView: View {
    let user: NDKUser
    let onTap: () -> Void
    @State private var metadata: NDKUserMetadata?
    @State private var profileTask: Task<Void, Never>?
    @EnvironmentObject private var nostrManager: NostrManager
    var displayName: String {
        metadata?.displayName ?? metadata?.name ?? String(user.pubkey.prefix(8))
    }
    var body: some View {
        Button(action: onTap) {
            VStack(spacing: 4) {
                Group {
                    if let imageUrl = metadata?.picture, let url = URL(string: imageUrl) {
                        AsyncImage(url: url) { image in
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                                .frame(width: 64, height: 64)
                                .clipShape(Circle())
                        } placeholder: {
                            Circle()
                                .fill(Color(white: 0.15))
                                .frame(width: 64, height: 64)
                                .overlay(
                                    Text(String(displayName.prefix(1)).uppercased())
                                        .font(.title2)
                                        .foregroundColor(.white.opacity(0.6))
                                )
                        }
                    } else {
                        Circle()
                            .fill(Color(white: 0.15))
                            .frame(width: 64, height: 64)
                            .overlay(
                                Text(String(displayName.prefix(1)).uppercased())
                                    .font(.title2)
                                    .foregroundColor(.white.opacity(0.6))
                            )
                    }
                }
                .overlay(
                    Circle()
                        .stroke(Color(.separator).opacity(0.3), lineWidth: 1)
                )
                Text(displayName)
                    .font(.caption2)
                    .foregroundStyle(.secondary)
                    .lineLimit(1)
                    .frame(maxWidth: 64)
            }
        }
        .buttonStyle(PlainButtonStyle())
        .task {
            let ndk = nostrManager.ndk
            profileTask = Task {
                // Use profile manager to load metadata
                for await metadata in await ndk.profileManager.subscribe(for: user.pubkey, maxAge: 3600) {
                    await MainActor.run {
                        self.metadata = metadata
                    }
                    break // Take first result
                }
            }
        }
        .onDisappear {
            profileTask?.cancel()
        }
    }
}
struct ScrollOffsetPreferenceKey: PreferenceKey {
    static let defaultValue: CGFloat = 0
    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
        value = nextValue()
    }
}
// MARK: - Helper Views
</file>

<file path="Sources/NutsackiOS/Views/ContactsView.swift">
import SwiftUI
import NDKSwift
struct ContactsView: View {
    @EnvironmentObject private var nostrManager: NostrManager
    @Environment(WalletManager.self) private var walletManager
    @Binding var navigationDestination: WalletView.WalletDestination?
    @State private var searchText = ""
    @State private var showSettings = false
    @State private var resolvedUser: NDKUser?
    @State private var isResolving = false
    @State private var showQRScanner = false
    @State private var contacts: [String] = []
    // Default users to show when no contacts
    private let defaultUsers = [
        // PABLOf7z
        "fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52",
        // jacj
        "82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2",
        // calle
        "50d94fc2d8580c682b071a542f8b1e31a200b0508bab95a33bef0855df281d63"
    ]
    var filteredContacts: [String] {
        if searchText.isEmpty {
            return contacts
        }
        var filtered: [String] = []
        for pubkey in contacts {
            // Filter by pubkey/npub
            let npub = NDKUser(pubkey: pubkey).npub
            if npub.localizedCaseInsensitiveContains(searchText) {
                filtered.append(pubkey)
                continue
            }
            // Profile search disabled for now - would need async implementation
            // TODO: Implement profile-based search with declarative data sources
        }
        return filtered
    }
    var body: some View {
        VStack(spacing: 0) {
                // Search input section
                VStack(spacing: 12) {
                    HStack {
                        TextField("npub, NIP-05, or hex pubkey", text: $searchText)
                            #if os(iOS)
                            .textInputAutocapitalization(.never)
                            #endif
                            .autocorrectionDisabled()
                        #if os(iOS)
                        Button(action: { showQRScanner = true }) {
                            Image(systemName: "qrcode.viewfinder")
                                .font(.title2)
                                .foregroundColor(.white)
                                .frame(width: 44, height: 44)
                                .background(Color.orange)
                                .cornerRadius(10)
                        }
                        .buttonStyle(.plain)
                        #endif
                    }
                    .padding(.horizontal)
                    if isResolving {
                        HStack {
                            ProgressView()
                                .scaleEffect(0.8)
                            Text("Resolving...")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                        }
                        .padding(.horizontal)
                    } else if let user = resolvedUser {
                        NavigationLink(value: user.pubkey) {
                            HStack {
                                // Profile picture
                                UserProfilePicture(user: user)
                                VStack(alignment: .leading) {
                                    UserDisplayName(user: user)
                                        .font(.subheadline)
                                        .fontWeight(.medium)
                                    UserNIP05(user: user)
                                        .font(.caption)
                                        .foregroundStyle(.secondary)
                                }
                                Spacer()
                                Image(systemName: "bolt.heart.fill")
                                    .foregroundStyle(.orange)
                            }
                            .padding(.vertical, 4)
                            .padding(.horizontal)
                        }
                        .buttonStyle(.plain)
                    }
                }
                .padding(.vertical, 8)
                .background(Color(.systemGroupedBackground))
                // Contacts list
                List {
                    if contacts.isEmpty {
                        Section {
                            ForEach(defaultUsers, id: \.self) { pubkey in
                                ContactRow(pubkey: pubkey)
                            }
                        } header: {
                            VStack(alignment: .leading, spacing: 8) {
                                Text("Suggested Contacts")
                                    .font(.headline)
                                    .foregroundStyle(.primary)
                                Text("Follow people on Nostr to see your contacts here")
                                    .font(.caption)
                                    .foregroundStyle(.secondary)
                            }
                            .textCase(nil)
                            .padding(.bottom, 4)
                        }
                    } else {
                        ForEach(filteredContacts, id: \.self) { pubkey in
                            ContactRow(pubkey: pubkey)
                        }
                    }
                }
            }
            .navigationTitle("Contacts")
            .platformNavigationBarTitleDisplayMode(inline: true)
            .toolbar {
                ToolbarItem(placement: .topBarLeading) {
                    Button(action: { showSettings = true }) {
                        Image(systemName: "person.circle.fill")
                            .font(.title3)
                    }
                }
            }
            .sheet(isPresented: $showSettings) {
                SettingsView()
                    .environmentObject(nostrManager)
                    .environment(walletManager)
            }
            .refreshable {
                // Data sources handle refreshing automatically
            }
            .onChange(of: searchText) { _, _ in
                resolveSearchInput()
            }
            #if os(iOS)
            .sheet(isPresented: $showQRScanner) {
                QRScannerView(
                    onScan: { scannedCode in
                        searchText = scannedCode
                        showQRScanner = false
                    },
                    onDismiss: {
                        showQRScanner = false
                    }
                )
            }
            #endif
        .navigationDestination(for: String.self) { pubkey in
            NutzapView(recipientPubkey: pubkey)
                .environmentObject(nostrManager)
                .environment(walletManager)
        }
        .task {
            await loadContacts()
        }
    }
    private func resolveSearchInput() {
        // Clear previous resolution if search text is empty or too short
        guard !searchText.isEmpty else {
            resolvedUser = nil
            return
        }
        // Only resolve if it looks like a pubkey, npub, or NIP-05
        guard searchText.starts(with: "npub1") ||
              HexValidator.isValid32ByteHex(searchText) ||
              searchText.contains("@") else {
            resolvedUser = nil
            return
        }
        isResolving = true
        Task {
            do {
                let ndk = nostrManager.ndk
                var pubkey: String?
                // Try to parse as npub
                if searchText.starts(with: "npub1") {
                    pubkey = try? Bech32.pubkey(from: searchText)
                }
                // Try as hex pubkey
                else if HexValidator.isValid32ByteHex(searchText) {
                    pubkey = searchText
                }
                // Try as NIP-05
                else if searchText.contains("@") {
                    let user = try await NDKUser.fromNip05(searchText, ndk: ndk)
                    pubkey = user.pubkey
                }
                if let pubkey = pubkey {
                    let user = NDKUser(pubkey: pubkey)
                    await MainActor.run {
                        resolvedUser = user
                        isResolving = false
                    }
                } else {
                    await MainActor.run {
                        resolvedUser = nil
                        isResolving = false
                    }
                }
            } catch {
                await MainActor.run {
                    resolvedUser = nil
                    isResolving = false
                }
            }
        }
    }
    @MainActor
    private func loadContacts() async {
        let ndk = nostrManager.ndk
        do {
            // Get user's contact list
            guard let signer = ndk.signer else { return }
            let pubkey = try await signer.pubkey
            let filter = NDKFilter(
                authors: [pubkey],
                kinds: [3]
            )
            // Use declarative data source to fetch contact list
            let contactDataSource = ndk.subscribe(
                filter: filter,
                maxAge: 3600,
                cachePolicy: .cacheWithNetwork
            )
            var contactListEvent: NDKEvent?
            for await event in contactDataSource.events {
                contactListEvent = event
                break // Take first event
            }
            if let contactListEvent = contactListEvent {
                // Parse the contact list
                var contactPubkeys: [String] = []
                for tag in contactListEvent.tags {
                    if tag.count >= 2 && tag[0] == "p" {
                        contactPubkeys.append(tag[1])
                    }
                }
                // Update contacts
                contacts = contactPubkeys
            }
        } catch {
            print("Failed to load contacts: \(error)")
        }
    }
}
struct ContactRow: View {
    let pubkey: String
    @EnvironmentObject private var nostrManager: NostrManager
    private var user: NDKUser {
        NDKUser(pubkey: pubkey)
    }
    var body: some View {
        NavigationLink(value: pubkey) {
            HStack {
                // Profile picture
                UserProfilePicture(pubkey: pubkey, size: 50)
                VStack(alignment: .leading, spacing: 4) {
                    UserDisplayName(pubkey: pubkey)
                        .font(.headline)
                        .lineLimit(1)
                    UserNIP05(pubkey: pubkey)
                        .font(.caption)
                        .foregroundStyle(.secondary)
                        .lineLimit(1)
                }
                Spacer()
                Image(systemName: "bolt.heart.fill")
                    .foregroundStyle(.orange)
            }
            .padding(.vertical, 4)
        }
        .buttonStyle(.plain)
    }
}
</file>

<file path="Sources/NutsackiOS/Views/ContentView.swift">
import SwiftUI
import NDKSwift
struct ContentView: View {
    @EnvironmentObject private var appState: AppState
    @EnvironmentObject private var nostrManager: NostrManager
    @Environment(WalletManager.self) private var walletManager
    @State private var urlState: URLState?
    @State private var showScanner = false
    @State private var scannedInvoice: String?
    @State private var showInvoicePreview = false
    var body: some View {
        ZStack {
            Color(UIColor.systemBackground).ignoresSafeArea()
            if !nostrManager.isInitialized {
                // Show loading while NostrManager initializes
                ProgressView("Initializing...")
                    .progressViewStyle(CircularProgressViewStyle())
                    .foregroundColor(.orange)
            } else if nostrManager.isAuthenticated {
                // Main app interface - shown when authenticated
                WalletView(urlState: $urlState, showScanner: $showScanner)
            } else {
                // Use SplashView as the authentication screen
                SplashView()
            }
        }
        .onAppear {
            print("\n=== 🏁 [ContentView] NAVIGATION STATE CHECK ===")
            print("🔍 [ContentView] onAppear at \(Date())")
            print("🔍 [ContentView] NostrManager.isInitialized: \(nostrManager.isInitialized)")
            print("🔍 [ContentView] NostrManager.isAuthenticated: \(nostrManager.isAuthenticated)")
            print("🔍 [ContentView] NostrManager has signer: \(nostrManager.ndk.signer != nil)")
            print("🔍 [ContentView] NostrManager.ndk: exists")
            Task {
                let isConfigured = walletManager.isWalletConfigured
                let wallet = walletManager.wallet
                let mintUrls = await wallet?.mints.getMintURLs() ?? []
                print("🔍 [ContentView] WalletManager.isWalletConfigured: \(isConfigured)")
                print("🔍 [ContentView] WalletManager.wallet: \(wallet != nil ? "exists" : "nil")")
                print("🔍 [ContentView] Wallet mint count: \(mintUrls.count)")
                print("🔍 [ContentView] Wallet mints: \(mintUrls)")
                // Decision logic
                if !nostrManager.isInitialized {
                    print("🚦 [ContentView] NAVIGATION DECISION: Show loading (NostrManager not initialized)")
                } else if nostrManager.isAuthenticated {
                    print("🚦 [ContentView] NAVIGATION DECISION: Show WalletView (authenticated)")
                } else {
                    print("🚦 [ContentView] NAVIGATION DECISION: Show SplashView (not authenticated)")
                }
                print("=== [ContentView] END NAVIGATION STATE CHECK ===\n")
            }
        }
        .ignoresSafeArea()
        .onOpenURL { url in
            handleUrl(url)
        }
        .sheet(isPresented: $showScanner) {
            QRScannerView(
                onScan: { scannedValue in
                    handleScannedValue(scannedValue)
                },
                onDismiss: {
                    showScanner = false
                }
            )
        }
        .sheet(isPresented: $showInvoicePreview) {
            if let invoice = scannedInvoice {
                LightningInvoicePreviewView(invoice: invoice)
            }
        }
    }
    private func handleUrl(_ url: URL) {
        print("URL passed to application: \(url.absoluteString)")
        if url.scheme == "cashu" || url.scheme == "nostr" {
            urlState = URLState(url: url.absoluteString, timestamp: Date())
        }
    }
    private func handleScannedValue(_ scannedValue: String) {
        showScanner = false
        // Check if it's a lightning invoice
        if isLightningInvoice(scannedValue) {
            scannedInvoice = scannedValue
            showInvoicePreview = true
        } else if scannedValue.lowercased().starts(with: "cashu") {
            // Handle cashu token by updating wallet view URL state
            urlState = URLState(url: scannedValue, timestamp: Date())
        } else {
            // Handle other QR codes (nostr URLs, etc)
            urlState = URLState(url: scannedValue, timestamp: Date())
        }
    }
    private func isLightningInvoice(_ text: String) -> Bool {
        let cleanText = text.replacingOccurrences(of: "lightning:", with: "")
        return LightningConstants.isLightningInvoice(cleanText)
    }
}
struct URLState: Equatable {
    let url: String
    let timestamp: Date
}
// MARK: - Lightning Invoice Preview View
struct LightningInvoicePreviewView: View {
    let invoice: String
    @Environment(\.dismiss) private var dismiss
    @Environment(WalletManager.self) private var walletManager
    @State private var decodedAmount: Int64?
    @State private var decodedDescription: String?
    @State private var availableBalance: Int = 0
    @State private var isPaying = false
    @State private var showError = false
    @State private var errorMessage = ""
    @State private var showSuccess = false
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 24) {
                    // Header
                    VStack(spacing: 16) {
                        ZStack {
                            Circle()
                                .fill(Color.orange.opacity(0.2))
                                .frame(width: 80, height: 80)
                            Image(systemName: "bolt.fill")
                                .font(.system(size: 40))
                                .foregroundColor(.orange)
                        }
                        Text("Lightning Invoice")
                            .font(.largeTitle)
                            .fontWeight(.bold)
                        Text("Review payment details before proceeding")
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                            .multilineTextAlignment(.center)
                    }
                    .padding(.top, 20)
                    // Payment Details Card
                    VStack(spacing: 0) {
                        if let amount = decodedAmount {
                            VStack(spacing: 16) {
                                HStack {
                                    VStack(alignment: .leading, spacing: 4) {
                                        Text("Amount")
                                            .font(.subheadline)
                                            .foregroundColor(.secondary)
                                        Text("\(amount) sats")
                                            .font(.title)
                                            .fontWeight(.bold)
                                    }
                                    Spacer()
                                    VStack(alignment: .trailing, spacing: 4) {
                                        Text("Fee (est.)")
                                            .font(.subheadline)
                                            .foregroundColor(.secondary)
                                        Text("~1 sat")
                                            .font(.subheadline)
                                            .foregroundColor(.secondary)
                                    }
                                }
                                Divider()
                                HStack {
                                    Text("Total Payment")
                                        .font(.headline)
                                        .fontWeight(.medium)
                                    Spacer()
                                    Text("\(amount + 1) sats")
                                        .font(.headline)
                                        .fontWeight(.bold)
                                        .foregroundColor(amount + 1 > availableBalance ? .red : .orange)
                                }
                            }
                            .padding(20)
                            .background(Color(UIColor.systemGray6))
                            .cornerRadius(16)
                        } else {
                            VStack(spacing: 12) {
                                Image(systemName: "exclamationmark.triangle")
                                    .font(.system(size: 30))
                                    .foregroundColor(.orange)
                                Text("Invalid Invoice")
                                    .font(.headline)
                                    .fontWeight(.medium)
                                Text("Unable to decode the lightning invoice")
                                    .font(.subheadline)
                                    .foregroundColor(.secondary)
                                    .multilineTextAlignment(.center)
                            }
                            .padding(20)
                            .background(Color(UIColor.systemGray6))
                            .cornerRadius(16)
                        }
                    }
                    // Description if available
                    if let description = decodedDescription, !description.isEmpty {
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Description")
                                .font(.headline)
                                .fontWeight(.medium)
                            Text(description)
                                .font(.body)
                                .foregroundColor(.secondary)
                                .padding(12)
                                .background(Color(UIColor.systemGray6))
                                .cornerRadius(12)
                        }
                    }
                    // Balance Check
                    if let amount = decodedAmount {
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Your Balance")
                                .font(.headline)
                                .fontWeight(.medium)
                            HStack {
                                Text("\(availableBalance) sats")
                                    .font(.title2)
                                    .fontWeight(.medium)
                                Spacer()
                                if amount + 1 > availableBalance {
                                    Text("Insufficient balance")
                                        .font(.subheadline)
                                        .foregroundColor(.red)
                                } else {
                                    Text("✓ Sufficient balance")
                                        .font(.subheadline)
                                        .foregroundColor(.green)
                                }
                            }
                            .padding(12)
                            .background(Color(UIColor.systemGray6))
                            .cornerRadius(12)
                        }
                    }
                    Spacer(minLength: 20)
                }
                .padding(.horizontal, 20)
            }
            .navigationTitle("Payment Preview")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: payInvoice) {
                        if isPaying {
                            ProgressView()
                                .scaleEffect(0.8)
                        } else {
                            Text("Pay")
                                .fontWeight(.semibold)
                        }
                    }
                    .disabled(decodedAmount == nil || isPaying || (decodedAmount ?? 0) + 1 > availableBalance)
                }
            }
        }
        .onAppear {
            decodeInvoice()
            loadBalance()
        }
        .alert("Error", isPresented: $showError) {
            Button("OK") { }
        } message: {
            Text(errorMessage)
        }
        .sheet(isPresented: $showSuccess) {
            if let amount = decodedAmount {
                NavigationStack {
                    VStack(spacing: 30) {
                        Image(systemName: "checkmark.circle.fill")
                            .font(.system(size: 60))
                            .foregroundStyle(.green)
                            .padding(.top, 40)
                        VStack(spacing: 8) {
                            Text("Payment Successful!")
                                .font(.title)
                                .fontWeight(.bold)
                            Text("\(Int(amount)) sats")
                                .font(.largeTitle)
                                .fontWeight(.semibold)
                        }
                        Spacer()
                        Button("Done") {
                            showSuccess = false
                            dismiss()
                        }
                        .buttonStyle(.borderedProminent)
                        .tint(.orange)
                        .controlSize(.large)
                        .padding(.bottom)
                    }
                    .padding()
                    .navigationTitle("Success")
                    .navigationBarTitleDisplayMode(.inline)
                }
            }
        }
    }
    private func decodeInvoice() {
        var cleanInvoice = invoice.trimmingCharacters(in: .whitespacesAndNewlines)
        if cleanInvoice.starts(with: "lightning:") {
            cleanInvoice = String(cleanInvoice.dropFirst(10))
        }
        if cleanInvoice.lowercased().starts(with: "lnbc") || cleanInvoice.lowercased().starts(with: "lntb") || cleanInvoice.lowercased().starts(with: "lnbcrt") {
            let trimmed = cleanInvoice.dropFirst(4)
            var amountStr = ""
            var multiplier: Int64 = 1
            for char in trimmed {
                if char.isNumber {
                    amountStr.append(char)
                } else if char == "m" {
                    multiplier = 100
                    break
                } else if char == "u" {
                    multiplier = 100000
                    break
                } else if char == "n" {
                    multiplier = 100000000
                    break
                } else if char == "p" {
                    multiplier = 100000000000
                    break
                } else {
                    break
                }
            }
            if let amount = Int64(amountStr) {
                decodedAmount = (amount * multiplier) / 1000
            }
            decodedDescription = "Lightning payment"
        }
    }
    private func loadBalance() {
        Task {
            do {
                guard let wallet = walletManager.wallet else { return }
                let balance = try await wallet.getBalance() ?? 0
                await MainActor.run {
                    availableBalance = Int(balance)
                }
            } catch {
                print("Failed to get balance: \(error)")
            }
        }
    }
    private func payInvoice() {
        guard let amount = decodedAmount else { return }
        isPaying = true
        Task {
            do {
                _ = try await walletManager.payLightning(
                    invoice: invoice.trimmingCharacters(in: .whitespacesAndNewlines),
                    amount: amount
                )
                // Transaction will be recorded automatically via NIP-60 history events
                await MainActor.run {
                    showSuccess = true
                    isPaying = false
                }
            } catch {
                await MainActor.run {
                    errorMessage = error.localizedDescription
                    showError = true
                    isPaying = false
                }
            }
        }
    }
}
</file>

<file path="Sources/NutsackiOS/Views/NutzapSettingsView.swift">
import SwiftUI
import NDKSwift
struct NutzapSettingsView: View {
    @Environment(WalletManager.self) private var walletManager
    @EnvironmentObject private var nostrManager: NostrManager
    @State private var p2pkPubkey: String = ""
    @State private var showError = false
    @State private var errorMessage = ""
    @State private var copiedToClipboard = false
    var body: some View {
        Form {
            publicKeySection
            mintsSection
        }
        .navigationTitle("Zap Settings")
        .platformNavigationBarTitleDisplayMode(inline: true)
        .alert("Error", isPresented: $showError) {
            Button("OK") { }
        } message: {
            Text(errorMessage)
        }
        .task {
            await loadP2PKPubkey()
        }
    }
    private var publicKeySection: some View {
        Section {
            VStack(alignment: .leading, spacing: 12) {
                Label("P2PK Public Key", systemImage: "key")
                    .font(.caption)
                    .foregroundStyle(.secondary)
                HStack {
                    Text(p2pkPubkey.isEmpty ? "Loading..." : p2pkPubkey)
                        .font(.system(.caption, design: .monospaced))
                        .lineLimit(3)
                        .multilineTextAlignment(.leading)
                        .textSelection(.enabled)
                    Spacer()
                    #if os(iOS)
                    Button(action: copyPubkey) {
                        Image(systemName: copiedToClipboard ? "checkmark" : "doc.on.doc")
                            .foregroundColor(.orange)
                    }
                    .buttonStyle(.plain)
                    #endif
                }
                .padding()
                .background(Color.secondary.opacity(0.1))
                .cornerRadius(8)
            }
        } header: {
            Text("Your Zap Receiving Key")
        } footer: {
            Text("This is your wallet's P2PK public key. Others need this to send you zaps.")
        }
    }
    private var mintsSection: some View {
        Section {
            AsyncContentView(
                operation: {
                    guard let wallet = walletManager.wallet else { return [] }
                    let mintStrings = await wallet.mints.getMintURLs()
                    let mintURLs = mintStrings.compactMap { URL(string: $0) }
                    return mintURLs.map { MintInfo(url: $0) }
                }
            ) { (mints: [MintInfo]) in
                ForEach(Array(mints.enumerated()), id: \.offset) { (_, mint) in
                    HStack {
                        Image(systemName: "building.columns")
                            .foregroundColor(.orange)
                        VStack(alignment: .leading) {
                            Text(mint.url.host ?? mint.url.absoluteString)
                                .font(.subheadline)
                            Text(mint.url.absoluteString)
                                .font(.caption2)
                                .foregroundStyle(.secondary)
                        }
                    }
                }
            }
        } header: {
            Text("Accepted Mints")
        } footer: {
            Text("People can only send you zaps using these mints")
        }
    }
    private func loadP2PKPubkey() async {
        do {
            let pubkey = try await walletManager.getP2PKPubkey()
            await MainActor.run {
                p2pkPubkey = pubkey
            }
        } catch {
            await MainActor.run {
                errorMessage = "Failed to load P2PK public key: \(error.localizedDescription)"
                showError = true
            }
        }
    }
    #if os(iOS)
    private func copyPubkey() {
        UIPasteboard.general.string = p2pkPubkey
        withAnimation(.easeInOut(duration: 0.2)) {
            copiedToClipboard = true
        }
        // Reset after 2 seconds
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            withAnimation {
                copiedToClipboard = false
            }
        }
    }
    #endif
}
</file>

<file path="Sources/NutsackiOS/Views/SettingsView.swift">
import SwiftUI
import NDKSwift
struct SettingsView: View {
    @EnvironmentObject private var appState: AppState
    @EnvironmentObject private var nostrManager: NostrManager
    @Environment(WalletManager.self) private var walletManager
    @State private var currentUser: NDKUser?
    @State private var copiedNpub = false
    var body: some View {
        NavigationStack {
            List {
                // Account section
                Section {
                    if let currentUser = currentUser {
                        NavigationLink(destination: AccountDetailView(user: currentUser, metadata: nil)) {
                            HStack {
                                // Profile picture
                                UserProfilePicture(user: currentUser, size: 50)
                                VStack(alignment: .leading, spacing: 4) {
                                    UserDisplayName(user: currentUser)
                                        .font(.headline)
                                    HStack(spacing: 4) {
                                        Text(String(currentUser.npub.prefix(16)) + "...")
                                            .font(.caption)
                                            .foregroundStyle(.secondary)
                                        Button(action: { copyNpub(currentUser.npub) }) {
                                            Image(systemName: copiedNpub ? "checkmark.circle.fill" : "doc.on.doc")
                                                .font(.caption)
                                                .foregroundColor(copiedNpub ? .green : .secondary)
                                        }
                                        .buttonStyle(.plain)
                                    }
                                }
                                Spacer()
                                Image(systemName: "chevron.right")
                                    .font(.caption)
                                    .foregroundStyle(.tertiary)
                            }
                        }
                    } else {
                        Text("No user logged in")
                            .foregroundStyle(.secondary)
                    }
                } header: {
                    Text("Account")
                }
                // Preferences
                Section {
                    Picker("Theme", selection: $appState.themeMode) {
                        ForEach(ThemeMode.allCases, id: \.self) { mode in
                            Text(mode.displayName).tag(mode)
                        }
                    }
                    Picker("Currency", selection: $appState.preferredConversionUnit) {
                        ForEach(CurrencyUnit.allCases, id: \.self) { unit in
                            Text(unit.symbol).tag(unit)
                        }
                    }
                    NavigationLink(destination: RelayManagementView()) {
                        Label("Relays", systemImage: "network")
                    }
                    NavigationLink(destination: BackupView()) {
                        Label("Backup", systemImage: "lock.shield")
                    }
                    NavigationLink(destination: UnpublishedEventsView()) {
                        HStack {
                            Label("Unpublished Events", systemImage: "clock.arrow.circlepath")
                            Spacer()
                            UnpublishedEventsBadge()
                        }
                    }
                } header: {
                    Text("Preferences")
                }
                // Blacklisted Mints Section
                Section {
                    NavigationLink(destination: BlacklistedMintsView()) {
                        HStack {
                            Label("Blacklisted Mints", systemImage: "xmark.shield")
                            Spacer()
                            if !appState.blacklistedMints.isEmpty {
                                Text("\(appState.blacklistedMints.count)")
                                    .font(.caption)
                                    .foregroundColor(.white)
                                    .padding(.horizontal, 8)
                                    .padding(.vertical, 4)
                                    .background(Color.red)
                                    .clipShape(Capsule())
                            }
                        }
                    }
                } header: {
                    Text("Security")
                } footer: {
                    Text("Manage mints that are blocked from being used in your wallet")
                }
                // Nutzap Settings
                Section {
                    NavigationLink(destination: NutzapSettingsView()) {
                        Label("Zap Settings", systemImage: "bolt.heart")
                    }
                    NavigationLink(destination: WalletEventsView()) {
                        Label("Wallet Events", systemImage: "list.bullet.rectangle")
                    }
                    NavigationLink(destination: RelayHealthView()) {
                        Label("Relay Health", systemImage: "antenna.radiowaves.left.and.right")
                    }
                    NavigationLink(destination: ProofManagementView()) {
                        Label("Manage Proofs", systemImage: "key")
                    }
                    NavigationLink(destination: ReceivedNutzapsView(walletManager: walletManager)) {
                        Label("Received Zaps", systemImage: "bolt.fill")
                    }
                } header: {
                    Text("Wallet")
                } footer: {
                    Text("Configure how others can send zaps to your wallet")
                }
                // Debug section
                #if DEBUG
                Section {
                    NavigationLink(destination: DebugView()) {
                        Label("Debug", systemImage: "ladybug")
                    }
                    Toggle(isOn: $appState.debugSimulateMintFailure) {
                        Label("Simulate Mint Failures", systemImage: "exclamationmark.triangle")
                    }
                } header: {
                    Text("Debug")
                } footer: {
                    Text("When enabled, mint operations will fail after payment to test error handling")
                }
                #endif
                // Danger zone
                Section {
                    Button(role: .destructive, action: logout) {
                        Label("Sign Out", systemImage: "rectangle.portrait.and.arrow.right")
                    }
                }
            }
            .navigationTitle("Settings")
            #if os(iOS)
            .navigationBarTitleDisplayMode(.inline)
            #endif
            .safeAreaInset(edge: .bottom) {
                Text("Version 1.0.0")
                    .font(.caption)
                    .foregroundStyle(.secondary)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 8)
                    .background(Color(UIColor.systemGroupedBackground))
            }
            .task {
                await loadUserData()
            }
        }
    }
    private func copyNpub(_ npub: String) {
        #if os(iOS)
        UIPasteboard.general.string = npub
        #else
        NSPasteboard.general.clearContents()
        NSPasteboard.general.setString(npub, forType: .string)
        #endif
        withAnimation {
            copiedNpub = true
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            withAnimation {
                copiedNpub = false
            }
        }
    }
    private func loadUserData() async {
        let ndk = nostrManager.ndk
        guard let signer = ndk.signer else { return }
        do {
            let pubkey = try await signer.pubkey
            currentUser = NDKUser(pubkey: pubkey)
        } catch {
            print("Failed to get current user: \(error)")
        }
    }
    private func logout() {
        // Clear wallet data and cancel subscriptions
        walletManager.clearWalletData()
        // Clear authentication data
        Task {
            await nostrManager.logout()
        }
    }
}
// MARK: - Account Detail View
struct AccountDetailView: View {
    let user: NDKUser
    let metadata: NDKUserMetadata?
    @EnvironmentObject private var nostrManager: NostrManager
    @State private var showPrivateKey = false
    @State private var copiedKey = false
    @State private var copiedNpub = false
    @State private var nsecKey: String?
    @State private var userMetadata: NDKUserMetadata?
    var npub: String {
        user.npub
    }
    var body: some View {
        List {
            Section {
                LabeledContent("Display Name", value: displayName)
                if let about = userMetadata?.about ?? metadata?.about {
                    LabeledContent("About") {
                        Text(about)
                            .font(.caption)
                    }
                }
                if let nip05 = userMetadata?.nip05 ?? metadata?.nip05 {
                    LabeledContent("NIP-05", value: nip05)
                }
            } header: {
                Text("Profile")
            }
            Section {
                VStack(alignment: .leading, spacing: 8) {
                    HStack {
                        Text("Public Key (npub)")
                        Spacer()
                    }
                    Text(npub)
                        .font(.caption)
                        .textSelection(.enabled)
                    Button(action: copyPublicKey) {
                        Label(
                            copiedNpub ? "Copied!" : "Copy npub",
                            systemImage: copiedNpub ? "checkmark.circle.fill" : "doc.on.doc"
                        )
                    }
                    .buttonStyle(.bordered)
                    .controlSize(.small)
                    .tint(copiedNpub ? .green : .blue)
                }
                if let nsecKey = nsecKey {
                    VStack(alignment: .leading, spacing: 8) {
                        HStack {
                            Text("Private Key (nsec)")
                            Spacer()
                            Button(action: togglePrivateKey) {
                                Image(systemName: showPrivateKey ? "eye.slash" : "eye")
                            }
                            .buttonStyle(.plain)
                        }
                        if showPrivateKey {
                            Text(nsecKey)
                                .font(.caption)
                                .textSelection(.enabled)
                            Button(action: copyPrivateKey) {
                                Label(
                                    copiedKey ? "Copied!" : "Copy Private Key",
                                    systemImage: copiedKey ? "checkmark.circle.fill" : "doc.on.doc"
                                )
                            }
                            .buttonStyle(.bordered)
                            .controlSize(.small)
                            .tint(copiedKey ? .green : .orange)
                        }
                    }
                } else {
                    Text("Private key access through secure authentication")
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }
            } header: {
                Text("Keys")
            } footer: {
                Text("Keep your private key secure. Anyone with this key can access your account.")
                    .foregroundStyle(.red)
            }
        }
        .navigationTitle("Account")
        #if os(iOS)
        .navigationBarTitleDisplayMode(.inline)
        #endif
        .onAppear {
            loadPrivateKey()
            Task {
                await loadUserMetadata()
            }
        }
    }
    private func loadPrivateKey() {
        guard let signer = nostrManager.ndk.signer as? NDKPrivateKeySigner else {
            nsecKey = nil
            return
        }
        Task {
            do {
                let nsec = try signer.nsec
                await MainActor.run {
                    nsecKey = nsec
                }
            } catch {
                print("Failed to load private key: \(error)")
                await MainActor.run {
                    nsecKey = nil
                }
            }
        }
    }
    private func togglePrivateKey() {
        withAnimation {
            showPrivateKey.toggle()
        }
    }
    private func copyPublicKey() {
        #if os(iOS)
        UIPasteboard.general.string = npub
        #else
        NSPasteboard.general.clearContents()
        NSPasteboard.general.setString(npub, forType: .string)
        #endif
        withAnimation {
            copiedNpub = true
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            withAnimation {
                copiedNpub = false
            }
        }
    }
    private func copyPrivateKey() {
        guard let nsec = nsecKey else { return }
        #if os(iOS)
        UIPasteboard.general.string = nsec
        #else
        NSPasteboard.general.clearContents()
        NSPasteboard.general.setString(nsec, forType: .string)
        #endif
        withAnimation {
            copiedKey = true
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            withAnimation {
                copiedKey = false
            }
        }
    }
    private var displayName: String {
        userMetadata?.displayName ?? userMetadata?.name ?? metadata?.displayName ?? metadata?.name ?? "Nostr User"
    }
    private func loadUserMetadata() async {
        guard let profileManager = nostrManager.profileManager else { return }
        for await metadata in profileManager.subscribe(for: user.pubkey, maxAge: 3600) {
            await MainActor.run {
                userMetadata = metadata
            }
            break // We only need the first result
        }
    }
}
// MARK: - Backup View
struct BackupView: View {
    var body: some View {
        List {
            Section {
                Text("Backup features coming soon")
                    .foregroundStyle(.secondary)
            } header: {
                Text("Wallet Backup")
            } footer: {
                Text("Your wallets are automatically backed up to Nostr using NIP-60")
            }
        }
        .navigationTitle("Backup")
        #if os(iOS)
        .navigationBarTitleDisplayMode(.inline)
        #endif
    }
}
// MARK: - About View
struct AboutView: View {
    var body: some View {
        ScrollView {
            VStack(spacing: 30) {
                // Logo
                Image(systemName: "banknote.fill")
                    .font(.system(size: 80))
                    .foregroundStyle(.orange.gradient)
                    .padding(.top, 40)
                Text("Nutsack")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                Text("Lightning-fast payments with Nostr")
                    .font(.subheadline)
                    .foregroundStyle(.secondary)
                // Description
                VStack(alignment: .leading, spacing: 16) {
                    Text("About")
                        .font(.headline)
                    Text("""
                    Nutsack is a Cashu ecash wallet that integrates seamlessly with Nostr. It implements NIP-60 for wallet backup and NIP-61 for nutzaps.
                    Built with NDKSwift, this wallet showcases the power of combining ecash with the Nostr protocol for a truly decentralized payment experience.
                    """)
                    .font(.body)
                    .foregroundStyle(.secondary)
                }
                .padding(.horizontal)
                Spacer(minLength: 40)
            }
        }
        .navigationTitle("About")
        #if os(iOS)
        .navigationBarTitleDisplayMode(.inline)
        #endif
    }
}
// MARK: - Unpublished Events Badge
struct UnpublishedEventsBadge: View {
    @EnvironmentObject private var nostrManager: NostrManager
    @State private var unpublishedCount = 0
    @State private var timer: Timer?
    var body: some View {
        Group {
            if unpublishedCount > 0 {
                Text("\(unpublishedCount)")
                    .font(.caption)
                    .foregroundColor(.white)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(Color.orange)
                    .clipShape(Capsule())
            }
        }
        .onAppear {
            updateUnpublishedCount()
            startPeriodicUpdate()
        }
        .onDisappear {
            timer?.invalidate()
            timer = nil
        }
    }
    private func updateUnpublishedCount() {
        Task {
            guard let cache = nostrManager.cache else { return }
            let unpublishedEvents = await cache.getUnpublishedEvents(maxAge: 3600, limit: nil)
            await MainActor.run {
                unpublishedCount = unpublishedEvents.count
            }
        }
    }
    private func startPeriodicUpdate() {
        timer = Timer.scheduledTimer(withTimeInterval: 30, repeats: true) { _ in
            updateUnpublishedCount()
        }
    }
}
// MARK: - Unpublished Events View
struct UnpublishedEventsView: View {
    @EnvironmentObject private var nostrManager: NostrManager
    @State private var unpublishedEvents: [(event: NDKEvent, targetRelays: Set<String>)] = []
    @State private var isLoading = true
    @State private var isRetrying = false
    @State private var lastRetryTime: Date?
    @State private var showRetrySuccess = false
    @State private var retriedCount = 0
    @State private var selectedEvent: NDKEvent?
    @State private var showingEventDetails = false
    var body: some View {
        List {
            // Status Section
                Section {
                    HStack {
                        VStack(alignment: .leading, spacing: 4) {
                            if isLoading {
                                Text("Checking...")
                                    .font(.caption)
                                    .foregroundStyle(.secondary)
                            } else {
                                Text("\(unpublishedEvents.count) events pending")
                                    .font(.caption)
                                    .foregroundStyle(.secondary)
                            }
                        }
                        Spacer()
                        if isLoading {
                            ProgressView()
                                .scaleEffect(0.8)
                        } else if unpublishedEvents.count > 0 {
                            Button(action: retryAllEvents) {
                                if isRetrying {
                                    ProgressView()
                                        .scaleEffect(0.8)
                                } else {
                                    Text("Retry All")
                                        .foregroundColor(.orange)
                                }
                            }
                            .disabled(isRetrying)
                        }
                    }
                    .padding(.vertical, 4)
                    if let lastRetryTime = lastRetryTime {
                        Text("Last retry: \(lastRetryTime, style: .relative)")
                            .font(.caption)
                            .foregroundStyle(.secondary)
                    }
                } header: {
                    Text("Status")
                }
                // Events List
                if !unpublishedEvents.isEmpty {
                    Section {
                        ForEach(Array(unpublishedEvents.enumerated()), id: \.offset) { index, eventInfo in
                            UnpublishedEventRow(
                                event: eventInfo.event,
                                targetRelays: eventInfo.targetRelays,
                                onRetry: {
                                    retryEvent(at: index)
                                },
                                onTap: {
                                    selectedEvent = eventInfo.event
                                    showingEventDetails = true
                                }
                            )
                        }
                    } header: {
                        Text("Pending Events")
                    } footer: {
                        Text("These events were published optimistically but haven't been confirmed by relays yet. You can retry individual events or all at once.")
                    }
                } else if !isLoading {
                    Section {
                        VStack(spacing: 16) {
                            Image(systemName: "checkmark.circle.fill")
                                .font(.system(size: 48))
                                .foregroundColor(.green)
                            Text("All events published successfully!")
                                .font(.headline)
                                .multilineTextAlignment(.center)
                            Text("Your events have been confirmed by the relays.")
                                .font(.subheadline)
                                .foregroundStyle(.secondary)
                                .multilineTextAlignment(.center)
                        }
                        .padding(.vertical, 20)
                        .frame(maxWidth: .infinity)
                    }
                }
            }
        .navigationTitle("Unpublished Events")
        #if os(iOS)
        .navigationBarTitleDisplayMode(.large)
        #endif
        .refreshable {
            await loadUnpublishedEvents()
        }
        .onAppear {
            Task {
                await loadUnpublishedEvents()
            }
        }
        .alert("Retry Successful", isPresented: $showRetrySuccess) {
            Button("OK") { }
        } message: {
            Text("Successfully retried \(retriedCount) events")
        }
        .sheet(isPresented: $showingEventDetails) {
            if let event = selectedEvent {
                UnpublishedEventDetailView(event: event)
            }
        }
    }
    private func loadUnpublishedEvents() async {
        guard let cache = nostrManager.cache else {
            await MainActor.run {
                isLoading = false
            }
            return
        }
        let events = await cache.getUnpublishedEvents(maxAge: 3600, limit: nil)
        await MainActor.run {
            unpublishedEvents = events
            isLoading = false
        }
    }
    private func retryAllEvents() {
        let ndk = nostrManager.ndk
        isRetrying = true
        Task {
            do {
                let retriedEvents = try await ndk.retryUnpublishedEvents(maxAge: 3600, limit: nil)
                await MainActor.run {
                    isRetrying = false
                    lastRetryTime = Date()
                    retriedCount = retriedEvents.count
                    showRetrySuccess = true
                }
                // Reload the list
                await loadUnpublishedEvents()
            } catch {
                await MainActor.run {
                    isRetrying = false
                }
                print("Failed to retry events: \(error)")
            }
        }
    }
    private func retryEvent(at index: Int) {
        let ndk = nostrManager.ndk
        guard index < unpublishedEvents.count else { return }
        let eventInfo = unpublishedEvents[index]
        Task {
            do {
                _ = try await ndk.publish(eventInfo.event)
                // Reload the list
                await loadUnpublishedEvents()
            } catch {
                print("Failed to retry individual event: \(error)")
            }
        }
    }
}
// MARK: - Unpublished Event Row
struct UnpublishedEventRow: View {
    let event: NDKEvent
    let targetRelays: Set<String>
    let onRetry: () -> Void
    let onTap: () -> Void
    @State private var isRetrying = false
    var body: some View {
        HStack {
            VStack(alignment: .leading, spacing: 8) {
                // Event content preview
                HStack {
                    VStack(alignment: .leading, spacing: 4) {
                        Text(eventKindName)
                            .font(.subheadline)
                            .fontWeight(.medium)
                        if !event.content.isEmpty {
                            Text(event.content)
                                .font(.caption)
                                .foregroundStyle(.secondary)
                                .lineLimit(3)
                        }
                    }
                    Spacer()
                }
                // Metadata
                HStack {
                    Text("Created: \(Date(timeIntervalSince1970: TimeInterval(event.createdAt)), style: .relative)")
                        .font(.caption2)
                        .foregroundStyle(.tertiary)
                    Spacer()
                    Text("\(targetRelays.count) relays")
                        .font(.caption2)
                        .foregroundStyle(.tertiary)
                }
                // Target relays (abbreviated)
                if !targetRelays.isEmpty {
                    Text("Targets: \(abbreviatedRelayList)")
                        .font(.caption2)
                        .foregroundStyle(.tertiary)
                        .lineLimit(1)
                }
            }
            Spacer()
            Button(action: retryEvent) {
                if isRetrying {
                    ProgressView()
                        .scaleEffect(0.7)
                } else {
                    Image(systemName: "arrow.clockwise")
                        .foregroundColor(.orange)
                }
            }
            .disabled(isRetrying)
            .buttonStyle(.plain)
        }
        .contentShape(Rectangle())
        .onTapGesture(perform: onTap)
        .padding(.vertical, 4)
    }
    private var eventKindName: String {
        switch event.kind {
        case 0: return "Profile"
        case 1: return "Note"
        case 3: return "Contacts"
        case 4: return "Direct Message"
        case 5: return "Deletion"
        case 6: return "Repost"
        case 7: return "Reaction"
        case 17375: return "NIP-60 Wallet"
        default: return "Event \(event.kind)"
        }
    }
    private var abbreviatedRelayList: String {
        let sorted = targetRelays.sorted()
        if sorted.count <= 2 {
            return sorted.map { shortRelayName($0) }.joined(separator: ", ")
        } else {
            let first = sorted.prefix(2).map { shortRelayName($0) }
            return first.joined(separator: ", ") + " +\(sorted.count - 2)"
        }
    }
    private func shortRelayName(_ url: String) -> String {
        guard let host = URL(string: url)?.host else { return url }
        // Remove common prefixes and show just the domain
        return host.replacingOccurrences(of: "www.", with: "")
            .replacingOccurrences(of: "relay.", with: "")
    }
    private func retryEvent() {
        isRetrying = true
        onRetry()
        // Reset retry state after a delay
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            isRetrying = false
        }
    }
}
// MARK: - Debug View
#if DEBUG
struct DebugView: View {
    @EnvironmentObject private var nostrManager: NostrManager
    @State private var cacheStats: CacheStatistics?
    @State private var isLoading = false
    @State private var errorMessage: String?
    @State private var lastUpdateTime: Date?
    var body: some View {
        NavigationStack {
            List {
                // Cache Statistics Section
                Section {
                    NavigationLink(destination: CacheStatsView()) {
                        HStack {
                            Label("Cache Statistics", systemImage: "cylinder.split.1x2")
                            Spacer()
                            if let stats = cacheStats {
                                Text("\(stats.totalEvents) events")
                                    .foregroundStyle(.secondary)
                            }
                        }
                    }
                } header: {
                    Text("Database")
                } footer: {
                    if let lastUpdate = lastUpdateTime {
                        Text("Last updated: \(lastUpdate, style: .relative)")
                    } else {
                        Text("View detailed cache statistics and event counts")
                    }
                }
                // Quick Stats Overview
                if let stats = cacheStats {
                    Section {
                        VStack(alignment: .leading, spacing: 12) {
                            HStack {
                                Image(systemName: "cylinder.fill")
                                    .foregroundColor(.blue)
                                Text("Cache Overview")
                                    .font(.headline)
                            }
                            Grid(alignment: .leading, horizontalSpacing: 16, verticalSpacing: 8) {
                                GridRow {
                                    Text("Total Events:")
                                        .foregroundStyle(.secondary)
                                    Text("\(stats.totalEvents)")
                                        .fontWeight(.medium)
                                }
                                GridRow {
                                    Text("Event Types:")
                                        .foregroundStyle(.secondary)
                                    Text("\(stats.eventsByKind.count) kinds")
                                        .fontWeight(.medium)
                                }
                                GridRow {
                                    Text("Most Common:")
                                        .foregroundStyle(.secondary)
                                    Text(stats.mostCommonKind)
                                        .fontWeight(.medium)
                                }
                            }
                            .font(.subheadline)
                        }
                        .padding(.vertical, 8)
                    } header: {
                        Text("Quick Stats")
                    }
                }
                // Error Display
                if let error = errorMessage {
                    Section {
                        Text(error)
                            .foregroundColor(.red)
                            .font(.caption)
                    } header: {
                        Text("Error")
                    }
                }
            }
            .navigationTitle("Debug")
            #if os(iOS)
            .navigationBarTitleDisplayMode(.inline)
            #endif
            .refreshable {
                await loadCacheStats()
            }
            .onAppear {
                Task {
                    await loadCacheStats()
                }
            }
        }
    }
    private func loadCacheStats() async {
        guard let cache = nostrManager.cache else {
            await MainActor.run {
                errorMessage = "No cache available"
                isLoading = false
            }
            return
        }
        await MainActor.run {
            isLoading = true
            errorMessage = nil
        }
        do {
            // Query all events to get statistics
            let filter = NDKFilter() // Empty filter to get all events
            let allEvents = try await cache.queryEvents(filter)
            // Group events by kind
            var eventsByKind: [Int: Int] = [:]
            for event in allEvents {
                eventsByKind[event.kind, default: 0] += 1
            }
            let stats = CacheStatistics(
                totalEvents: allEvents.count,
                eventsByKind: eventsByKind
            )
            await MainActor.run {
                cacheStats = stats
                lastUpdateTime = Date()
                isLoading = false
            }
        } catch {
            await MainActor.run {
                errorMessage = "Failed to load cache stats: \(error.localizedDescription)"
                isLoading = false
            }
        }
    }
}
// MARK: - Cache Statistics View
struct CacheStatsView: View {
    @EnvironmentObject private var nostrManager: NostrManager
    @State private var cacheStats: CacheStatistics?
    @State private var isLoading = true
    @State private var errorMessage: String?
    var body: some View {
        List {
            // Total Events Section
            Section {
                if let stats = cacheStats {
                    HStack {
                        Image(systemName: "cylinder.fill")
                            .foregroundColor(.blue)
                        VStack(alignment: .leading, spacing: 4) {
                            Text("Total Events")
                                .font(.headline)
                            Text("\(stats.totalEvents) events in database")
                                .font(.subheadline)
                                .foregroundStyle(.secondary)
                        }
                        Spacer()
                        Text("\(stats.totalEvents)")
                            .font(.title2)
                            .fontWeight(.bold)
                            .foregroundColor(.blue)
                    }
                    .padding(.vertical, 8)
                } else if isLoading {
                    HStack {
                        ProgressView()
                            .scaleEffect(0.8)
                        Text("Loading cache statistics...")
                            .foregroundStyle(.secondary)
                    }
                } else {
                    Text("No cache data available")
                        .foregroundStyle(.secondary)
                }
            } header: {
                Text("Overview")
            }
            // Events by Kind Section
            if let stats = cacheStats, !stats.eventsByKind.isEmpty {
                Section {
                    ForEach(stats.sortedEventKinds, id: \.kind) { kindStat in
                        HStack {
                            Text("Kind \(kindStat.kind)")
                                .font(.subheadline)
                                .fontWeight(.medium)
                            Spacer()
                            Text("\(kindStat.count)")
                                .font(.subheadline)
                                .fontWeight(.medium)
                        }
                        .padding(.vertical, 4)
                    }
                } header: {
                    Text("Events by Kind")
                } footer: {
                    Text("Breakdown of events stored in the cache by Nostr event kind")
                }
            }
            // Error Display
            if let error = errorMessage {
                Section {
                    Text(error)
                        .foregroundColor(.red)
                        .font(.caption)
                } header: {
                    Text("Error")
                }
            }
        }
        .navigationTitle("Cache Statistics")
        #if os(iOS)
        .navigationBarTitleDisplayMode(.inline)
        #endif
        .refreshable {
            await loadCacheStats()
        }
        .onAppear {
            Task {
                await loadCacheStats()
            }
        }
    }
    private func loadCacheStats() async {
        guard let cache = nostrManager.cache else {
            await MainActor.run {
                errorMessage = "No cache available"
                isLoading = false
            }
            return
        }
        await MainActor.run {
            isLoading = true
            errorMessage = nil
        }
        do {
            // Query all events to get statistics
            let filter = NDKFilter() // Empty filter to get all events
            let allEvents = try await cache.queryEvents(filter)
            // Group events by kind
            var eventsByKind: [Int: Int] = [:]
            for event in allEvents {
                eventsByKind[event.kind, default: 0] += 1
            }
            let stats = CacheStatistics(
                totalEvents: allEvents.count,
                eventsByKind: eventsByKind
            )
            await MainActor.run {
                cacheStats = stats
                isLoading = false
            }
        } catch {
            await MainActor.run {
                errorMessage = "Failed to load cache stats: \(error.localizedDescription)"
                isLoading = false
            }
        }
    }
}
#endif
// MARK: - Cache Statistics Extensions
extension CacheStatistics {
    var sortedEventKinds: [EventKindStatistic] {
        eventsByKind.map { kind, count in
            EventKindStatistic(kind: kind, count: count)
        }.sorted { $0.count > $1.count }
    }
    var mostCommonKind: String {
        guard let mostCommon = sortedEventKinds.first else { return "None" }
        return "Kind \(mostCommon.kind) (\(mostCommon.count))"
    }
}
struct EventKindStatistic {
    let kind: Int
    let count: Int
}
// MARK: - Unpublished Event Detail View
struct UnpublishedEventDetailView: View {
    let event: NDKEvent
    @Environment(\.dismiss) private var dismiss
    @State private var copiedToClipboard = false
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(alignment: .leading, spacing: 16) {
                    // Event Metadata
                    VStack(alignment: .leading, spacing: 8) {
                            HStack {
                                Text("Event ID")
                                    .font(.caption)
                                    .foregroundStyle(.secondary)
                                Spacer()
                            }
                            Text(event.id)
                                .font(.system(.caption, design: .monospaced))
                                .textSelection(.enabled)
                        }
                        VStack(alignment: .leading, spacing: 8) {
                            HStack {
                                Text("Kind")
                                    .font(.caption)
                                    .foregroundStyle(.secondary)
                                Spacer()
                            }
                            Text("\(event.kind)")
                                .font(.system(.body, design: .monospaced))
                        }
                        VStack(alignment: .leading, spacing: 8) {
                            HStack {
                                Text("Created At")
                                    .font(.caption)
                                    .foregroundStyle(.secondary)
                                Spacer()
                            }
                            Text("\(Date(timeIntervalSince1970: TimeInterval(event.createdAt)), formatter: DateFormatter.fullDateTimeFormatter)")
                                .font(.system(.caption, design: .monospaced))
                        }
                        VStack(alignment: .leading, spacing: 8) {
                            HStack {
                                Text("Author")
                                    .font(.caption)
                                    .foregroundStyle(.secondary)
                                Spacer()
                            }
                            Text(NDKUser(pubkey: event.pubkey).npub)
                                .font(.system(.caption, design: .monospaced))
                                .textSelection(.enabled)
                        }
                    .padding()
                    .background(Color(UIColor.secondarySystemBackground))
                    .clipShape(RoundedRectangle(cornerRadius: 10))
                    // Tags
                    if !event.tags.isEmpty {
                        VStack(alignment: .leading, spacing: 8) {
                                Text("Tags")
                                    .font(.headline)
                                    .padding(.bottom, 4)
                                ForEach(Array(event.tags.enumerated()), id: \.offset) { index, tag in
                                    HStack(alignment: .top, spacing: 8) {
                                        Text("\(index)")
                                            .font(.caption)
                                            .foregroundStyle(.secondary)
                                            .frame(width: 20, alignment: .trailing)
                                        Text(tag.joined(separator: ", "))
                                            .font(.system(.caption, design: .monospaced))
                                            .textSelection(.enabled)
                                            .frame(maxWidth: .infinity, alignment: .leading)
                                    }
                                    .padding(.vertical, 2)
                                }
                        }
                        .padding()
                        .background(Color(UIColor.secondarySystemBackground))
                        .clipShape(RoundedRectangle(cornerRadius: 10))
                    }
                    // Content
                    if !event.content.isEmpty {
                        VStack(alignment: .leading, spacing: 8) {
                                Text("Content")
                                    .font(.headline)
                                    .padding(.bottom, 4)
                                Text(event.content)
                                    .font(.system(.caption, design: .monospaced))
                                    .textSelection(.enabled)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                        }
                        .padding()
                        .background(Color(UIColor.secondarySystemBackground))
                        .clipShape(RoundedRectangle(cornerRadius: 10))
                    }
                    // Raw JSON
                    VStack(alignment: .leading, spacing: 8) {
                            HStack {
                                Text("Raw Event JSON")
                                    .font(.headline)
                                Spacer()
                                Button(action: copyRawJSON) {
                                    Label(
                                        copiedToClipboard ? "Copied!" : "Copy",
                                        systemImage: copiedToClipboard ? "checkmark.circle.fill" : "doc.on.doc"
                                    )
                                    .font(.caption)
                                    .foregroundColor(copiedToClipboard ? .green : .accentColor)
                                }
                            }
                            .padding(.bottom, 4)
                            ScrollView(.horizontal) {
                                Text(formattedJSON)
                                    .font(.system(.caption, design: .monospaced))
                                    .textSelection(.enabled)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                            }
                    }
                    .padding()
                    .background(Color(UIColor.secondarySystemBackground))
                    .clipShape(RoundedRectangle(cornerRadius: 10))
                }
                .padding()
            }
            .navigationTitle("Event Details")
            #if os(iOS)
            .navigationBarTitleDisplayMode(.inline)
            #endif
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
        }
    }
    private var formattedJSON: String {
        let eventDict: [String: Any] = [
            "id": event.id,
            "pubkey": event.pubkey,
            "created_at": event.createdAt,
            "kind": event.kind,
            "tags": event.tags,
            "content": event.content,
            "sig": event.sig
        ]
        if let jsonData = try? JSONSerialization.data(withJSONObject: eventDict, options: [.prettyPrinted, .sortedKeys]),
           let jsonString = String(data: jsonData, encoding: .utf8) {
            return jsonString
        }
        return "Failed to format JSON"
    }
    private func copyRawJSON() {
        #if os(iOS)
        UIPasteboard.general.string = formattedJSON
        #else
        NSPasteboard.general.clearContents()
        NSPasteboard.general.setString(formattedJSON, forType: .string)
        #endif
        withAnimation {
            copiedToClipboard = true
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            withAnimation {
                copiedToClipboard = false
            }
        }
    }
}
// MARK: - Date Formatter Extension
extension DateFormatter {
    static let fullDateTimeFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .medium
        return formatter
    }()
}
</file>

<file path="Sources/NutsackiOS/Views/WalletOnboardingView.swift">
import SwiftUI
import NDKSwift
import Combine
struct WalletOnboardingView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(WalletManager.self) private var walletManager
    @EnvironmentObject private var nostrManager: NostrManager
    @Environment(\.colorScheme) private var colorScheme
    enum AuthMode: Identifiable {
        case none
        case create
        case `import`
        var id: String {
            switch self {
            case .none: return "none"
            case .create: return "create"
            case .import: return "import"
            }
        }
    }
    let authMode: AuthMode
    @State private var currentStep: Int
    @State private var logoScale: CGFloat = 0.3
    @State private var logoOpacity: Double = 0
    @State private var logoRotation: Double = -180
    @State private var glowOpacity: Double = 0
    @State private var pulseScale: CGFloat = 1
    @State private var contentOpacity: Double = 0
    @State private var contentOffset: CGFloat = 50
    @State private var electricityOffset: CGFloat = -100
    @State private var titleOpacity: Double = 0
    @State private var titleOffset: CGFloat = 20
    @State private var selectedRelays: Set<String> = []
    @State private var selectedMints: Set<String> = []
    @State private var isSettingUpWallet = false
    @State private var setupError: String?
    @State private var showError = false
    // Mint discovery
    @State private var discoveredMints: [DiscoveredMint] = []
    @State private var mintDiscoveryDataSource: MintDiscoveryDataSource?
    @State private var cancellables = Set<AnyCancellable>()
    // Auth form states
    @State private var displayName = ""
    @State private var nsecInput = ""
    @State private var showPassword = false
    @State private var isProcessing = false
    @State private var showScanner = false
    @State private var authError: String?
    @State private var showAuthError = false
    @State private var loginStatus = ""
    // Avatar states
    @State private var avatarSeed = UUID().uuidString
    @State private var selectedAvatar = ""
    init(authMode: AuthMode = .none) {
        self.authMode = authMode
        // Start at step 0 for import/create, step 1 for none (already authenticated)
        let initialStep = authMode == .none ? 1 : 0
        self._currentStep = State(initialValue: initialStep)
        print("🔍 [WalletOnboarding] Init with authMode: \(authMode)")
        print("🔍 [WalletOnboarding] Setting initial step to: \(initialStep)")
        print("🔍 [WalletOnboarding] Step 0 = REGISTER/LOGIN, Step 1 = SETUP")
    }
    private var currentTitle: String {
        switch currentStep {
        case 0: return authMode == .create ? "REGISTER" : authMode == .import ? "LOGIN" : "AUTHENTICATE"
        case 1: return "SETUP"
        case 2: return "RELAYS"
        case 3: return "MINTS"
        default: return ""
        }
    }
    // Default relay suggestions
    let suggestedRelays = [
        RelayInfo(url: RelayConstants.primal, name: "Primal", description: "Fast and reliable public relay"),
        RelayInfo(url: RelayConstants.damus, name: "Damus", description: "Popular iOS-friendly relay"),
        RelayInfo(url: RelayConstants.nosLol, name: "nos.lol", description: "High-performance relay"),
        RelayInfo(url: RelayConstants.nostrBand, name: "Nostr Band", description: "Analytics and search relay"),
    ]
    // Header view with logo and title
    @ViewBuilder
    private var headerView: some View {
        VStack(spacing: 16) {
            HStack(alignment: .center, spacing: 20) {
                logoSection
                titleSection
                Spacer()
            }
            .padding(.horizontal, 32)
            stepIndicator
                .opacity(contentOpacity)
        }
    }
    // Logo section
    @ViewBuilder
    private var logoSection: some View {
        ZStack {
            // Glow effect
            Circle()
                .fill(
                    RadialGradient(
                        gradient: Gradient(colors: [
                            Color.orange.opacity(0.6),
                            Color.purple.opacity(0.3),
                            Color.clear
                        ]),
                        center: .center,
                        startRadius: 5,
                        endRadius: 40
                    )
                )
                .frame(width: 80, height: 80)
                .blur(radius: 15)
                .scaleEffect(pulseScale)
                .opacity(logoOpacity * 0.7)
            // Logo background
            Circle()
                .fill(
                    LinearGradient(
                        gradient: Gradient(colors: [
                            Color.orange,
                            Color.orange.opacity(0.9),
                            Color(red: 0.8, green: 0.4, blue: 0.1)
                        ]),
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .frame(width: 60, height: 60)
                .shadow(color: Color.orange.opacity(0.5), radius: 10, x: 0, y: 2)
                .scaleEffect(logoScale)
                .opacity(logoOpacity)
                .rotationEffect(.degrees(logoRotation))
            // Nut logo
            NutLogoView(size: 35, color: .white)
                .scaleEffect(logoScale)
                .opacity(logoOpacity)
                .rotationEffect(.degrees(logoRotation))
        }
    }
    // Title section
    @ViewBuilder
    private var titleSection: some View {
        Text(currentTitle)
            .font(.system(size: 40, weight: .black))
            .tracking(2)
            .foregroundStyle(
                LinearGradient(
                    gradient: Gradient(colors: [
                        Color.white,
                        Color.white.opacity(0.9)
                    ]),
                    startPoint: .top,
                    endPoint: .bottom
                )
            )
            .shadow(color: Color.orange.opacity(0.3), radius: 8, x: 0, y: 2)
            .opacity(titleOpacity)
            .offset(x: titleOffset)
            .animation(.spring(response: 0.5, dampingFraction: 0.8), value: currentStep)
    }
    // Step indicator
    @ViewBuilder
    private var stepIndicator: some View {
        HStack(spacing: 12) {
            ForEach(0..<4) { step in
                Capsule()
                    .fill(currentStep >= step ? Color.orange : Color.white.opacity(0.2))
                    .frame(width: currentStep == step ? 32 : 16, height: 4)
                    .animation(.easeInOut(duration: 0.3), value: currentStep)
            }
        }
    }
    // Content view
    @ViewBuilder
    private var contentView: some View {
        VStack {
            switch currentStep {
            case 0:
                authStepContent
            case 1:
                WelcomeStepView()
                    .transition(.asymmetric(
                        insertion: .move(edge: .trailing).combined(with: .opacity),
                        removal: .move(edge: .leading).combined(with: .opacity)
                    ))
            case 2:
                RelaySelectionView(
                    selectedRelays: $selectedRelays,
                    suggestedRelays: suggestedRelays
                )
                .transition(.asymmetric(
                    insertion: .move(edge: .trailing).combined(with: .opacity),
                    removal: .move(edge: .leading).combined(with: .opacity)
                ))
            case 3:
                MintSelectionView(
                    selectedMints: $selectedMints,
                    discoveredMints: discoveredMints
                )
                .transition(.asymmetric(
                    insertion: .move(edge: .trailing).combined(with: .opacity),
                    removal: .move(edge: .leading).combined(with: .opacity)
                ))
            default:
                EmptyView()
            }
        }
    }
    // Auth step content
    @ViewBuilder
    private var authStepContent: some View {
        if authMode == .create {
            createAccountForm
                .transition(.asymmetric(
                    insertion: .move(edge: .trailing).combined(with: .opacity),
                    removal: .move(edge: .leading).combined(with: .opacity)
                ))
        } else if authMode == .import {
            importAccountForm
                .transition(.asymmetric(
                    insertion: .move(edge: .trailing).combined(with: .opacity),
                    removal: .move(edge: .leading).combined(with: .opacity)
                ))
        } else {
            EmptyView()
        }
    }
    // Background gradient view
    @ViewBuilder
    private var backgroundGradient: some View {
        LinearGradient(
            gradient: Gradient(colors: [
                Color(red: 0.05, green: 0.02, blue: 0.08),
                Color(red: 0.02, green: 0.01, blue: 0.03),
                Color.black
            ]),
            startPoint: .topLeading,
            endPoint: .bottomTrailing
        )
        .ignoresSafeArea()
    }
    // Action buttons view
    @ViewBuilder
    private var actionButtonsView: some View {
        VStack(spacing: 16) {
            if currentStep == 0 {
                // Auth form buttons - handled within forms
                EmptyView()
            } else if currentStep == 1 {
                // Continue button
                Button(action: {
                    withAnimation(.spring(response: 0.5, dampingFraction: 0.8)) {
                        currentStep = 2
                    }
                }) {
                    HStack {
                        Text("Continue")
                            .font(.system(size: 18, weight: .semibold))
                        Image(systemName: "arrow.right")
                            .font(.system(size: 16, weight: .semibold))
                    }
                    .frame(maxWidth: .infinity)
                    .frame(height: 56)
                    .background(
                        LinearGradient(
                            gradient: Gradient(colors: [
                                Color.orange,
                                Color(red: 0.9, green: 0.5, blue: 0.1)
                            ]),
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .foregroundColor(.white)
                    .clipShape(RoundedRectangle(cornerRadius: 16))
                    .shadow(color: Color.orange.opacity(0.3), radius: 10, x: 0, y: 4)
                }
                // Logout button
                Button(action: {
                    Task {
                        await nostrManager.logout()
                    }
                    dismiss()
                }) {
                    Text("Logout")
                        .font(.system(size: 16, weight: .medium))
                        .foregroundColor(Color.white.opacity(0.6))
                }
            } else if currentStep == 2 {
                // Next button for relay selection with back arrow
                HStack(spacing: 12) {
                    Button(action: {
                        withAnimation(.spring(response: 0.5, dampingFraction: 0.8)) {
                            currentStep = 1
                        }
                    }) {
                        Image(systemName: "arrow.left")
                            .font(.system(size: 18, weight: .semibold))
                            .foregroundColor(.white)
                            .frame(width: 56, height: 56)
                            .background(Color.white.opacity(0.1))
                            .clipShape(RoundedRectangle(cornerRadius: 16))
                            .overlay(
                                RoundedRectangle(cornerRadius: 16)
                                    .stroke(Color.white.opacity(0.2), lineWidth: 1)
                            )
                    }
                    Button(action: {
                        withAnimation(.spring(response: 0.5, dampingFraction: 0.8)) {
                            currentStep = 3
                        }
                    }) {
                        HStack {
                            Text("Next: Select Mints")
                                .font(.system(size: 18, weight: .semibold))
                            Image(systemName: "arrow.right")
                                .font(.system(size: 16, weight: .semibold))
                        }
                        .frame(maxWidth: .infinity)
                        .frame(height: 56)
                        .background(
                            LinearGradient(
                                gradient: Gradient(colors: [
                                    selectedRelays.isEmpty ? Color.gray : Color.orange,
                                    selectedRelays.isEmpty ? Color.gray.opacity(0.8) : Color(red: 0.9, green: 0.5, blue: 0.1)
                                ]),
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .foregroundColor(.white)
                        .clipShape(RoundedRectangle(cornerRadius: 16))
                        .shadow(color: selectedRelays.isEmpty ? Color.clear : Color.orange.opacity(0.3), radius: 10, x: 0, y: 4)
                    }
                    .disabled(selectedRelays.isEmpty)
                }
            } else if currentStep == 3 {
                // Setup wallet button with back arrow
                HStack(spacing: 12) {
                    Button(action: {
                        withAnimation(.spring(response: 0.5, dampingFraction: 0.8)) {
                            currentStep = 2
                        }
                    }) {
                        Image(systemName: "arrow.left")
                            .font(.system(size: 18, weight: .semibold))
                            .foregroundColor(.white)
                            .frame(width: 56, height: 56)
                            .background(Color.white.opacity(0.1))
                            .clipShape(RoundedRectangle(cornerRadius: 16))
                            .overlay(
                                RoundedRectangle(cornerRadius: 16)
                                    .stroke(Color.white.opacity(0.2), lineWidth: 1)
                            )
                    }
                    Button(action: setupWallet) {
                        if isSettingUpWallet {
                            ProgressView()
                                .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                .frame(maxWidth: .infinity)
                                .frame(height: 56)
                                .background(
                                    LinearGradient(
                                        gradient: Gradient(colors: [
                                            Color.orange,
                                            Color(red: 0.9, green: 0.5, blue: 0.1)
                                        ]),
                                        startPoint: .leading,
                                        endPoint: .trailing
                                    )
                                )
                                .clipShape(RoundedRectangle(cornerRadius: 16))
                        } else {
                            HStack {
                                Image(systemName: "checkmark.circle.fill")
                                    .font(.system(size: 20))
                                Text("Complete Setup")
                                    .font(.system(size: 18, weight: .semibold))
                            }
                            .frame(maxWidth: .infinity)
                            .frame(height: 56)
                            .background(
                                LinearGradient(
                                    gradient: Gradient(colors: [
                                        Color.orange,
                                        Color(red: 0.9, green: 0.5, blue: 0.1)
                                    ]),
                                    startPoint: .leading,
                                    endPoint: .trailing
                                )
                            )
                            .foregroundColor(.white)
                            .clipShape(RoundedRectangle(cornerRadius: 16))
                            .shadow(color: Color.orange.opacity(0.3), radius: 10, x: 0, y: 4)
                        }
                    }
                    .disabled(selectedRelays.isEmpty || isSettingUpWallet)
                }
            }
        }
        .padding(.horizontal, 24)
        .padding(.bottom, 40)
        .offset(y: contentOffset)
        .opacity(contentOpacity)
    }
    // Electric field effects
    @ViewBuilder
    private var electricFieldEffects: some View {
        ForEach(0..<3) { index in
            ElectricArc(
                startPoint: CGPoint(x: 0.5, y: 0.5),
                endPoint: CGPoint(
                    x: 0.5 + cos(Double(index) * .pi / 1.5) * 0.3,
                    y: 0.5 + sin(Double(index) * .pi / 1.5) * 0.3
                )
            )
            .stroke(
                LinearGradient(
                    gradient: Gradient(colors: [
                        Color.orange.opacity(0.4),
                        Color.purple.opacity(0.2),
                        Color.clear
                    ]),
                    startPoint: .center,
                    endPoint: .bottom
                ),
                lineWidth: 1.5
            )
            .blur(radius: 2)
            .opacity(glowOpacity * 0.5)
            .offset(y: electricityOffset)
            .animation(
                .easeInOut(duration: 3)
                .delay(Double(index) * 0.2)
                .repeatForever(autoreverses: true),
                value: electricityOffset
            )
        }
    }
    var body: some View {
        ZStack {
            backgroundGradient
            electricFieldEffects
            VStack(spacing: 0) {
                headerView
                    .padding(.top, 30)
                contentView
                    .padding(.horizontal, 24)
                    .padding(.top, 20)
                    .offset(y: contentOffset)
                    .opacity(contentOpacity)
                Spacer()
                actionButtonsView
            }
        }
        .onAppear {
            print("\n=== 🎯 [WalletOnboarding] SETUP WIZARD START ===")
            print("🔍 [WalletOnboarding] onAppear - authMode: \(authMode), currentStep: \(currentStep)")
            print("🔍 [WalletOnboarding] NostrManager has signer: \(nostrManager.ndk.signer != nil)")
            print("🔍 [WalletOnboarding] NostrManager.isAuthenticated: \(nostrManager.isAuthenticated)")
            Task {
                let wallet = walletManager.wallet
                let mintUrls = await wallet?.mints.getMintURLs() ?? []
                print("🔍 [WalletOnboarding] Current wallet state:")
                print("  - wallet exists: \(wallet != nil)")
                print("  - mint count: \(mintUrls.count)")
                print("  - mints: \(mintUrls)")
                if authMode == .none && currentStep == 1 {
                    print("🚨 [WalletOnboarding] WARNING: User already authenticated but being shown setup wizard!")
                    print("🚨 [WalletOnboarding] This indicates wallet exists but has no mints configured")
                }
            }
            animateOnboarding()
            // Start mint discovery immediately when view appears
            startMintDiscovery()
            print("=== [WalletOnboarding] END SETUP WIZARD START ===\n")
        }
        .onDisappear {
            // Clean up subscriptions when view disappears
            cancellables.removeAll()
        }
        .alert("Setup Error", isPresented: $showError) {
            Button("OK") { }
        } message: {
            Text(setupError ?? "Failed to setup wallet")
        }
        .alert("Error", isPresented: $showAuthError) {
            Button("OK") { }
        } message: {
            Text(authError ?? "An error occurred")
        }
        .sheet(isPresented: $showScanner) {
            QRScannerView(
                onScan: { scannedValue in
                    nsecInput = scannedValue
                    showScanner = false
                },
                onDismiss: {
                    showScanner = false
                }
            )
        }
    }
    private func animateOnboarding() {
        // Logo animation
        withAnimation(.spring(response: 1.0, dampingFraction: 0.7)) {
            logoScale = 1
            logoOpacity = 1
            logoRotation = 0
        }
        // Title animation
        withAnimation(.spring(response: 0.8, dampingFraction: 0.8).delay(0.5)) {
            titleOpacity = 1
            titleOffset = 0
        }
        // Glow effects
        withAnimation(.easeInOut(duration: 1.2).delay(0.3)) {
            glowOpacity = 1
        }
        // Electricity animation
        withAnimation(.easeInOut(duration: 2).delay(0.5).repeatForever(autoreverses: true)) {
            electricityOffset = 100
        }
        // Pulse animation
        withAnimation(.easeInOut(duration: 1.5).delay(0.8).repeatForever(autoreverses: true)) {
            pulseScale = 1.15
        }
        // Content animation
        withAnimation(.easeOut(duration: 0.8).delay(0.8)) {
            contentOffset = 0
            contentOpacity = 1
        }
    }
    private func startMintDiscovery() {
        // Start mint discovery immediately, even before authentication
        Task {
            // Wait for NDK to be available (should be almost immediate)
            while nostrManager.ndk == nil {
                try? await Task.sleep(nanoseconds: 100_000_000) // 100ms
            }
            let ndk = nostrManager.ndk
            // Use the existing working MintDiscoveryDataSource
            let dataSource = MintDiscoveryDataSource(ndk: ndk)
            await MainActor.run {
                self.mintDiscoveryDataSource = dataSource
            }
            // Start streaming mint discovery
            dataSource.startStreaming()
            // Observe changes from the data source
            await MainActor.run {
                dataSource.$discoveredMints
                    .sink { mints in
                        self.discoveredMints = mints
                    }
                    .store(in: &cancellables)
            }
        }
    }
    private func setupWallet() {
        guard !selectedRelays.isEmpty && !selectedMints.isEmpty else { return }
        isSettingUpWallet = true
        setupError = nil
        Task {
            do {
                // First ensure the wallet exists (this creates the NIP60Wallet instance)
                try await walletManager.loadWalletForCurrentUser()
                guard let wallet = walletManager.wallet else {
                    throw NSError(domain: "WalletOnboarding", code: 0, userInfo: [NSLocalizedDescriptionKey: "Failed to create wallet"])
                }
                // Setup wallet with selected relays and mints
                try await wallet.setup(
                    mints: Array(selectedMints),
                    relays: Array(selectedRelays),
                    publishMintList: true
                )
                await MainActor.run {
                    dismiss()
                }
            } catch {
                await MainActor.run {
                    setupError = error.localizedDescription
                    showError = true
                    isSettingUpWallet = false
                }
            }
        }
    }
    // MARK: - Auth Forms
    @ViewBuilder
    private var createAccountForm: some View {
        VStack(spacing: 20) {
            // Avatar selection
            VStack(spacing: 12) {
                Text("Choose Your Avatar")
                    .font(.system(size: 14, weight: .medium))
                    .foregroundColor(Color.white.opacity(0.8))
                Button(action: randomizeAvatar) {
                    ZStack {
                        Circle()
                            .fill(Color.white.opacity(0.1))
                            .frame(width: 120, height: 120)
                            .overlay(
                                Circle()
                                    .stroke(Color.orange.opacity(0.5), lineWidth: 2)
                            )
                        if !selectedAvatar.isEmpty {
                            AsyncImage(url: URL(string: selectedAvatar)) { image in
                                image
                                    .resizable()
                                    .aspectRatio(contentMode: .fit)
                                    .clipShape(Circle())
                            } placeholder: {
                                ProgressView()
                                    .progressViewStyle(CircularProgressViewStyle(tint: .orange))
                            }
                            .frame(width: 110, height: 110)
                        } else {
                            Image(systemName: "person.crop.circle.fill")
                                .font(.system(size: 60))
                                .foregroundColor(Color.white.opacity(0.3))
                        }
                        // Refresh icon overlay
                        Image(systemName: "arrow.triangle.2.circlepath")
                            .font(.system(size: 20, weight: .semibold))
                            .foregroundColor(.white)
                            .padding(8)
                            .background(Circle().fill(Color.orange))
                            .offset(x: 40, y: 40)
                    }
                }
                .buttonStyle(PlainButtonStyle())
                Text("Tap to generate a new avatar")
                    .font(.system(size: 12))
                    .foregroundColor(Color.white.opacity(0.4))
            }
            // Form fields
            VStack(spacing: 20) {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Display Name")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundColor(Color.white.opacity(0.8))
                    TextField("", text: $displayName)
                        .textFieldStyle(DarkTextFieldStyle())
                        .textContentType(.name)
                }
                Text("This information will be public on Nostr")
                    .font(.system(size: 12))
                    .foregroundColor(Color.white.opacity(0.4))
                    .frame(maxWidth: .infinity, alignment: .leading)
            }
            Spacer()
            // Create button
            Button(action: createAccount) {
                if isProcessing {
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
                } else {
                    HStack {
                        Image(systemName: "bolt.fill")
                        Text("Create Account")
                            .fontWeight(.semibold)
                    }
                }
            }
            .frame(maxWidth: .infinity)
            .frame(height: 56)
            .background(
                LinearGradient(
                    gradient: Gradient(colors: [
                        displayName.isEmpty ? Color.gray : Color.orange,
                        displayName.isEmpty ? Color.gray.opacity(0.8) : Color(red: 0.9, green: 0.5, blue: 0.1)
                    ]),
                    startPoint: .leading,
                    endPoint: .trailing
                )
            )
            .foregroundColor(.white)
            .clipShape(RoundedRectangle(cornerRadius: 16))
            .shadow(color: displayName.isEmpty ? Color.clear : Color.orange.opacity(0.3), radius: 10, x: 0, y: 4)
            .disabled(displayName.isEmpty || isProcessing)
            // Cancel button
            Button(action: { dismiss() }) {
                Text("Cancel")
                    .font(.system(size: 16, weight: .medium))
                    .foregroundColor(Color.white.opacity(0.6))
            }
            .padding(.top, 8)
        }
        .onAppear {
            generateInitialAvatar()
        }
    }
    @ViewBuilder
    private var importAccountForm: some View {
        VStack(spacing: 20) {
            // Form fields
            VStack(spacing: 20) {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Private Key")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundColor(Color.white.opacity(0.8))
                    HStack(spacing: 12) {
                        HStack {
                            if showPassword {
                                TextField("nsec1...", text: $nsecInput)
                                    .textContentType(.password)
                                    #if os(iOS)
                                    .textInputAutocapitalization(.never)
                                    #endif
                                    .font(.system(.body, design: .monospaced))
                            } else {
                                SecureField("nsec1...", text: $nsecInput)
                                    .textContentType(.password)
                                    #if os(iOS)
                                    .textInputAutocapitalization(.never)
                                    #endif
                                    .font(.system(.body, design: .monospaced))
                            }
                            Button(action: { showPassword.toggle() }) {
                                Image(systemName: showPassword ? "eye.slash.fill" : "eye.fill")
                                    .font(.callout)
                                    .foregroundColor(Color.white.opacity(0.6))
                            }
                        }
                        .padding(16)
                        .background(Color.white.opacity(0.08))
                        .foregroundColor(.white)
                        .accentColor(.orange)
                        .overlay(
                            RoundedRectangle(cornerRadius: 12)
                                .stroke(Color.white.opacity(0.2), lineWidth: 1)
                        )
                        .clipShape(RoundedRectangle(cornerRadius: 12))
                        Button(action: { showScanner = true }) {
                            ZStack {
                                RoundedRectangle(cornerRadius: 12)
                                    .fill(Color.white.opacity(0.08))
                                    .frame(width: 50, height: 50)
                                    .overlay(
                                        RoundedRectangle(cornerRadius: 12)
                                            .stroke(Color.white.opacity(0.2), lineWidth: 1)
                                    )
                                Image(systemName: "qrcode.viewfinder")
                                    .font(.title2)
                                    .foregroundColor(.orange)
                            }
                        }
                    }
                    HStack {
                        Image(systemName: "lock.shield.fill")
                            .font(.caption)
                            .foregroundColor(Color.white.opacity(0.4))
                        Text("Your key is stored securely on this device")
                            .font(.caption)
                            .foregroundColor(Color.white.opacity(0.4))
                    }
                    .padding(.top, 4)
                }
            }
            Spacer()
            // Login button
            Button(action: importAccount) {
                if isProcessing {
                    HStack(spacing: 12) {
                        ProgressView()
                            .progressViewStyle(CircularProgressViewStyle(tint: .white))
                            .scaleEffect(0.9)
                        Text(loginStatus.isEmpty ? "Logging in..." : loginStatus)
                            .fontWeight(.semibold)
                    }
                } else {
                    HStack {
                        Image(systemName: "arrow.right.circle.fill")
                        Text("Log In")
                            .fontWeight(.semibold)
                    }
                }
            }
            .foregroundColor(.white)
            .frame(maxWidth: .infinity)
            .frame(height: 56)
            .background(
                LinearGradient(
                    gradient: Gradient(colors: [
                        nsecInput.isEmpty ? Color.gray : Color.orange,
                        nsecInput.isEmpty ? Color.gray.opacity(0.8) : Color(red: 0.9, green: 0.5, blue: 0.1)
                    ]),
                    startPoint: .leading,
                    endPoint: .trailing
                )
            )
            .clipShape(RoundedRectangle(cornerRadius: 16))
            .shadow(color: nsecInput.isEmpty ? Color.clear : Color.orange.opacity(0.3), radius: 10, x: 0, y: 4)
            .disabled(nsecInput.isEmpty || isProcessing)
            // Cancel button
            Button(action: { dismiss() }) {
                Text("Cancel")
                    .font(.system(size: 16, weight: .medium))
                    .foregroundColor(Color.white.opacity(0.6))
            }
            .padding(.top, 8)
        }
    }
    // MARK: - Auth Actions
    private func createAccount() {
        guard !displayName.isEmpty else { return }
        isProcessing = true
        Task {
            do {
                _ = try await nostrManager.createNutsackAccount(
                    displayName: displayName,
                    about: nil,
                    picture: selectedAvatar.isEmpty ? nil : selectedAvatar
                )
                await MainActor.run {
                    isProcessing = false
                    // Transition to welcome step
                    withAnimation(.spring(response: 0.8, dampingFraction: 0.8)) {
                        currentStep = 1
                    }
                    // Mint discovery is already running, no need to start it again
                }
            } catch {
                await MainActor.run {
                    authError = error.localizedDescription
                    showAuthError = true
                    isProcessing = false
                }
            }
        }
    }
    // MARK: - Avatar Methods
    private func generateInitialAvatar() {
        avatarSeed = UUID().uuidString
        selectedAvatar = generateDicebearURL(seed: avatarSeed)
    }
    private func randomizeAvatar() {
        withAnimation(.easeInOut(duration: 0.2)) {
            avatarSeed = UUID().uuidString
            selectedAvatar = generateDicebearURL(seed: avatarSeed)
        }
    }
    private func generateDicebearURL(seed: String) -> String {
        // Using bottts style for a fun robot-like avatar
        // You can change the style to: adventurer, avataaars, big-ears, big-smile, bottts, croodles, fun-emoji, lorelei, micah, miniavs, open-peeps, personas, pixel-art
        let style = "bottts"
        let size = 200
        return "https://api.dicebear.com/7.x/\(style)/png?seed=\(seed)&size=\(size)"
    }
    private func importAccount() {
        isProcessing = true
        loginStatus = "Authenticating..."
        Task {
            do {
                // Step 1: Create signer and authenticate
                let signer = try NDKPrivateKeySigner(nsec: nsecInput)
                let pubkey = try await signer.pubkey
                await MainActor.run {
                    loginStatus = "Finding your relays..."
                }
                // Step 2: Get user's relay list BEFORE starting session
                let ndk = nostrManager.ndk
                NDKLogger.configure(
                    logLevel: .debug,
                    enabledCategories: [
                        .general,
                        .subscription,
                        .cache
                    ],
                    logNetworkTraffic: true
                )
                // Create user object with NDK reference and fetch their relay list
                let user = NDKUser(pubkey: pubkey)
                user.ndk = ndk
                print("Starting fetch")
                let relayInfoList: [NDKRelayInfo] = try await user.fetchRelayList()
                print("Back from fetch")
                var userRelays: [String] = []
                // Extract write relays from the relay list
                let writeRelays = relayInfoList.filter { $0.write }.map { $0.url }
                let readRelays = relayInfoList.filter { $0.read }.map { $0.url }
                if !writeRelays.isEmpty {
                    userRelays = writeRelays
                    print("Found \(writeRelays.count) write relays from user's relay list")
                } else if !readRelays.isEmpty {
                    // Fall back to read relays if no write relays
                    userRelays = readRelays
                    print("Found \(readRelays.count) read relays from user's relay list")
                }
                // Add user's relays to NDK before starting session
                if !userRelays.isEmpty {
                    await MainActor.run {
                        loginStatus = "Connecting to your relays..."
                    }
                    for relay in userRelays {
                        await ndk.addRelay(relay)
                    }
                    // Wait for relays to connect
                    try await Task.sleep(nanoseconds: 500_000_000) // 500ms to allow connections
                } else {
                    await MainActor.run {
                        loginStatus = "No relays found..."
                    }
                }
                // Step 3: Import account with session persistence
                try await nostrManager.importAccount(signer: signer)
                await MainActor.run {
                    loginStatus = "Importing wallet..."
                }
                // Step 4: Check for existing wallet (kind 17375) using collect
                let walletFilter = NDKFilter(
                    authors: [pubkey],
                    kinds: [EventKind.cashuWalletConfig], // NIP-60 wallet configuration
                    limit: 1
                )
                let walletDataSource = ndk.subscribe(
                    filter: walletFilter,
                    maxAge: 0,  // Force network fetch
                    cachePolicy: .networkOnly
                )
                let walletEvents = await walletDataSource.collect(timeout: 5.0) // 5 second timeout
                let walletFound = !walletEvents.isEmpty
                if walletFound {
                    print("Found existing wallet configuration")
                }
                await MainActor.run {
                    isProcessing = false
                    loginStatus = ""
                    if walletFound {
                        // Step 5: Go directly to main screen if wallet exists
                        // Load the wallet before dismissing
                        Task {
                            do {
                                try await walletManager.loadWalletForCurrentUser()
                                await MainActor.run {
                                    dismiss()
                                }
                            } catch {
                                print("Failed to load wallet: \(error)")
                                // Still dismiss but wallet loading failed
                                await MainActor.run {
                                    dismiss()
                                }
                            }
                        }
                    } else {
                        // Go to wallet setup if no wallet found
                        withAnimation(.spring(response: 0.8, dampingFraction: 0.8)) {
                            currentStep = 1
                        }
                        // Mint discovery is already running, no need to start it again
                    }
                }
            } catch {
                await MainActor.run {
                    authError = error.localizedDescription
                    showAuthError = true
                    isProcessing = false
                    loginStatus = ""
                }
            }
        }
    }
}
// MARK: - Welcome Step View
struct WelcomeStepView: View {
    var body: some View {
        VStack(spacing: 20) {
            Text("Let's set up your Cashu wallet to enable instant, private payments")
                .font(.system(size: 16, weight: .medium))
                .foregroundColor(Color.white.opacity(0.7))
                .multilineTextAlignment(.center)
                .padding(.horizontal)
            // Feature highlights
            VStack(spacing: 20) {
                FeatureRow(
                    icon: "bolt.fill",
                    title: "Lightning Fast",
                    description: "Instant payments with minimal fees"
                )
                FeatureRow(
                    icon: "lock.shield.fill",
                    title: "Private & Secure",
                    description: "Your transactions stay private"
                )
                FeatureRow(
                    icon: "arrow.triangle.2.circlepath",
                    title: "Decentralized",
                    description: "No single point of failure"
                )
            }
            .padding(.top, 20)
        }
    }
}
// MARK: - Feature Row
struct FeatureRow: View {
    let icon: String
    let title: String
    let description: String
    var body: some View {
        HStack(spacing: 16) {
            ZStack {
                Circle()
                    .fill(Color.orange.opacity(0.2))
                    .frame(width: 48, height: 48)
                Image(systemName: icon)
                    .font(.system(size: 22))
                    .foregroundColor(.orange)
            }
            VStack(alignment: .leading, spacing: 4) {
                Text(title)
                    .font(.system(size: 16, weight: .semibold))
                    .foregroundColor(.white)
                Text(description)
                    .font(.system(size: 14))
                    .foregroundColor(Color.white.opacity(0.6))
            }
            Spacer()
        }
    }
}
// MARK: - Relay Selection View
struct RelaySelectionView: View {
    @Binding var selectedRelays: Set<String>
    let suggestedRelays: [RelayInfo]
    var body: some View {
        VStack(spacing: 20) {
            Text("Select relays to sync your wallet data")
                .font(.system(size: 16, weight: .medium))
                .foregroundColor(Color.white.opacity(0.7))
                .multilineTextAlignment(.center)
            // Relay list
            ScrollView {
                VStack(spacing: 12) {
                    ForEach(suggestedRelays, id: \.url) { relay in
                        OnboardingRelayRowView(
                            relay: relay,
                            isSelected: selectedRelays.contains(relay.url),
                            onTap: {
                                withAnimation(.easeInOut(duration: 0.2)) {
                                    if selectedRelays.contains(relay.url) {
                                        selectedRelays.remove(relay.url)
                                    } else {
                                        selectedRelays.insert(relay.url)
                                    }
                                }
                            }
                        )
                    }
                }
            }
            .frame(maxHeight: 400)
            // Selection hint
            Text("\(selectedRelays.count) relay\(selectedRelays.count == 1 ? "" : "s") selected")
                .font(.system(size: 14, weight: .medium))
                .foregroundColor(Color.white.opacity(0.5))
        }
    }
}
// MARK: - Relay Row View
struct OnboardingRelayRowView: View {
    let relay: RelayInfo
    let isSelected: Bool
    let onTap: () -> Void
    var body: some View {
        Button(action: onTap) {
            HStack(spacing: 16) {
                // Relay icon
                ZStack {
                    Circle()
                        .fill(
                            LinearGradient(
                                gradient: Gradient(colors: [
                                    Color.orange.opacity(0.2),
                                    Color.orange.opacity(0.1)
                                ]),
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(width: 48, height: 48)
                    Image(systemName: "antenna.radiowaves.left.and.right")
                        .font(.system(size: 22))
                        .foregroundColor(.orange)
                }
                // Relay info
                VStack(alignment: .leading, spacing: 4) {
                    Text(relay.name)
                        .font(.system(size: 16, weight: .semibold))
                        .foregroundColor(.white)
                    Text(relay.description)
                        .font(.system(size: 14))
                        .foregroundColor(Color.white.opacity(0.6))
                }
                Spacer()
            }
            .padding(16)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(isSelected ? Color.orange.opacity(0.15) : Color.white.opacity(0.05))
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                            .stroke(isSelected ? Color.orange.opacity(0.5) : Color.white.opacity(0.1), lineWidth: 1)
                    )
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
}
// MARK: - Relay Info
struct RelayInfo {
    let url: String
    let name: String
    let description: String
}
// MARK: - Mint Selection View
struct MintSelectionView: View {
    @Binding var selectedMints: Set<String>
    let discoveredMints: [DiscoveredMint]
    @State private var manualMintURL = ""
    @State private var showManualInput = false
    @State private var isAddingMint = false
    @State private var addMintError: String?
    @Environment(WalletManager.self) private var walletManager
    var sortedMints: [DiscoveredMint] {
        discoveredMints.sorted { first, second in
            // Sort by presence of icon first (mints with icons come first)
            let firstHasIcon = (first.metadata?.iconURL != nil || first.mintInfo?.iconURL != nil)
            let secondHasIcon = (second.metadata?.iconURL != nil || second.mintInfo?.iconURL != nil)
            if firstHasIcon != secondHasIcon {
                return firstHasIcon
            }
            // Then by recommendation count
            if first.recommendedBy.count != second.recommendedBy.count {
                return first.recommendedBy.count > second.recommendedBy.count
            }
            // Then by announcement date
            let firstDate = first.announcementCreatedAt ?? 0
            let secondDate = second.announcementCreatedAt ?? 0
            return firstDate > secondDate
        }
    }
    var body: some View {
        VStack(spacing: 20) {
            infoCard
            mintListContent
            selectedCountView
        }
    }
    @ViewBuilder
    private var infoCard: some View {
        HStack(spacing: 12) {
            Image(systemName: "info.circle.fill")
                .font(.system(size: 20))
                .foregroundColor(.green.opacity(0.8))
            Text("Mints are custodial services that issue ecash tokens. Select multiple mints to spread risk.")
                .font(.system(size: 12))
                .foregroundColor(Color.white.opacity(0.7))
                .fixedSize(horizontal: false, vertical: true)
            Spacer()
        }
        .padding(16)
        .background(infoCardBackground)
    }
    @ViewBuilder
    private var infoCardBackground: some View {
        RoundedRectangle(cornerRadius: 12)
            .fill(Color.green.opacity(0.1))
            .overlay(
                RoundedRectangle(cornerRadius: 12)
                    .stroke(Color.green.opacity(0.2), lineWidth: 1)
            )
    }
    @ViewBuilder
    private var mintListContent: some View {
        // Always show the scroll view, even if empty
        // This follows the "never wait, always stream" philosophy
        mintScrollView
    }
    @ViewBuilder
    private var emptyStateView: some View {
        VStack(spacing: 16) {
            Image(systemName: "exclamationmark.triangle")
                .font(.system(size: 40))
                .foregroundColor(.yellow)
            Text("No mints discovered")
                .font(.system(size: 16, weight: .medium))
                .foregroundColor(Color.white.opacity(0.7))
            Text("Check your internet connection and try again")
                .font(.system(size: 14))
                .foregroundColor(Color.white.opacity(0.5))
                .multilineTextAlignment(.center)
        }
        .frame(maxHeight: 300)
        .frame(maxWidth: .infinity)
    }
    @ViewBuilder
    private var mintScrollView: some View {
        ScrollView {
            VStack(spacing: 12) {
                customMintSection
                discoveredMintsSection
                manuallyAddedMintsSection
                // Show a hint if no mints discovered yet
                if discoveredMints.isEmpty {
                    VStack(spacing: 12) {
                        Text("No recommended mints found")
                            .font(.system(size: 14, weight: .medium))
                            .foregroundColor(Color.white.opacity(0.5))
                        Text("Add custom mints above")
                            .font(.system(size: 12))
                            .foregroundColor(Color.white.opacity(0.4))
                            .multilineTextAlignment(.center)
                    }
                    .padding(20)
                    .frame(maxWidth: .infinity)
                }
            }
        }
        .scrollIndicators(.hidden)
    }
    @ViewBuilder
    private var customMintSection: some View {
        VStack(spacing: 12) {
            customMintHeader
            if showManualInput {
                customMintInputSection
                    .transition(.opacity.combined(with: .move(edge: .top)))
            }
        }
        .padding(12)
        .background(sectionBackground)
    }
    @ViewBuilder
    private var customMintHeader: some View {
        HStack {
            Text("Add Custom Mint")
                .font(.system(size: 14, weight: .semibold))
                .foregroundColor(Color.white.opacity(0.9))
            Spacer()
            Button(action: toggleManualInput) {
                Image(systemName: showManualInput ? "minus.circle.fill" : "plus.circle.fill")
                    .font(.system(size: 20))
                    .foregroundColor(.green)
            }
        }
        .padding(.horizontal, 4)
    }
    @ViewBuilder
    private var customMintInputSection: some View {
        VStack(spacing: 8) {
            HStack(spacing: 8) {
                mintURLTextField
                addMintButton
            }
            if let error = addMintError {
                Text(error)
                    .font(.system(size: 12))
                    .foregroundColor(.red)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .padding(.horizontal, 4)
            }
        }
    }
    @ViewBuilder
    private var mintURLTextField: some View {
        TextField("https://mint.example.com", text: $manualMintURL)
            .textFieldStyle(PlainTextFieldStyle())
            .font(.system(size: 14, design: .monospaced))
            .foregroundColor(.white)
            .padding(12)
            .background(textFieldBackground)
            .autocapitalization(.none)
            .disableAutocorrection(true)
    }
    @ViewBuilder
    private var textFieldBackground: some View {
        RoundedRectangle(cornerRadius: 10)
            .fill(Color.white.opacity(0.1))
            .overlay(
                RoundedRectangle(cornerRadius: 10)
                    .stroke(Color.white.opacity(0.2), lineWidth: 1)
            )
    }
    @ViewBuilder
    private var addMintButton: some View {
        Button(action: addManualMint) {
            if isAddingMint {
                ProgressView()
                    .scaleEffect(0.8)
                    .frame(width: 44, height: 44)
                    .background(Color.green)
                    .clipShape(RoundedRectangle(cornerRadius: 10))
            } else {
                Image(systemName: "plus")
                    .font(.system(size: 18, weight: .semibold))
                    .foregroundColor(.white)
                    .frame(width: 44, height: 44)
                    .background(manualMintURL.isEmpty ? Color.gray : Color.green)
                    .clipShape(RoundedRectangle(cornerRadius: 10))
            }
        }
        .disabled(manualMintURL.isEmpty || isAddingMint)
    }
    @ViewBuilder
    private var sectionBackground: some View {
        RoundedRectangle(cornerRadius: 12)
            .fill(Color.white.opacity(0.05))
            .overlay(
                RoundedRectangle(cornerRadius: 12)
                    .stroke(Color.white.opacity(0.1), lineWidth: 1)
            )
    }
    @ViewBuilder
    private var discoveredMintsSection: some View {
        ForEach(sortedMints, id: \.url) { mint in
            MintRowView(
                mint: mint,
                isSelected: selectedMints.contains(mint.url),
                onTap: { toggleMintSelection(mint.url) }
            )
        }
    }
    @ViewBuilder
    private var manuallyAddedMintsSection: some View {
        let customMints = selectedMints.subtracting(Set(discoveredMints.map { $0.url }))
        ForEach(Array(customMints), id: \.self) { mintURL in
            CustomMintRowView(
                mintURL: mintURL,
                isSelected: true,
                onTap: { removeMint(mintURL) }
            )
        }
    }
    @ViewBuilder
    private var selectedCountView: some View {
        if !selectedMints.isEmpty {
            HStack {
                Image(systemName: "checkmark.circle.fill")
                    .font(.system(size: 16))
                    .foregroundColor(.green)
                Text("\(selectedMints.count) mint\(selectedMints.count == 1 ? "" : "s") selected")
                    .font(.system(size: 14, weight: .medium))
                    .foregroundColor(Color.white.opacity(0.7))
                Spacer()
            }
        }
    }
    private func toggleManualInput() {
        withAnimation(.easeInOut(duration: 0.3)) {
            showManualInput.toggle()
            manualMintURL = ""
            addMintError = nil
        }
    }
    private func toggleMintSelection(_ url: String) {
        withAnimation(.easeInOut(duration: 0.2)) {
            if selectedMints.contains(url) {
                selectedMints.remove(url)
            } else {
                selectedMints.insert(url)
            }
        }
    }
    private func removeMint(_ url: String) {
        _ = withAnimation(.easeInOut(duration: 0.2)) {
            selectedMints.remove(url)
        }
    }
    private func addManualMint() {
        let trimmedURL = manualMintURL.trimmingCharacters(in: .whitespacesAndNewlines)
        // Validate URL
        guard !trimmedURL.isEmpty,
              let url = URL(string: trimmedURL),
              url.scheme == "https" || url.scheme == "http" else {
            addMintError = "Please enter a valid mint URL (e.g., https://mint.example.com)"
            return
        }
        // Check if already added
        if selectedMints.contains(trimmedURL) || discoveredMints.contains(where: { $0.url == trimmedURL }) {
            addMintError = "This mint has already been added"
            return
        }
        // Add to selected mints
        withAnimation(.easeInOut(duration: 0.2)) {
            selectedMints.insert(trimmedURL)
            manualMintURL = ""
            showManualInput = false
            addMintError = nil
        }
    }
}
// MARK: - Custom Mint Row View
struct CustomMintRowView: View {
    let mintURL: String
    let isSelected: Bool
    let onTap: () -> Void
    @Environment(WalletManager.self) private var walletManager
    @State private var mintInfo: NDKMintInfo?
    var displayName: String {
        if let name = mintInfo?.name, !name.isEmpty {
            return name
        } else if let url = URL(string: mintURL), let host = url.host {
            return host
        } else {
            return "Custom Mint"
        }
    }
    var body: some View {
        Button(action: onTap) {
            HStack(spacing: 16) {
                // Mint icon
                MintIconView(
                    mint: DiscoveredMint(url: mintURL, name: displayName),
                    mintInfo: mintInfo
                )
                // Mint info
                VStack(alignment: .leading, spacing: 4) {
                    Text(displayName)
                        .font(.system(size: 16, weight: .semibold))
                        .foregroundColor(.white)
                    if let description = mintInfo?.description, !description.isEmpty {
                        Text(description)
                            .font(.system(size: 14))
                            .foregroundColor(Color.white.opacity(0.7))
                            .lineLimit(2)
                    } else {
                        Text("Custom mint")
                            .font(.system(size: 14))
                            .foregroundColor(Color.white.opacity(0.5))
                    }
                    Text(mintURL)
                        .font(.system(size: 11, design: .monospaced))
                        .foregroundColor(Color.white.opacity(0.4))
                        .lineLimit(1)
                        .truncationMode(.middle)
                }
                Spacer()
            }
            .padding(16)
            .background(
                RoundedRectangle(cornerRadius: 16)
                    .fill(isSelected ? Color.green.opacity(0.15) : Color.white.opacity(0.05))
                    .overlay(
                        RoundedRectangle(cornerRadius: 16)
                            .stroke(isSelected ? Color.green.opacity(0.5) : Color.white.opacity(0.1), lineWidth: 1)
                    )
            )
        }
        .buttonStyle(PlainButtonStyle())
        .task {
            await loadMintInfo()
        }
    }
    private func loadMintInfo() async {
        guard mintInfo == nil,
              let wallet = walletManager.wallet,
              let url = URL(string: mintURL) else { return }
        do {
            let info = try await wallet.mints.getMintInfo(url: url)
            await MainActor.run {
                self.mintInfo = info
            }
        } catch {
            // Silently fail - we'll just use the default icon
        }
    }
}
// MARK: - Mint Row View
struct MintRowView: View {
    let mint: DiscoveredMint
    let isSelected: Bool
    let onTap: () -> Void
    @Environment(WalletManager.self) private var walletManager
    @State private var mintInfo: NDKMintInfo?
    @State private var isLoadingIcon = false
    var body: some View {
        Button(action: onTap) {
            HStack(spacing: 16) {
                // Mint icon
                MintIconView(mint: mint, mintInfo: mintInfo)
                // Mint info
                VStack(alignment: .leading, spacing: 4) {
                    Text(mint.name)
                        .font(.system(size: 16, weight: .semibold))
                        .foregroundColor(.white)
                    if let description = mint.metadata?.description ?? mint.description ?? mintInfo?.description,
                       !description.isEmpty {
                        Text(description)
                            .font(.system(size: 14))
                            .foregroundColor(Color.white.opacity(0.7))
                            .lineLimit(2)
                    }
                    Text(mint.url)
                        .font(.system(size: 11, design: .monospaced))
                        .foregroundColor(Color.white.opacity(0.4))
                        .lineLimit(1)
                        .truncationMode(.middle)
                }
                Spacer()
            }
            .padding(16)
            .background(
                RoundedRectangle(cornerRadius: 16)
                    .fill(isSelected ? Color.green.opacity(0.15) : Color.white.opacity(0.05))
                    .overlay(
                        RoundedRectangle(cornerRadius: 16)
                            .stroke(isSelected ? Color.green.opacity(0.5) : Color.white.opacity(0.1), lineWidth: 1)
                    )
            )
        }
        .buttonStyle(PlainButtonStyle())
        .task {
            await loadMintInfo()
        }
    }
    private func loadMintInfo() async {
        guard mintInfo == nil,
              let wallet = walletManager.wallet,
              let url = URL(string: mint.url) else { return }
        do {
            let info = try await wallet.mints.getMintInfo(url: url)
            await MainActor.run {
                self.mintInfo = info
            }
        } catch {
            // Silently fail - we'll just use the default icon
        }
    }
}
// MARK: - Mint Icon View
struct MintIconView: View {
    let mint: DiscoveredMint
    let mintInfo: NDKMintInfo?
    @State private var hasError = false
    var body: some View {
        ZStack {
            RoundedRectangle(cornerRadius: 12)
                .fill(
                    LinearGradient(
                        gradient: Gradient(colors: [
                            Color.green.opacity(0.2),
                            Color.green.opacity(0.1)
                        ]),
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .frame(width: 48, height: 48)
            if let iconURL = mint.metadata?.iconURL ?? mintInfo?.iconURL,
               !iconURL.isEmpty,
               let url = URL(string: iconURL),
               !hasError {
                AsyncImage(url: url) { phase in
                    switch phase {
                    case .empty:
                        ProgressView()
                            .scaleEffect(0.5)
                            .frame(width: 48, height: 48)
                    case .success(let image):
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fit)
                            .frame(width: 40, height: 40)
                            .clipShape(RoundedRectangle(cornerRadius: 8))
                    case .failure:
                        Image(systemName: "building.columns")
                            .font(.system(size: 22))
                            .foregroundColor(.green)
                            .onAppear {
                                hasError = true
                            }
                    @unknown default:
                        Image(systemName: "building.columns")
                            .font(.system(size: 22))
                            .foregroundColor(.green)
                    }
                }
            } else {
                Image(systemName: "building.columns")
                    .font(.system(size: 22))
                    .foregroundColor(.green)
            }
        }
    }
}
</file>

<file path="Sources/NutsackiOS/NutsackApp.swift">
import SwiftUI
import NDKSwift
@main
struct NutsackApp: App {
    @StateObject private var appState = AppState()
    @StateObject private var nostrManager: NostrManager
    @State private var walletManager: WalletManager
    init() {
        // Initialize logging settings from UserDefaults
        Self.initializeLoggingSettings()
        let nm = NostrManager(from: "App")
        let appStateInstance = AppState()
        let wm = WalletManager(
            nostrManager: nm,
            appState: appStateInstance
        )
        _nostrManager = StateObject(wrappedValue: nm)
        _walletManager = State(initialValue: wm)
        _appState = StateObject(wrappedValue: appStateInstance)
    }
    private static func initializeLoggingSettings() {
        let defaults = UserDefaults.standard
        // Load log level
        let savedLogLevel = defaults.integer(forKey: "ndkLogLevel")
        if savedLogLevel > 0 {
            NDKLogger.logLevel = NDKLogLevel(rawValue: savedLogLevel) ?? .debug
        }
        // Load network logging settings
        if defaults.object(forKey: "ndkLogNetworkTraffic") != nil {
            NDKLogger.logNetworkTraffic = defaults.bool(forKey: "ndkLogNetworkTraffic")
        }
        if defaults.object(forKey: "ndkPrettyPrintNetworkMessages") != nil {
            NDKLogger.prettyPrintNetworkMessages = defaults.bool(forKey: "ndkPrettyPrintNetworkMessages")
        }
        // Load enabled categories
        if let categoriesData = defaults.data(forKey: "ndkEnabledCategories"),
           let categoryStrings = JSONCoding.safeDecode(Set<String>.self, from: categoriesData) {
            let categories = Set(categoryStrings.compactMap { NDKLogCategory(rawValue: $0) })
            NDKLogger.enabledCategories = categories
        }
    }
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(appState)
                .environmentObject(nostrManager)
                .environment(walletManager)
                .preferredColorScheme(appState.themeMode.colorScheme)
        }
    }
}
</file>

<file path="project.yml">
name: NutsackiOS
options:
  bundleIdPrefix: com.nutsack
  deploymentTarget:
    iOS: "17.0"
settings:
  base:
    # Code Signing Settings - Update these with your values
    DEVELOPMENT_TEAM: "456SHKPP26"
    CODE_SIGN_STYLE: Automatic
    CODE_SIGN_IDENTITY: "Apple Development"
    PROVISIONING_PROFILE_SPECIFIER: ""
    # App Settings
    PRODUCT_BUNDLE_IDENTIFIER: com.nutsack.wallet
    MARKETING_VERSION: "1.0.0"
    CURRENT_PROJECT_VERSION: "1"
packages:
  NDKSwift:
    path: ../NDKSwift
targets:
  NutsackiOS:
    type: application
    platform: iOS
    sources: 
      - Sources/NutsackiOS
    dependencies:
      - package: NDKSwift
        product: NDKSwift
      - package: NDKSwift
        product: NDKSwiftUI
    info:
      path: Sources/NutsackiOS/Info.plist
      properties:
        UILaunchStoryboardName: LaunchScreen
        LSRequiresIPhoneOS: true
        UIApplicationSceneManifest:
          UIApplicationSupportsMultipleScenes: false
        UIRequiredDeviceCapabilities:
          - arm64
        UISupportedInterfaceOrientations:
          - UIInterfaceOrientationPortrait
          - UIInterfaceOrientationPortraitUpsideDown
          - UIInterfaceOrientationLandscapeLeft
          - UIInterfaceOrientationLandscapeRight
        UISupportedInterfaceOrientations~ipad:
          - UIInterfaceOrientationPortrait
          - UIInterfaceOrientationPortraitUpsideDown
          - UIInterfaceOrientationLandscapeLeft
          - UIInterfaceOrientationLandscapeRight
    settings:
      base:
        INFOPLIST_FILE: Sources/NutsackiOS/Info.plist
        PRODUCT_NAME: Nutsack
        ASSETCATALOG_COMPILER_APPICON_NAME: AppIcon
        TARGETED_DEVICE_FAMILY: "1,2"
        SUPPORTS_MACCATALYST: false
        SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD: false
        SWIFT_VERSION: 5.9
    preBuildScripts:
      - script: |
          if [ "${CONFIGURATION}" = "Debug" ]; then
            echo "Debug build"
          fi
        name: "Debug Check"
</file>

</files>
